{"ast":null,"code":"/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}; // import java.util.Collection;\n// import java.util.Collections;\n\n\nimport Collections from '../../util/Collections'; // import java.util.Comparator;\n// import java.util.Iterator;\n// import java.util.LinkedList;\n\nimport State from './State';\nimport * as C from './EncoderConstants';\nimport * as CharMap from './CharMap';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * This produces nearly optimal encodings of text into the first-level of\n * encoding used by Aztec code.\n *\n * It uses a dynamic algorithm.  For each prefix of the string, it determines\n * a set of encodings that could lead to this prefix.  We repeatedly add a\n * character and generate a new set of optimal encodings until we have read\n * through the entire input.\n *\n * @author Frank Yellin\n * @author Rustam Abdullaev\n */\n\nvar HighLevelEncoder = function () {\n  function HighLevelEncoder(text) {\n    this.text = text;\n  }\n  /**\n   * @return text represented by this encoder encoded as a {@link BitArray}\n   */\n\n\n  HighLevelEncoder.prototype.encode = function () {\n    var spaceCharCode = StringUtils.getCharCode(' ');\n    var lineBreakCharCode = StringUtils.getCharCode('\\n');\n    var states = Collections.singletonList(State.INITIAL_STATE);\n\n    for (var index = 0; index < this.text.length; index++) {\n      var pairCode = void 0;\n      var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n\n      switch (this.text[index]) {\n        case StringUtils.getCharCode('\\r'):\n          pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n          break;\n\n        case StringUtils.getCharCode('.'):\n          pairCode = nextChar === spaceCharCode ? 3 : 0;\n          break;\n\n        case StringUtils.getCharCode(','):\n          pairCode = nextChar === spaceCharCode ? 4 : 0;\n          break;\n\n        case StringUtils.getCharCode(':'):\n          pairCode = nextChar === spaceCharCode ? 5 : 0;\n          break;\n\n        default:\n          pairCode = 0;\n      }\n\n      if (pairCode > 0) {\n        // We have one of the four special PUNCT pairs.  Treat them specially.\n        // Get a new set of states for the two new characters.\n        states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n        index++;\n      } else {\n        // Get a new set of states for the new character.\n        states = this.updateStateListForChar(states, index);\n      }\n    } // We are left with a set of states.  Find the shortest one.\n\n\n    var minState = Collections.min(states, function (a, b) {\n      return a.getBitCount() - b.getBitCount();\n    }); // Convert it to a bit array, and return.\n\n    return minState.toBitArray(this.text);\n  }; // We update a set of states for a new character by updating each state\n  // for the new character, merging the results, and then removing the\n  // non-optimal states.\n\n\n  HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {\n    var e_1, _a;\n\n    var result = [];\n\n    try {\n      for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {\n        var state = states_1_1.value\n        /*State*/\n        ;\n        this.updateStateForChar(state, index, result);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return HighLevelEncoder.simplifyStates(result);\n  }; // Return a set of states that represent the possible ways of updating this\n  // state for the next character.  The resulting set of states are added to\n  // the \"result\" list.\n\n\n  HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {\n    var ch = this.text[index] & 0xff;\n    var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;\n    var stateNoBinary = null;\n\n    for (var mode\n    /*int*/\n    = 0; mode <= C.MODE_PUNCT; mode++) {\n      var charInMode = CharMap.CHAR_MAP[mode][ch];\n\n      if (charInMode > 0) {\n        if (stateNoBinary == null) {\n          // Only create stateNoBinary the first time it's required.\n          stateNoBinary = state.endBinaryShift(index);\n        } // Try generating the character by latching to its mode\n\n\n        if (!charInCurrentTable || mode === state.getMode() || mode === C.MODE_DIGIT) {\n          // If the character is in the current table, we don't want to latch to\n          // any other mode except possibly digit (which uses only 4 bits).  Any\n          // other latch would be equally successful *after* this character, and\n          // so wouldn't save any bits.\n          var latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n          result.push(latchState);\n        } // Try generating the character by switching to its mode.\n\n\n        if (!charInCurrentTable && ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {\n          // It never makes sense to temporarily shift to another mode if the\n          // character exists in the current mode.  That can never save bits.\n          var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n          result.push(shiftState);\n        }\n      }\n    }\n\n    if (state.getBinaryShiftByteCount() > 0 || CharMap.CHAR_MAP[state.getMode()][ch] === 0) {\n      // It's never worthwhile to go into binary shift mode if you're not already\n      // in binary shift mode, and the character exists in your current mode.\n      // That can never save bits over just outputting the char in the current mode.\n      var binaryState = state.addBinaryShiftChar(index);\n      result.push(binaryState);\n    }\n  };\n\n  HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {\n    var e_2, _a;\n\n    var result = [];\n\n    try {\n      for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {\n        var state = states_2_1.value\n        /*State*/\n        ;\n        this.updateStateForPair(state, index, pairCode, result);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return this.simplifyStates(result);\n  };\n\n  HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {\n    var stateNoBinary = state.endBinaryShift(index); // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n\n    result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));\n\n    if (state.getMode() !== C.MODE_PUNCT) {\n      // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n      // Every state except C.MODE_PUNCT (handled above) can shift\n      result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));\n    }\n\n    if (pairCode === 3 || pairCode === 4) {\n      // both characters are in DIGITS.  Sometimes better to just add two digits\n      var digitState = stateNoBinary.latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n      .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT\n\n      result.push(digitState);\n    }\n\n    if (state.getBinaryShiftByteCount() > 0) {\n      // It only makes sense to do the characters as binary if we're already\n      // in binary mode.\n      var binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);\n      result.push(binaryState);\n    }\n  };\n\n  HighLevelEncoder.simplifyStates = function (states) {\n    var e_3, _a, e_4, _b;\n\n    var result = [];\n\n    try {\n      for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {\n        var newState = states_3_1.value;\n        var add = true;\n\n        var _loop_1 = function _loop_1(oldState) {\n          if (oldState.isBetterThanOrEqualTo(newState)) {\n            add = false;\n            return \"break\";\n          }\n\n          if (newState.isBetterThanOrEqualTo(oldState)) {\n            // iterator.remove();\n            result = result.filter(function (x) {\n              return x !== oldState;\n            }); // remove old state\n          }\n        };\n\n        try {\n          for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n            var oldState = result_1_1.value;\n\n            var state_1 = _loop_1(oldState);\n\n            if (state_1 === \"break\") break;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        if (add) {\n          result.push(newState);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return result;\n  };\n\n  return HighLevelEncoder;\n}();\n\nexport default HighLevelEncoder;","map":{"version":3,"sources":["../../../../../src/core/aztec/encoder/HighLevelEncoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// import java.util.Collection;\n// import java.util.Collections;\nimport Collections from '../../util/Collections';\n// import java.util.Comparator;\n// import java.util.Iterator;\n// import java.util.LinkedList;\nimport State from './State';\nimport * as C from './EncoderConstants';\nimport * as CharMap from './CharMap';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * This produces nearly optimal encodings of text into the first-level of\n * encoding used by Aztec code.\n *\n * It uses a dynamic algorithm.  For each prefix of the string, it determines\n * a set of encodings that could lead to this prefix.  We repeatedly add a\n * character and generate a new set of optimal encodings until we have read\n * through the entire input.\n *\n * @author Frank Yellin\n * @author Rustam Abdullaev\n */\nvar HighLevelEncoder = /** @class */ (function () {\n    function HighLevelEncoder(text) {\n        this.text = text;\n    }\n    /**\n     * @return text represented by this encoder encoded as a {@link BitArray}\n     */\n    HighLevelEncoder.prototype.encode = function () {\n        var spaceCharCode = StringUtils.getCharCode(' ');\n        var lineBreakCharCode = StringUtils.getCharCode('\\n');\n        var states = Collections.singletonList(State.INITIAL_STATE);\n        for (var index = 0; index < this.text.length; index++) {\n            var pairCode = void 0;\n            var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n            switch (this.text[index]) {\n                case StringUtils.getCharCode('\\r'):\n                    pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n                    break;\n                case StringUtils.getCharCode('.'):\n                    pairCode = nextChar === spaceCharCode ? 3 : 0;\n                    break;\n                case StringUtils.getCharCode(','):\n                    pairCode = nextChar === spaceCharCode ? 4 : 0;\n                    break;\n                case StringUtils.getCharCode(':'):\n                    pairCode = nextChar === spaceCharCode ? 5 : 0;\n                    break;\n                default:\n                    pairCode = 0;\n            }\n            if (pairCode > 0) {\n                // We have one of the four special PUNCT pairs.  Treat them specially.\n                // Get a new set of states for the two new characters.\n                states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n                index++;\n            }\n            else {\n                // Get a new set of states for the new character.\n                states = this.updateStateListForChar(states, index);\n            }\n        }\n        // We are left with a set of states.  Find the shortest one.\n        var minState = Collections.min(states, function (a, b) {\n            return a.getBitCount() - b.getBitCount();\n        });\n        // Convert it to a bit array, and return.\n        return minState.toBitArray(this.text);\n    };\n    // We update a set of states for a new character by updating each state\n    // for the new character, merging the results, and then removing the\n    // non-optimal states.\n    HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {\n        var e_1, _a;\n        var result = [];\n        try {\n            for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {\n                var state = states_1_1.value /*State*/;\n                this.updateStateForChar(state, index, result);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return HighLevelEncoder.simplifyStates(result);\n    };\n    // Return a set of states that represent the possible ways of updating this\n    // state for the next character.  The resulting set of states are added to\n    // the \"result\" list.\n    HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {\n        var ch = (this.text[index] & 0xff);\n        var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;\n        var stateNoBinary = null;\n        for (var mode /*int*/ = 0; mode <= C.MODE_PUNCT; mode++) {\n            var charInMode = CharMap.CHAR_MAP[mode][ch];\n            if (charInMode > 0) {\n                if (stateNoBinary == null) {\n                    // Only create stateNoBinary the first time it's required.\n                    stateNoBinary = state.endBinaryShift(index);\n                }\n                // Try generating the character by latching to its mode\n                if (!charInCurrentTable ||\n                    mode === state.getMode() ||\n                    mode === C.MODE_DIGIT) {\n                    // If the character is in the current table, we don't want to latch to\n                    // any other mode except possibly digit (which uses only 4 bits).  Any\n                    // other latch would be equally successful *after* this character, and\n                    // so wouldn't save any bits.\n                    var latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n                    result.push(latchState);\n                }\n                // Try generating the character by switching to its mode.\n                if (!charInCurrentTable &&\n                    ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {\n                    // It never makes sense to temporarily shift to another mode if the\n                    // character exists in the current mode.  That can never save bits.\n                    var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n                    result.push(shiftState);\n                }\n            }\n        }\n        if (state.getBinaryShiftByteCount() > 0 ||\n            CharMap.CHAR_MAP[state.getMode()][ch] === 0) {\n            // It's never worthwhile to go into binary shift mode if you're not already\n            // in binary shift mode, and the character exists in your current mode.\n            // That can never save bits over just outputting the char in the current mode.\n            var binaryState = state.addBinaryShiftChar(index);\n            result.push(binaryState);\n        }\n    };\n    HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {\n        var e_2, _a;\n        var result = [];\n        try {\n            for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {\n                var state = states_2_1.value /*State*/;\n                this.updateStateForPair(state, index, pairCode, result);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return this.simplifyStates(result);\n    };\n    HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {\n        var stateNoBinary = state.endBinaryShift(index);\n        // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n        result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));\n        if (state.getMode() !== C.MODE_PUNCT) {\n            // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n            // Every state except C.MODE_PUNCT (handled above) can shift\n            result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));\n        }\n        if (pairCode === 3 || pairCode === 4) {\n            // both characters are in DIGITS.  Sometimes better to just add two digits\n            var digitState = stateNoBinary\n                .latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n                .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT\n            result.push(digitState);\n        }\n        if (state.getBinaryShiftByteCount() > 0) {\n            // It only makes sense to do the characters as binary if we're already\n            // in binary mode.\n            var binaryState = state\n                .addBinaryShiftChar(index)\n                .addBinaryShiftChar(index + 1);\n            result.push(binaryState);\n        }\n    };\n    HighLevelEncoder.simplifyStates = function (states) {\n        var e_3, _a, e_4, _b;\n        var result = [];\n        try {\n            for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {\n                var newState = states_3_1.value;\n                var add = true;\n                var _loop_1 = function (oldState) {\n                    if (oldState.isBetterThanOrEqualTo(newState)) {\n                        add = false;\n                        return \"break\";\n                    }\n                    if (newState.isBetterThanOrEqualTo(oldState)) {\n                        // iterator.remove();\n                        result = result.filter(function (x) { return x !== oldState; }); // remove old state\n                    }\n                };\n                try {\n                    for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n                        var oldState = result_1_1.value;\n                        var state_1 = _loop_1(oldState);\n                        if (state_1 === \"break\")\n                            break;\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n                if (add) {\n                    result.push(newState);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return result;\n    };\n    return HighLevelEncoder;\n}());\nexport default HighLevelEncoder;\n//# sourceMappingURL=HighLevelEncoder.js.map"]},"metadata":{},"sourceType":"module"}