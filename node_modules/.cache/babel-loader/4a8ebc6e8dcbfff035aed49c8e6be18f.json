{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/*namespace com.google.zxing.oned {*/\n\n\nimport BarcodeFormat from '../BarcodeFormat';\nimport ChecksumException from '../ChecksumException';\nimport DecodeHintType from '../DecodeHintType';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException'; // import Reader from '../Reader';\n\nimport Result from '../Result'; // import ResultMetadataType from '../ResultMetadataType';\n\nimport ResultPoint from '../ResultPoint';\nimport OneDReader from './OneDReader';\n/**\n * <p>Decodes Code 128 barcodes.</p>\n *\n * @author Sean Owen\n */\n\nvar Code128Reader = function (_super) {\n  __extends(Code128Reader, _super);\n\n  function Code128Reader() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Code128Reader.findStartPattern = function (row) {\n    var width = row.getSize();\n    var rowOffset = row.getNextSet(0);\n    var counterPosition = 0;\n    var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n    var patternStart = rowOffset;\n    var isWhite = false;\n    var patternLength = 6;\n\n    for (var i = rowOffset; i < width; i++) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          var bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n          var bestMatch = -1;\n\n          for (var startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {\n            var variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n\n            if (variance < bestVariance) {\n              bestVariance = variance;\n              bestMatch = startCode;\n            }\n          } // Look for whitespace before start pattern, >= 50% of width of start pattern\n\n\n          if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n            return Int32Array.from([patternStart, i, bestMatch]);\n          }\n\n          patternStart += counters[0] + counters[1];\n          counters = counters.slice(2, counters.length - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException();\n  };\n\n  Code128Reader.decodeCode = function (row, counters, rowOffset) {\n    OneDReader.recordPattern(row, rowOffset, counters);\n    var bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n\n    var bestMatch = -1;\n\n    for (var d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {\n      var pattern = Code128Reader.CODE_PATTERNS[d];\n      var variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = d;\n      }\n    } // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n\n\n    if (bestMatch >= 0) {\n      return bestMatch;\n    } else {\n      throw new NotFoundException();\n    }\n  };\n\n  Code128Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var convertFNC1 = hints && hints.get(DecodeHintType.ASSUME_GS1) === true;\n    var startPatternInfo = Code128Reader.findStartPattern(row);\n    var startCode = startPatternInfo[2];\n    var currentRawCodesIndex = 0;\n    var rawCodes = new Uint8Array(20);\n    rawCodes[currentRawCodesIndex++] = startCode;\n    var codeSet;\n\n    switch (startCode) {\n      case Code128Reader.CODE_START_A:\n        codeSet = Code128Reader.CODE_CODE_A;\n        break;\n\n      case Code128Reader.CODE_START_B:\n        codeSet = Code128Reader.CODE_CODE_B;\n        break;\n\n      case Code128Reader.CODE_START_C:\n        codeSet = Code128Reader.CODE_CODE_C;\n        break;\n\n      default:\n        throw new FormatException();\n    }\n\n    var done = false;\n    var isNextShifted = false;\n    var result = '';\n    var lastStart = startPatternInfo[0];\n    var nextStart = startPatternInfo[1];\n    var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n    var lastCode = 0;\n    var code = 0;\n    var checksumTotal = startCode;\n    var multiplier = 0;\n    var lastCharacterWasPrintable = true;\n    var upperMode = false;\n    var shiftUpperMode = false;\n\n    while (!done) {\n      var unshift = isNextShifted;\n      isNextShifted = false; // Save off last code\n\n      lastCode = code; // Decode another code from image\n\n      code = Code128Reader.decodeCode(row, counters, nextStart);\n      rawCodes[currentRawCodesIndex++] = code; // Remember whether the last code was printable or not (excluding CODE_STOP)\n\n      if (code !== Code128Reader.CODE_STOP) {\n        lastCharacterWasPrintable = true;\n      } // Add to checksum computation (if not CODE_STOP of course)\n\n\n      if (code !== Code128Reader.CODE_STOP) {\n        multiplier++;\n        checksumTotal += multiplier * code;\n      } // Advance to where the next code will to start\n\n\n      lastStart = nextStart;\n      nextStart += counters.reduce(function (previous, current) {\n        return previous + current;\n      }, 0); // Take care of illegal start codes\n\n      switch (code) {\n        case Code128Reader.CODE_START_A:\n        case Code128Reader.CODE_START_B:\n        case Code128Reader.CODE_START_C:\n          throw new FormatException();\n      }\n\n      switch (codeSet) {\n        case Code128Reader.CODE_CODE_A:\n          if (code < 64) {\n            if (shiftUpperMode === upperMode) {\n              result += String.fromCharCode(' '.charCodeAt(0) + code);\n            } else {\n              result += String.fromCharCode(' '.charCodeAt(0) + code + 128);\n            }\n\n            shiftUpperMode = false;\n          } else if (code < 96) {\n            if (shiftUpperMode === upperMode) {\n              result += String.fromCharCode(code - 64);\n            } else {\n              result += String.fromCharCode(code + 64);\n            }\n\n            shiftUpperMode = false;\n          } else {\n            // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n            // code was printable or not.\n            if (code !== Code128Reader.CODE_STOP) {\n              lastCharacterWasPrintable = false;\n            }\n\n            switch (code) {\n              case Code128Reader.CODE_FNC_1:\n                if (convertFNC1) {\n                  if (result.length === 0) {\n                    // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                    // is FNC1 then this is GS1-128. We add the symbology identifier.\n                    result += ']C1';\n                  } else {\n                    // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                    result += String.fromCharCode(29);\n                  }\n                }\n\n                break;\n\n              case Code128Reader.CODE_FNC_2:\n              case Code128Reader.CODE_FNC_3:\n                // do nothing?\n                break;\n\n              case Code128Reader.CODE_FNC_4_A:\n                if (!upperMode && shiftUpperMode) {\n                  upperMode = true;\n                  shiftUpperMode = false;\n                } else if (upperMode && shiftUpperMode) {\n                  upperMode = false;\n                  shiftUpperMode = false;\n                } else {\n                  shiftUpperMode = true;\n                }\n\n                break;\n\n              case Code128Reader.CODE_SHIFT:\n                isNextShifted = true;\n                codeSet = Code128Reader.CODE_CODE_B;\n                break;\n\n              case Code128Reader.CODE_CODE_B:\n                codeSet = Code128Reader.CODE_CODE_B;\n                break;\n\n              case Code128Reader.CODE_CODE_C:\n                codeSet = Code128Reader.CODE_CODE_C;\n                break;\n\n              case Code128Reader.CODE_STOP:\n                done = true;\n                break;\n            }\n          }\n\n          break;\n\n        case Code128Reader.CODE_CODE_B:\n          if (code < 96) {\n            if (shiftUpperMode === upperMode) {\n              result += String.fromCharCode(' '.charCodeAt(0) + code);\n            } else {\n              result += String.fromCharCode(' '.charCodeAt(0) + code + 128);\n            }\n\n            shiftUpperMode = false;\n          } else {\n            if (code !== Code128Reader.CODE_STOP) {\n              lastCharacterWasPrintable = false;\n            }\n\n            switch (code) {\n              case Code128Reader.CODE_FNC_1:\n                if (convertFNC1) {\n                  if (result.length === 0) {\n                    // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                    // is FNC1 then this is GS1-128. We add the symbology identifier.\n                    result += ']C1';\n                  } else {\n                    // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                    result += String.fromCharCode(29);\n                  }\n                }\n\n                break;\n\n              case Code128Reader.CODE_FNC_2:\n              case Code128Reader.CODE_FNC_3:\n                // do nothing?\n                break;\n\n              case Code128Reader.CODE_FNC_4_B:\n                if (!upperMode && shiftUpperMode) {\n                  upperMode = true;\n                  shiftUpperMode = false;\n                } else if (upperMode && shiftUpperMode) {\n                  upperMode = false;\n                  shiftUpperMode = false;\n                } else {\n                  shiftUpperMode = true;\n                }\n\n                break;\n\n              case Code128Reader.CODE_SHIFT:\n                isNextShifted = true;\n                codeSet = Code128Reader.CODE_CODE_A;\n                break;\n\n              case Code128Reader.CODE_CODE_A:\n                codeSet = Code128Reader.CODE_CODE_A;\n                break;\n\n              case Code128Reader.CODE_CODE_C:\n                codeSet = Code128Reader.CODE_CODE_C;\n                break;\n\n              case Code128Reader.CODE_STOP:\n                done = true;\n                break;\n            }\n          }\n\n          break;\n\n        case Code128Reader.CODE_CODE_C:\n          if (code < 100) {\n            if (code < 10) {\n              result += '0';\n            }\n\n            result += code;\n          } else {\n            if (code !== Code128Reader.CODE_STOP) {\n              lastCharacterWasPrintable = false;\n            }\n\n            switch (code) {\n              case Code128Reader.CODE_FNC_1:\n                if (convertFNC1) {\n                  if (result.length === 0) {\n                    // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                    // is FNC1 then this is GS1-128. We add the symbology identifier.\n                    result += ']C1';\n                  } else {\n                    // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                    result += String.fromCharCode(29);\n                  }\n                }\n\n                break;\n\n              case Code128Reader.CODE_CODE_A:\n                codeSet = Code128Reader.CODE_CODE_A;\n                break;\n\n              case Code128Reader.CODE_CODE_B:\n                codeSet = Code128Reader.CODE_CODE_B;\n                break;\n\n              case Code128Reader.CODE_STOP:\n                done = true;\n                break;\n            }\n          }\n\n          break;\n      } // Unshift back to another code set if we were shifted\n\n\n      if (unshift) {\n        codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n      }\n    }\n\n    var lastPatternSize = nextStart - lastStart; // Check for ample whitespace following pattern, but, to do this we first need to remember that\n    // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n    // to read off. Would be slightly better to properly read. Here we just skip it:\n\n    nextStart = row.getNextUnset(nextStart);\n\n    if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n      throw new NotFoundException();\n    } // Pull out from sum the value of the penultimate check code\n\n\n    checksumTotal -= multiplier * lastCode; // lastCode is the checksum then:\n\n    if (checksumTotal % 103 !== lastCode) {\n      throw new ChecksumException();\n    } // Need to pull out the check digits from string\n\n\n    var resultLength = result.length;\n\n    if (resultLength === 0) {\n      // false positive\n      throw new NotFoundException();\n    } // Only bother if the result had at least one character, and if the checksum digit happened to\n    // be a printable character. If it was just interpreted as a control code, nothing to remove.\n\n\n    if (resultLength > 0 && lastCharacterWasPrintable) {\n      if (codeSet === Code128Reader.CODE_CODE_C) {\n        result = result.substring(0, resultLength - 2);\n      } else {\n        result = result.substring(0, resultLength - 1);\n      }\n    }\n\n    var left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n    var right = lastStart + lastPatternSize / 2.0;\n    var rawCodesSize = rawCodes.length;\n    var rawBytes = new Uint8Array(rawCodesSize);\n\n    for (var i = 0; i < rawCodesSize; i++) {\n      rawBytes[i] = rawCodes[i];\n    }\n\n    var points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n    return new Result(result, rawBytes, 0, points, BarcodeFormat.CODE_128, new Date().getTime());\n  };\n\n  Code128Reader.CODE_PATTERNS = [Int32Array.from([2, 1, 2, 2, 2, 2]), Int32Array.from([2, 2, 2, 1, 2, 2]), Int32Array.from([2, 2, 2, 2, 2, 1]), Int32Array.from([1, 2, 1, 2, 2, 3]), Int32Array.from([1, 2, 1, 3, 2, 2]), Int32Array.from([1, 3, 1, 2, 2, 2]), Int32Array.from([1, 2, 2, 2, 1, 3]), Int32Array.from([1, 2, 2, 3, 1, 2]), Int32Array.from([1, 3, 2, 2, 1, 2]), Int32Array.from([2, 2, 1, 2, 1, 3]), Int32Array.from([2, 2, 1, 3, 1, 2]), Int32Array.from([2, 3, 1, 2, 1, 2]), Int32Array.from([1, 1, 2, 2, 3, 2]), Int32Array.from([1, 2, 2, 1, 3, 2]), Int32Array.from([1, 2, 2, 2, 3, 1]), Int32Array.from([1, 1, 3, 2, 2, 2]), Int32Array.from([1, 2, 3, 1, 2, 2]), Int32Array.from([1, 2, 3, 2, 2, 1]), Int32Array.from([2, 2, 3, 2, 1, 1]), Int32Array.from([2, 2, 1, 1, 3, 2]), Int32Array.from([2, 2, 1, 2, 3, 1]), Int32Array.from([2, 1, 3, 2, 1, 2]), Int32Array.from([2, 2, 3, 1, 1, 2]), Int32Array.from([3, 1, 2, 1, 3, 1]), Int32Array.from([3, 1, 1, 2, 2, 2]), Int32Array.from([3, 2, 1, 1, 2, 2]), Int32Array.from([3, 2, 1, 2, 2, 1]), Int32Array.from([3, 1, 2, 2, 1, 2]), Int32Array.from([3, 2, 2, 1, 1, 2]), Int32Array.from([3, 2, 2, 2, 1, 1]), Int32Array.from([2, 1, 2, 1, 2, 3]), Int32Array.from([2, 1, 2, 3, 2, 1]), Int32Array.from([2, 3, 2, 1, 2, 1]), Int32Array.from([1, 1, 1, 3, 2, 3]), Int32Array.from([1, 3, 1, 1, 2, 3]), Int32Array.from([1, 3, 1, 3, 2, 1]), Int32Array.from([1, 1, 2, 3, 1, 3]), Int32Array.from([1, 3, 2, 1, 1, 3]), Int32Array.from([1, 3, 2, 3, 1, 1]), Int32Array.from([2, 1, 1, 3, 1, 3]), Int32Array.from([2, 3, 1, 1, 1, 3]), Int32Array.from([2, 3, 1, 3, 1, 1]), Int32Array.from([1, 1, 2, 1, 3, 3]), Int32Array.from([1, 1, 2, 3, 3, 1]), Int32Array.from([1, 3, 2, 1, 3, 1]), Int32Array.from([1, 1, 3, 1, 2, 3]), Int32Array.from([1, 1, 3, 3, 2, 1]), Int32Array.from([1, 3, 3, 1, 2, 1]), Int32Array.from([3, 1, 3, 1, 2, 1]), Int32Array.from([2, 1, 1, 3, 3, 1]), Int32Array.from([2, 3, 1, 1, 3, 1]), Int32Array.from([2, 1, 3, 1, 1, 3]), Int32Array.from([2, 1, 3, 3, 1, 1]), Int32Array.from([2, 1, 3, 1, 3, 1]), Int32Array.from([3, 1, 1, 1, 2, 3]), Int32Array.from([3, 1, 1, 3, 2, 1]), Int32Array.from([3, 3, 1, 1, 2, 1]), Int32Array.from([3, 1, 2, 1, 1, 3]), Int32Array.from([3, 1, 2, 3, 1, 1]), Int32Array.from([3, 3, 2, 1, 1, 1]), Int32Array.from([3, 1, 4, 1, 1, 1]), Int32Array.from([2, 2, 1, 4, 1, 1]), Int32Array.from([4, 3, 1, 1, 1, 1]), Int32Array.from([1, 1, 1, 2, 2, 4]), Int32Array.from([1, 1, 1, 4, 2, 2]), Int32Array.from([1, 2, 1, 1, 2, 4]), Int32Array.from([1, 2, 1, 4, 2, 1]), Int32Array.from([1, 4, 1, 1, 2, 2]), Int32Array.from([1, 4, 1, 2, 2, 1]), Int32Array.from([1, 1, 2, 2, 1, 4]), Int32Array.from([1, 1, 2, 4, 1, 2]), Int32Array.from([1, 2, 2, 1, 1, 4]), Int32Array.from([1, 2, 2, 4, 1, 1]), Int32Array.from([1, 4, 2, 1, 1, 2]), Int32Array.from([1, 4, 2, 2, 1, 1]), Int32Array.from([2, 4, 1, 2, 1, 1]), Int32Array.from([2, 2, 1, 1, 1, 4]), Int32Array.from([4, 1, 3, 1, 1, 1]), Int32Array.from([2, 4, 1, 1, 1, 2]), Int32Array.from([1, 3, 4, 1, 1, 1]), Int32Array.from([1, 1, 1, 2, 4, 2]), Int32Array.from([1, 2, 1, 1, 4, 2]), Int32Array.from([1, 2, 1, 2, 4, 1]), Int32Array.from([1, 1, 4, 2, 1, 2]), Int32Array.from([1, 2, 4, 1, 1, 2]), Int32Array.from([1, 2, 4, 2, 1, 1]), Int32Array.from([4, 1, 1, 2, 1, 2]), Int32Array.from([4, 2, 1, 1, 1, 2]), Int32Array.from([4, 2, 1, 2, 1, 1]), Int32Array.from([2, 1, 2, 1, 4, 1]), Int32Array.from([2, 1, 4, 1, 2, 1]), Int32Array.from([4, 1, 2, 1, 2, 1]), Int32Array.from([1, 1, 1, 1, 4, 3]), Int32Array.from([1, 1, 1, 3, 4, 1]), Int32Array.from([1, 3, 1, 1, 4, 1]), Int32Array.from([1, 1, 4, 1, 1, 3]), Int32Array.from([1, 1, 4, 3, 1, 1]), Int32Array.from([4, 1, 1, 1, 1, 3]), Int32Array.from([4, 1, 1, 3, 1, 1]), Int32Array.from([1, 1, 3, 1, 4, 1]), Int32Array.from([1, 1, 4, 1, 3, 1]), Int32Array.from([3, 1, 1, 1, 4, 1]), Int32Array.from([4, 1, 1, 1, 3, 1]), Int32Array.from([2, 1, 1, 4, 1, 2]), Int32Array.from([2, 1, 1, 2, 1, 4]), Int32Array.from([2, 1, 1, 2, 3, 2]), Int32Array.from([2, 3, 3, 1, 1, 1, 2])];\n  Code128Reader.MAX_AVG_VARIANCE = 0.25;\n  Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n  Code128Reader.CODE_SHIFT = 98;\n  Code128Reader.CODE_CODE_C = 99;\n  Code128Reader.CODE_CODE_B = 100;\n  Code128Reader.CODE_CODE_A = 101;\n  Code128Reader.CODE_FNC_1 = 102;\n  Code128Reader.CODE_FNC_2 = 97;\n  Code128Reader.CODE_FNC_3 = 96;\n  Code128Reader.CODE_FNC_4_A = 101;\n  Code128Reader.CODE_FNC_4_B = 100;\n  Code128Reader.CODE_START_A = 103;\n  Code128Reader.CODE_START_B = 104;\n  Code128Reader.CODE_START_C = 105;\n  Code128Reader.CODE_STOP = 106;\n  return Code128Reader;\n}(OneDReader);\n\nexport default Code128Reader;","map":{"version":3,"sources":["../../../../src/core/oned/Code128Reader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/*namespace com.google.zxing.oned {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport ChecksumException from '../ChecksumException';\nimport DecodeHintType from '../DecodeHintType';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException';\n// import Reader from '../Reader';\nimport Result from '../Result';\n// import ResultMetadataType from '../ResultMetadataType';\nimport ResultPoint from '../ResultPoint';\nimport OneDReader from './OneDReader';\n/**\n * <p>Decodes Code 128 barcodes.</p>\n *\n * @author Sean Owen\n */\nvar Code128Reader = /** @class */ (function (_super) {\n    __extends(Code128Reader, _super);\n    function Code128Reader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Code128Reader.findStartPattern = function (row) {\n        var width = row.getSize();\n        var rowOffset = row.getNextSet(0);\n        var counterPosition = 0;\n        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n        var patternStart = rowOffset;\n        var isWhite = false;\n        var patternLength = 6;\n        for (var i = rowOffset; i < width; i++) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === (patternLength - 1)) {\n                    var bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n                    var bestMatch = -1;\n                    for (var startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {\n                        var variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                        if (variance < bestVariance) {\n                            bestVariance = variance;\n                            bestMatch = startCode;\n                        }\n                    }\n                    // Look for whitespace before start pattern, >= 50% of width of start pattern\n                    if (bestMatch >= 0 &&\n                        row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n                        return Int32Array.from([patternStart, i, bestMatch]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters = counters.slice(2, counters.length - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException();\n    };\n    Code128Reader.decodeCode = function (row, counters, rowOffset) {\n        OneDReader.recordPattern(row, rowOffset, counters);\n        var bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n        var bestMatch = -1;\n        for (var d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {\n            var pattern = Code128Reader.CODE_PATTERNS[d];\n            var variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = d;\n            }\n        }\n        // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException();\n        }\n    };\n    Code128Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var convertFNC1 = hints && (hints.get(DecodeHintType.ASSUME_GS1) === true);\n        var startPatternInfo = Code128Reader.findStartPattern(row);\n        var startCode = startPatternInfo[2];\n        var currentRawCodesIndex = 0;\n        var rawCodes = new Uint8Array(20);\n        rawCodes[currentRawCodesIndex++] = startCode;\n        var codeSet;\n        switch (startCode) {\n            case Code128Reader.CODE_START_A:\n                codeSet = Code128Reader.CODE_CODE_A;\n                break;\n            case Code128Reader.CODE_START_B:\n                codeSet = Code128Reader.CODE_CODE_B;\n                break;\n            case Code128Reader.CODE_START_C:\n                codeSet = Code128Reader.CODE_CODE_C;\n                break;\n            default:\n                throw new FormatException();\n        }\n        var done = false;\n        var isNextShifted = false;\n        var result = '';\n        var lastStart = startPatternInfo[0];\n        var nextStart = startPatternInfo[1];\n        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n        var lastCode = 0;\n        var code = 0;\n        var checksumTotal = startCode;\n        var multiplier = 0;\n        var lastCharacterWasPrintable = true;\n        var upperMode = false;\n        var shiftUpperMode = false;\n        while (!done) {\n            var unshift = isNextShifted;\n            isNextShifted = false;\n            // Save off last code\n            lastCode = code;\n            // Decode another code from image\n            code = Code128Reader.decodeCode(row, counters, nextStart);\n            rawCodes[currentRawCodesIndex++] = code;\n            // Remember whether the last code was printable or not (excluding CODE_STOP)\n            if (code !== Code128Reader.CODE_STOP) {\n                lastCharacterWasPrintable = true;\n            }\n            // Add to checksum computation (if not CODE_STOP of course)\n            if (code !== Code128Reader.CODE_STOP) {\n                multiplier++;\n                checksumTotal += multiplier * code;\n            }\n            // Advance to where the next code will to start\n            lastStart = nextStart;\n            nextStart += counters.reduce(function (previous, current) { return previous + current; }, 0);\n            // Take care of illegal start codes\n            switch (code) {\n                case Code128Reader.CODE_START_A:\n                case Code128Reader.CODE_START_B:\n                case Code128Reader.CODE_START_C:\n                    throw new FormatException();\n            }\n            switch (codeSet) {\n                case Code128Reader.CODE_CODE_A:\n                    if (code < 64) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code));\n                        }\n                        else {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else if (code < 96) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((code - 64));\n                        }\n                        else {\n                            result += String.fromCharCode((code + 64));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else {\n                        // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n                        // code was printable or not.\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_FNC_2:\n                            case Code128Reader.CODE_FNC_3:\n                                // do nothing?\n                                break;\n                            case Code128Reader.CODE_FNC_4_A:\n                                if (!upperMode && shiftUpperMode) {\n                                    upperMode = true;\n                                    shiftUpperMode = false;\n                                }\n                                else if (upperMode && shiftUpperMode) {\n                                    upperMode = false;\n                                    shiftUpperMode = false;\n                                }\n                                else {\n                                    shiftUpperMode = true;\n                                }\n                                break;\n                            case Code128Reader.CODE_SHIFT:\n                                isNextShifted = true;\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_CODE_B:\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_CODE_C:\n                                codeSet = Code128Reader.CODE_CODE_C;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n                case Code128Reader.CODE_CODE_B:\n                    if (code < 96) {\n                        if (shiftUpperMode === upperMode) {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code));\n                        }\n                        else {\n                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                        }\n                        shiftUpperMode = false;\n                    }\n                    else {\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_FNC_2:\n                            case Code128Reader.CODE_FNC_3:\n                                // do nothing?\n                                break;\n                            case Code128Reader.CODE_FNC_4_B:\n                                if (!upperMode && shiftUpperMode) {\n                                    upperMode = true;\n                                    shiftUpperMode = false;\n                                }\n                                else if (upperMode && shiftUpperMode) {\n                                    upperMode = false;\n                                    shiftUpperMode = false;\n                                }\n                                else {\n                                    shiftUpperMode = true;\n                                }\n                                break;\n                            case Code128Reader.CODE_SHIFT:\n                                isNextShifted = true;\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_A:\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_C:\n                                codeSet = Code128Reader.CODE_CODE_C;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n                case Code128Reader.CODE_CODE_C:\n                    if (code < 100) {\n                        if (code < 10) {\n                            result += '0';\n                        }\n                        result += code;\n                    }\n                    else {\n                        if (code !== Code128Reader.CODE_STOP) {\n                            lastCharacterWasPrintable = false;\n                        }\n                        switch (code) {\n                            case Code128Reader.CODE_FNC_1:\n                                if (convertFNC1) {\n                                    if (result.length === 0) {\n                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                        // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                        result += ']C1';\n                                    }\n                                    else {\n                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                        result += String.fromCharCode(29);\n                                    }\n                                }\n                                break;\n                            case Code128Reader.CODE_CODE_A:\n                                codeSet = Code128Reader.CODE_CODE_A;\n                                break;\n                            case Code128Reader.CODE_CODE_B:\n                                codeSet = Code128Reader.CODE_CODE_B;\n                                break;\n                            case Code128Reader.CODE_STOP:\n                                done = true;\n                                break;\n                        }\n                    }\n                    break;\n            }\n            // Unshift back to another code set if we were shifted\n            if (unshift) {\n                codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n            }\n        }\n        var lastPatternSize = nextStart - lastStart;\n        // Check for ample whitespace following pattern, but, to do this we first need to remember that\n        // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n        // to read off. Would be slightly better to properly read. Here we just skip it:\n        nextStart = row.getNextUnset(nextStart);\n        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n            throw new NotFoundException();\n        }\n        // Pull out from sum the value of the penultimate check code\n        checksumTotal -= multiplier * lastCode;\n        // lastCode is the checksum then:\n        if (checksumTotal % 103 !== lastCode) {\n            throw new ChecksumException();\n        }\n        // Need to pull out the check digits from string\n        var resultLength = result.length;\n        if (resultLength === 0) {\n            // false positive\n            throw new NotFoundException();\n        }\n        // Only bother if the result had at least one character, and if the checksum digit happened to\n        // be a printable character. If it was just interpreted as a control code, nothing to remove.\n        if (resultLength > 0 && lastCharacterWasPrintable) {\n            if (codeSet === Code128Reader.CODE_CODE_C) {\n                result = result.substring(0, resultLength - 2);\n            }\n            else {\n                result = result.substring(0, resultLength - 1);\n            }\n        }\n        var left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n        var right = lastStart + lastPatternSize / 2.0;\n        var rawCodesSize = rawCodes.length;\n        var rawBytes = new Uint8Array(rawCodesSize);\n        for (var i = 0; i < rawCodesSize; i++) {\n            rawBytes[i] = rawCodes[i];\n        }\n        var points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n        return new Result(result, rawBytes, 0, points, BarcodeFormat.CODE_128, new Date().getTime());\n    };\n    Code128Reader.CODE_PATTERNS = [\n        Int32Array.from([2, 1, 2, 2, 2, 2]),\n        Int32Array.from([2, 2, 2, 1, 2, 2]),\n        Int32Array.from([2, 2, 2, 2, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 2, 3]),\n        Int32Array.from([1, 2, 1, 3, 2, 2]),\n        Int32Array.from([1, 3, 1, 2, 2, 2]),\n        Int32Array.from([1, 2, 2, 2, 1, 3]),\n        Int32Array.from([1, 2, 2, 3, 1, 2]),\n        Int32Array.from([1, 3, 2, 2, 1, 2]),\n        Int32Array.from([2, 2, 1, 2, 1, 3]),\n        Int32Array.from([2, 2, 1, 3, 1, 2]),\n        Int32Array.from([2, 3, 1, 2, 1, 2]),\n        Int32Array.from([1, 1, 2, 2, 3, 2]),\n        Int32Array.from([1, 2, 2, 1, 3, 2]),\n        Int32Array.from([1, 2, 2, 2, 3, 1]),\n        Int32Array.from([1, 1, 3, 2, 2, 2]),\n        Int32Array.from([1, 2, 3, 1, 2, 2]),\n        Int32Array.from([1, 2, 3, 2, 2, 1]),\n        Int32Array.from([2, 2, 3, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 3, 2]),\n        Int32Array.from([2, 2, 1, 2, 3, 1]),\n        Int32Array.from([2, 1, 3, 2, 1, 2]),\n        Int32Array.from([2, 2, 3, 1, 1, 2]),\n        Int32Array.from([3, 1, 2, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 2, 2, 2]),\n        Int32Array.from([3, 2, 1, 1, 2, 2]),\n        Int32Array.from([3, 2, 1, 2, 2, 1]),\n        Int32Array.from([3, 1, 2, 2, 1, 2]),\n        Int32Array.from([3, 2, 2, 1, 1, 2]),\n        Int32Array.from([3, 2, 2, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 2, 3]),\n        Int32Array.from([2, 1, 2, 3, 2, 1]),\n        Int32Array.from([2, 3, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 3, 2, 3]),\n        Int32Array.from([1, 3, 1, 1, 2, 3]),\n        Int32Array.from([1, 3, 1, 3, 2, 1]),\n        Int32Array.from([1, 1, 2, 3, 1, 3]),\n        Int32Array.from([1, 3, 2, 1, 1, 3]),\n        Int32Array.from([1, 3, 2, 3, 1, 1]),\n        Int32Array.from([2, 1, 1, 3, 1, 3]),\n        Int32Array.from([2, 3, 1, 1, 1, 3]),\n        Int32Array.from([2, 3, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 3, 3]),\n        Int32Array.from([1, 1, 2, 3, 3, 1]),\n        Int32Array.from([1, 3, 2, 1, 3, 1]),\n        Int32Array.from([1, 1, 3, 1, 2, 3]),\n        Int32Array.from([1, 1, 3, 3, 2, 1]),\n        Int32Array.from([1, 3, 3, 1, 2, 1]),\n        Int32Array.from([3, 1, 3, 1, 2, 1]),\n        Int32Array.from([2, 1, 1, 3, 3, 1]),\n        Int32Array.from([2, 3, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 3, 1, 1, 3]),\n        Int32Array.from([2, 1, 3, 3, 1, 1]),\n        Int32Array.from([2, 1, 3, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 2, 3]),\n        Int32Array.from([3, 1, 1, 3, 2, 1]),\n        Int32Array.from([3, 3, 1, 1, 2, 1]),\n        Int32Array.from([3, 1, 2, 1, 1, 3]),\n        Int32Array.from([3, 1, 2, 3, 1, 1]),\n        Int32Array.from([3, 3, 2, 1, 1, 1]),\n        Int32Array.from([3, 1, 4, 1, 1, 1]),\n        Int32Array.from([2, 2, 1, 4, 1, 1]),\n        Int32Array.from([4, 3, 1, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2, 4]),\n        Int32Array.from([1, 1, 1, 4, 2, 2]),\n        Int32Array.from([1, 2, 1, 1, 2, 4]),\n        Int32Array.from([1, 2, 1, 4, 2, 1]),\n        Int32Array.from([1, 4, 1, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 2, 2, 1]),\n        Int32Array.from([1, 1, 2, 2, 1, 4]),\n        Int32Array.from([1, 1, 2, 4, 1, 2]),\n        Int32Array.from([1, 2, 2, 1, 1, 4]),\n        Int32Array.from([1, 2, 2, 4, 1, 1]),\n        Int32Array.from([1, 4, 2, 1, 1, 2]),\n        Int32Array.from([1, 4, 2, 2, 1, 1]),\n        Int32Array.from([2, 4, 1, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 1, 4]),\n        Int32Array.from([4, 1, 3, 1, 1, 1]),\n        Int32Array.from([2, 4, 1, 1, 1, 2]),\n        Int32Array.from([1, 3, 4, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 4, 2]),\n        Int32Array.from([1, 2, 1, 1, 4, 2]),\n        Int32Array.from([1, 2, 1, 2, 4, 1]),\n        Int32Array.from([1, 1, 4, 2, 1, 2]),\n        Int32Array.from([1, 2, 4, 1, 1, 2]),\n        Int32Array.from([1, 2, 4, 2, 1, 1]),\n        Int32Array.from([4, 1, 1, 2, 1, 2]),\n        Int32Array.from([4, 2, 1, 1, 1, 2]),\n        Int32Array.from([4, 2, 1, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 4, 1]),\n        Int32Array.from([2, 1, 4, 1, 2, 1]),\n        Int32Array.from([4, 1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 1, 4, 3]),\n        Int32Array.from([1, 1, 1, 3, 4, 1]),\n        Int32Array.from([1, 3, 1, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 1, 3]),\n        Int32Array.from([1, 1, 4, 3, 1, 1]),\n        Int32Array.from([4, 1, 1, 1, 1, 3]),\n        Int32Array.from([4, 1, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 4, 1]),\n        Int32Array.from([4, 1, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 1, 4, 1, 2]),\n        Int32Array.from([2, 1, 1, 2, 1, 4]),\n        Int32Array.from([2, 1, 1, 2, 3, 2]),\n        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),\n    ];\n    Code128Reader.MAX_AVG_VARIANCE = 0.25;\n    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    Code128Reader.CODE_SHIFT = 98;\n    Code128Reader.CODE_CODE_C = 99;\n    Code128Reader.CODE_CODE_B = 100;\n    Code128Reader.CODE_CODE_A = 101;\n    Code128Reader.CODE_FNC_1 = 102;\n    Code128Reader.CODE_FNC_2 = 97;\n    Code128Reader.CODE_FNC_3 = 96;\n    Code128Reader.CODE_FNC_4_A = 101;\n    Code128Reader.CODE_FNC_4_B = 100;\n    Code128Reader.CODE_START_A = 103;\n    Code128Reader.CODE_START_B = 104;\n    Code128Reader.CODE_START_C = 105;\n    Code128Reader.CODE_STOP = 106;\n    return Code128Reader;\n}(OneDReader));\nexport default Code128Reader;\n//# sourceMappingURL=Code128Reader.js.map"]},"metadata":{},"sourceType":"module"}