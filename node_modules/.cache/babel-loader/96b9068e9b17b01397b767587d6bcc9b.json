{"ast":null,"code":"/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*namespace com.google.zxing.qrcode.decoder {*/\nimport BitSource from '../../common/BitSource';\nimport CharacterSetECI from '../../common/CharacterSetECI';\nimport DecoderResult from '../../common/DecoderResult';\nimport StringUtils from '../../common/StringUtils';\nimport FormatException from '../../FormatException';\nimport StringBuilder from '../../util/StringBuilder';\nimport StringEncoding from '../../util/StringEncoding';\nimport Mode from './Mode';\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\n\nvar DecodedBitStreamParser = function () {\n  function DecodedBitStreamParser() {}\n\n  DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n    var bits = new BitSource(bytes);\n    var result = new StringBuilder();\n    var byteSegments = new Array(); // 1\n    // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n\n    var symbolSequence = -1;\n    var parityData = -1;\n\n    try {\n      var currentCharacterSetECI = null;\n      var fc1InEffect = false;\n      var mode = void 0;\n\n      do {\n        // While still another segment to read...\n        if (bits.available() < 4) {\n          // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n          mode = Mode.TERMINATOR;\n        } else {\n          var modeBits = bits.readBits(4);\n          mode = Mode.forBits(modeBits); // mode is encoded by 4 bits\n        }\n\n        switch (mode) {\n          case Mode.TERMINATOR:\n            break;\n\n          case Mode.FNC1_FIRST_POSITION:\n          case Mode.FNC1_SECOND_POSITION:\n            // We do little with FNC1 except alter the parsed result a bit according to the spec\n            fc1InEffect = true;\n            break;\n\n          case Mode.STRUCTURED_APPEND:\n            if (bits.available() < 16) {\n              throw new FormatException();\n            } // sequence number and parity is added later to the result metadata\n            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n\n\n            symbolSequence = bits.readBits(8);\n            parityData = bits.readBits(8);\n            break;\n\n          case Mode.ECI:\n            // Count doesn't apply to ECI\n            var value = DecodedBitStreamParser.parseECIValue(bits);\n            currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);\n\n            if (currentCharacterSetECI === null) {\n              throw new FormatException();\n            }\n\n            break;\n\n          case Mode.HANZI:\n            // First handle Hanzi mode which does not start with character count\n            // Chinese mode contains a sub set indicator right after mode indicator\n            var subset = bits.readBits(4);\n            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n\n            if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n              DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n            }\n\n            break;\n\n          default:\n            // \"Normal\" QR code modes:\n            // How many characters will follow, encoded in this mode?\n            var count = bits.readBits(mode.getCharacterCountBits(version));\n\n            switch (mode) {\n              case Mode.NUMERIC:\n                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                break;\n\n              case Mode.ALPHANUMERIC:\n                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                break;\n\n              case Mode.BYTE:\n                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                break;\n\n              case Mode.KANJI:\n                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                break;\n\n              default:\n                throw new FormatException();\n            }\n\n            break;\n        }\n      } while (mode !== Mode.TERMINATOR);\n    } catch (iae\n    /*: IllegalArgumentException*/\n    ) {\n      // from readBits() calls\n      throw new FormatException();\n    }\n\n    return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n  };\n  /**\n   * See specification GBT 18284-2000\n   */\n\n\n  DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n\n      if (assembledTwoBytes < 0x003BF) {\n        // In the 0xA1A1 to 0xAAFE range\n        assembledTwoBytes += 0x0A1A1;\n      } else {\n        // In the 0xB0A1 to 0xFAFE range\n        assembledTwoBytes += 0x0A6A1;\n      }\n\n      buffer[offset] = assembledTwoBytes >> 8 & 0xFF;\n      buffer[offset + 1] = assembledTwoBytes & 0xFF;\n      offset += 2;\n      count--;\n    }\n\n    try {\n      result.append(StringEncoding.decode(buffer, StringUtils.GB2312)); // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as Shift_JIS afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n\n      if (assembledTwoBytes < 0x01F00) {\n        // In the 0x8140 to 0x9FFC range\n        assembledTwoBytes += 0x08140;\n      } else {\n        // In the 0xE040 to 0xEBBF range\n        assembledTwoBytes += 0x0C140;\n      }\n\n      buffer[offset] = assembledTwoBytes >> 8;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes;\n      offset += 2;\n      count--;\n    } // Shift_JIS may not be supported in some environments:\n\n\n    try {\n      result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS)); // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeByteSegment = function (bits, result, count\n  /*int*/\n  , currentCharacterSetECI, byteSegments, hints) {\n    // Don't crash trying to read more bits than we have available.\n    if (8 * count > bits.available()) {\n      throw new FormatException();\n    }\n\n    var readBytes = new Uint8Array(count);\n\n    for (var i = 0; i < count; i++) {\n      readBytes[i] =\n      /*(byte) */\n      bits.readBits(8);\n    }\n\n    var encoding;\n\n    if (currentCharacterSetECI === null) {\n      // The spec isn't clear on this mode; see\n      // section 6.4.5: t does not say which encoding to assuming\n      // upon decoding. I have seen ISO-8859-1 used as well as\n      // Shift_JIS -- without anything like an ECI designator to\n      // give a hint.\n      encoding = StringUtils.guessEncoding(readBytes, hints);\n    } else {\n      encoding = currentCharacterSetECI.getName();\n    }\n\n    try {\n      result.append(StringEncoding.decode(readBytes, encoding));\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException(ignored);\n    }\n\n    byteSegments.push(readBytes);\n  };\n\n  DecodedBitStreamParser.toAlphaNumericChar = function (value\n  /*int*/\n  ) {\n    if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n      throw new FormatException();\n    }\n\n    return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n  };\n\n  DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count\n  /*int*/\n  , fc1InEffect) {\n    // Read two characters at a time\n    var start = result.length();\n\n    while (count > 1) {\n      if (bits.available() < 11) {\n        throw new FormatException();\n      }\n\n      var nextTwoCharsBits = bits.readBits(11);\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n      count -= 2;\n    }\n\n    if (count === 1) {\n      // special case: one character left\n      if (bits.available() < 6) {\n        throw new FormatException();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n    } // See section 6.4.8.1, 6.4.8.2\n\n\n    if (fc1InEffect) {\n      // We need to massage the result a bit if in an FNC1 mode:\n      for (var i = start; i < result.length(); i++) {\n        if (result.charAt(i) === '%') {\n          if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n            // %% is rendered as %\n            result.deleteCharAt(i + 1);\n          } else {\n            // In alpha mode, % should be converted to FNC1 separator 0x1D\n            result.setCharAt(i, String.fromCharCode(0x1D));\n          }\n        }\n      }\n    }\n  };\n\n  DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Read three digits at a time\n    while (count >= 3) {\n      // Each 10 bits encodes three digits\n      if (bits.available() < 10) {\n        throw new FormatException();\n      }\n\n      var threeDigitsBits = bits.readBits(10);\n\n      if (threeDigitsBits >= 1000) {\n        throw new FormatException();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n      count -= 3;\n    }\n\n    if (count === 2) {\n      // Two digits left over to read, encoded in 7 bits\n      if (bits.available() < 7) {\n        throw new FormatException();\n      }\n\n      var twoDigitsBits = bits.readBits(7);\n\n      if (twoDigitsBits >= 100) {\n        throw new FormatException();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n    } else if (count === 1) {\n      // One digit left over to read\n      if (bits.available() < 4) {\n        throw new FormatException();\n      }\n\n      var digitBits = bits.readBits(4);\n\n      if (digitBits >= 10) {\n        throw new FormatException();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n    }\n  };\n\n  DecodedBitStreamParser.parseECIValue = function (bits) {\n    var firstByte = bits.readBits(8);\n\n    if ((firstByte & 0x80) === 0) {\n      // just one byte\n      return firstByte & 0x7F;\n    }\n\n    if ((firstByte & 0xC0) === 0x80) {\n      // two bytes\n      var secondByte = bits.readBits(8);\n      return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n    }\n\n    if ((firstByte & 0xE0) === 0xC0) {\n      // three bytes\n      var secondThirdBytes = bits.readBits(16);\n      return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n    }\n\n    throw new FormatException();\n  };\n  /**\n   * See ISO 18004:2006, 6.4.4 Table 5\n   */\n\n\n  DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n  DecodedBitStreamParser.GB2312_SUBSET = 1;\n  return DecodedBitStreamParser;\n}();\n\nexport default DecodedBitStreamParser; // function Uint8ArrayToString(a: Uint8Array): string {\n//     const CHUNK_SZ = 0x8000;\n//     const c = new StringBuilder();\n//     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n//         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n//     }\n//     return c.toString();\n// }","map":{"version":3,"sources":["../../../../../src/core/qrcode/decoder/DecodedBitStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*namespace com.google.zxing.qrcode.decoder {*/\nimport BitSource from '../../common/BitSource';\nimport CharacterSetECI from '../../common/CharacterSetECI';\nimport DecoderResult from '../../common/DecoderResult';\nimport StringUtils from '../../common/StringUtils';\nimport FormatException from '../../FormatException';\nimport StringBuilder from '../../util/StringBuilder';\nimport StringEncoding from '../../util/StringEncoding';\nimport Mode from './Mode';\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n        var bits = new BitSource(bytes);\n        var result = new StringBuilder();\n        var byteSegments = new Array(); // 1\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n        var symbolSequence = -1;\n        var parityData = -1;\n        try {\n            var currentCharacterSetECI = null;\n            var fc1InEffect = false;\n            var mode = void 0;\n            do {\n                // While still another segment to read...\n                if (bits.available() < 4) {\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                    mode = Mode.TERMINATOR;\n                }\n                else {\n                    var modeBits = bits.readBits(4);\n                    mode = Mode.forBits(modeBits); // mode is encoded by 4 bits\n                }\n                switch (mode) {\n                    case Mode.TERMINATOR:\n                        break;\n                    case Mode.FNC1_FIRST_POSITION:\n                    case Mode.FNC1_SECOND_POSITION:\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\n                        fc1InEffect = true;\n                        break;\n                    case Mode.STRUCTURED_APPEND:\n                        if (bits.available() < 16) {\n                            throw new FormatException();\n                        }\n                        // sequence number and parity is added later to the result metadata\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                        symbolSequence = bits.readBits(8);\n                        parityData = bits.readBits(8);\n                        break;\n                    case Mode.ECI:\n                        // Count doesn't apply to ECI\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\n                        currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);\n                        if (currentCharacterSetECI === null) {\n                            throw new FormatException();\n                        }\n                        break;\n                    case Mode.HANZI:\n                        // First handle Hanzi mode which does not start with character count\n                        // Chinese mode contains a sub set indicator right after mode indicator\n                        var subset = bits.readBits(4);\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n                        }\n                        break;\n                    default:\n                        // \"Normal\" QR code modes:\n                        // How many characters will follow, encoded in this mode?\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\n                        switch (mode) {\n                            case Mode.NUMERIC:\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                                break;\n                            case Mode.ALPHANUMERIC:\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                break;\n                            case Mode.BYTE:\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                break;\n                            case Mode.KANJI:\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                                break;\n                            default:\n                                throw new FormatException();\n                        }\n                        break;\n                }\n            } while (mode !== Mode.TERMINATOR);\n        }\n        catch (iae /*: IllegalArgumentException*/) {\n            // from readBits() calls\n            throw new FormatException();\n        }\n        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n    };\n    /**\n     * See specification GBT 18284-2000\n     */\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as GB2312 afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n            if (assembledTwoBytes < 0x003BF) {\n                // In the 0xA1A1 to 0xAAFE range\n                assembledTwoBytes += 0x0A1A1;\n            }\n            else {\n                // In the 0xB0A1 to 0xFAFE range\n                assembledTwoBytes += 0x0A6A1;\n            }\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n            offset += 2;\n            count--;\n        }\n        try {\n            result.append(StringEncoding.decode(buffer, StringUtils.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as Shift_JIS afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n            if (assembledTwoBytes < 0x01F00) {\n                // In the 0x8140 to 0x9FFC range\n                assembledTwoBytes += 0x08140;\n            }\n            else {\n                // In the 0xE040 to 0xEBBF range\n                assembledTwoBytes += 0x0C140;\n            }\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n            offset += 2;\n            count--;\n        }\n        // Shift_JIS may not be supported in some environments:\n        try {\n            result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n        // Don't crash trying to read more bits than we have available.\n        if (8 * count > bits.available()) {\n            throw new FormatException();\n        }\n        var readBytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            readBytes[i] = /*(byte) */ bits.readBits(8);\n        }\n        var encoding;\n        if (currentCharacterSetECI === null) {\n            // The spec isn't clear on this mode; see\n            // section 6.4.5: t does not say which encoding to assuming\n            // upon decoding. I have seen ISO-8859-1 used as well as\n            // Shift_JIS -- without anything like an ECI designator to\n            // give a hint.\n            encoding = StringUtils.guessEncoding(readBytes, hints);\n        }\n        else {\n            encoding = currentCharacterSetECI.getName();\n        }\n        try {\n            result.append(StringEncoding.decode(readBytes, encoding));\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException(ignored);\n        }\n        byteSegments.push(readBytes);\n    };\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n            throw new FormatException();\n        }\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n    };\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n        // Read two characters at a time\n        var start = result.length();\n        while (count > 1) {\n            if (bits.available() < 11) {\n                throw new FormatException();\n            }\n            var nextTwoCharsBits = bits.readBits(11);\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n            count -= 2;\n        }\n        if (count === 1) {\n            // special case: one character left\n            if (bits.available() < 6) {\n                throw new FormatException();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n        }\n        // See section 6.4.8.1, 6.4.8.2\n        if (fc1InEffect) {\n            // We need to massage the result a bit if in an FNC1 mode:\n            for (var i = start; i < result.length(); i++) {\n                if (result.charAt(i) === '%') {\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                        // %% is rendered as %\n                        result.deleteCharAt(i + 1);\n                    }\n                    else {\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\n                        result.setCharAt(i, String.fromCharCode(0x1D));\n                    }\n                }\n            }\n        }\n    };\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n        // Read three digits at a time\n        while (count >= 3) {\n            // Each 10 bits encodes three digits\n            if (bits.available() < 10) {\n                throw new FormatException();\n            }\n            var threeDigitsBits = bits.readBits(10);\n            if (threeDigitsBits >= 1000) {\n                throw new FormatException();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n            count -= 3;\n        }\n        if (count === 2) {\n            // Two digits left over to read, encoded in 7 bits\n            if (bits.available() < 7) {\n                throw new FormatException();\n            }\n            var twoDigitsBits = bits.readBits(7);\n            if (twoDigitsBits >= 100) {\n                throw new FormatException();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n        }\n        else if (count === 1) {\n            // One digit left over to read\n            if (bits.available() < 4) {\n                throw new FormatException();\n            }\n            var digitBits = bits.readBits(4);\n            if (digitBits >= 10) {\n                throw new FormatException();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n        }\n    };\n    DecodedBitStreamParser.parseECIValue = function (bits) {\n        var firstByte = bits.readBits(8);\n        if ((firstByte & 0x80) === 0) {\n            // just one byte\n            return firstByte & 0x7F;\n        }\n        if ((firstByte & 0xC0) === 0x80) {\n            // two bytes\n            var secondByte = bits.readBits(8);\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n        }\n        if ((firstByte & 0xE0) === 0xC0) {\n            // three bytes\n            var secondThirdBytes = bits.readBits(16);\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n        }\n        throw new FormatException();\n    };\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\n    return DecodedBitStreamParser;\n}());\nexport default DecodedBitStreamParser;\n// function Uint8ArrayToString(a: Uint8Array): string {\n//     const CHUNK_SZ = 0x8000;\n//     const c = new StringBuilder();\n//     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n//         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n//     }\n//     return c.toString();\n// }\n//# sourceMappingURL=DecodedBitStreamParser.js.map"]},"metadata":{},"sourceType":"module"}