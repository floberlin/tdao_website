{"ast":null,"code":"const MAX_PROCESS_COUNT = 10;\n\nclass RenderQueue {\n  constructor() {\n    this.list = []; // Used to store the web components in order\n\n    this.lookup = new Set(); // Used for faster search\n  }\n\n  add(webComponent) {\n    if (this.lookup.has(webComponent)) {\n      return;\n    }\n\n    this.list.push(webComponent);\n    this.lookup.add(webComponent);\n  }\n\n  remove(webComponent) {\n    if (!this.lookup.has(webComponent)) {\n      return;\n    }\n\n    this.list = this.list.filter(item => item !== webComponent);\n    this.lookup.delete(webComponent);\n  }\n\n  shift() {\n    const webComponent = this.list.shift();\n\n    if (webComponent) {\n      this.lookup.delete(webComponent);\n      return webComponent;\n    }\n  }\n\n  isEmpty() {\n    return this.list.length === 0;\n  }\n\n  isAdded(webComponent) {\n    return this.lookup.has(webComponent);\n  }\n  /**\n   * Processes the whole queue by executing the callback on each component,\n   * while also imposing restrictions on how many times a component may be processed.\n   *\n   * @param callback - function with one argument (the web component to be processed)\n   */\n\n\n  process(callback) {\n    let webComponent;\n    const stats = new Map();\n    webComponent = this.shift();\n\n    while (webComponent) {\n      const timesProcessed = stats.get(webComponent) || 0;\n\n      if (timesProcessed > MAX_PROCESS_COUNT) {\n        throw new Error(`Web component processed too many times this task, max allowed is: ${MAX_PROCESS_COUNT}`);\n      }\n\n      callback(webComponent);\n      stats.set(webComponent, timesProcessed + 1);\n      webComponent = this.shift();\n    }\n  }\n\n}\n\nexport default RenderQueue;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/RenderQueue.js"],"names":["MAX_PROCESS_COUNT","RenderQueue","constructor","list","lookup","Set","add","webComponent","has","push","remove","filter","item","delete","shift","isEmpty","length","isAdded","process","callback","stats","Map","timesProcessed","get","Error","set"],"mappings":"AAAA,MAAMA,iBAAiB,GAAG,EAA1B;;AAEA,MAAMC,WAAN,CAAkB;AACjBC,EAAAA,WAAW,GAAG;AACb,SAAKC,IAAL,GAAY,EAAZ,CADa,CACG;;AAChB,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd,CAFa,CAEY;AACzB;;AAEDC,EAAAA,GAAG,CAACC,YAAD,EAAe;AACjB,QAAI,KAAKH,MAAL,CAAYI,GAAZ,CAAgBD,YAAhB,CAAJ,EAAmC;AAClC;AACA;;AAED,SAAKJ,IAAL,CAAUM,IAAV,CAAeF,YAAf;AACA,SAAKH,MAAL,CAAYE,GAAZ,CAAgBC,YAAhB;AACA;;AAEDG,EAAAA,MAAM,CAACH,YAAD,EAAe;AACpB,QAAI,CAAC,KAAKH,MAAL,CAAYI,GAAZ,CAAgBD,YAAhB,CAAL,EAAoC;AACnC;AACA;;AAED,SAAKJ,IAAL,GAAY,KAAKA,IAAL,CAAUQ,MAAV,CAAiBC,IAAI,IAAIA,IAAI,KAAKL,YAAlC,CAAZ;AACA,SAAKH,MAAL,CAAYS,MAAZ,CAAmBN,YAAnB;AACA;;AAEDO,EAAAA,KAAK,GAAG;AACP,UAAMP,YAAY,GAAG,KAAKJ,IAAL,CAAUW,KAAV,EAArB;;AACA,QAAIP,YAAJ,EAAkB;AACjB,WAAKH,MAAL,CAAYS,MAAZ,CAAmBN,YAAnB;AACA,aAAOA,YAAP;AACA;AACD;;AAEDQ,EAAAA,OAAO,GAAG;AACT,WAAO,KAAKZ,IAAL,CAAUa,MAAV,KAAqB,CAA5B;AACA;;AAEDC,EAAAA,OAAO,CAACV,YAAD,EAAe;AACrB,WAAO,KAAKH,MAAL,CAAYI,GAAZ,CAAgBD,YAAhB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCW,EAAAA,OAAO,CAACC,QAAD,EAAW;AACjB,QAAIZ,YAAJ;AACA,UAAMa,KAAK,GAAG,IAAIC,GAAJ,EAAd;AAEAd,IAAAA,YAAY,GAAG,KAAKO,KAAL,EAAf;;AACA,WAAOP,YAAP,EAAqB;AACpB,YAAMe,cAAc,GAAGF,KAAK,CAACG,GAAN,CAAUhB,YAAV,KAA2B,CAAlD;;AACA,UAAIe,cAAc,GAAGtB,iBAArB,EAAwC;AACvC,cAAM,IAAIwB,KAAJ,CAAW,qEAAoExB,iBAAkB,EAAjG,CAAN;AACA;;AACDmB,MAAAA,QAAQ,CAACZ,YAAD,CAAR;AACAa,MAAAA,KAAK,CAACK,GAAN,CAAUlB,YAAV,EAAwBe,cAAc,GAAG,CAAzC;AACAf,MAAAA,YAAY,GAAG,KAAKO,KAAL,EAAf;AACA;AACD;;AA5DgB;;AA+DlB,eAAeb,WAAf","sourcesContent":["const MAX_PROCESS_COUNT = 10;\n\nclass RenderQueue {\n\tconstructor() {\n\t\tthis.list = []; // Used to store the web components in order\n\t\tthis.lookup = new Set(); // Used for faster search\n\t}\n\n\tadd(webComponent) {\n\t\tif (this.lookup.has(webComponent)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.list.push(webComponent);\n\t\tthis.lookup.add(webComponent);\n\t}\n\n\tremove(webComponent) {\n\t\tif (!this.lookup.has(webComponent)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.list = this.list.filter(item => item !== webComponent);\n\t\tthis.lookup.delete(webComponent);\n\t}\n\n\tshift() {\n\t\tconst webComponent = this.list.shift();\n\t\tif (webComponent) {\n\t\t\tthis.lookup.delete(webComponent);\n\t\t\treturn webComponent;\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.list.length === 0;\n\t}\n\n\tisAdded(webComponent) {\n\t\treturn this.lookup.has(webComponent);\n\t}\n\n\t/**\n\t * Processes the whole queue by executing the callback on each component,\n\t * while also imposing restrictions on how many times a component may be processed.\n\t *\n\t * @param callback - function with one argument (the web component to be processed)\n\t */\n\tprocess(callback) {\n\t\tlet webComponent;\n\t\tconst stats = new Map();\n\n\t\twebComponent = this.shift();\n\t\twhile (webComponent) {\n\t\t\tconst timesProcessed = stats.get(webComponent) || 0;\n\t\t\tif (timesProcessed > MAX_PROCESS_COUNT) {\n\t\t\t\tthrow new Error(`Web component processed too many times this task, max allowed is: ${MAX_PROCESS_COUNT}`);\n\t\t\t}\n\t\t\tcallback(webComponent);\n\t\t\tstats.set(webComponent, timesProcessed + 1);\n\t\t\twebComponent = this.shift();\n\t\t}\n\t}\n}\n\nexport default RenderQueue;\n"]},"metadata":{},"sourceType":"module"}