{"ast":null,"code":"// The Latch Table shows, for each pair of Modes, the optimal method for\n// getting from one mode to another.  In the worst possible case, this can\n// be up to 14 bits.  In the best possible case, we are already there!\n// The high half-word of each entry gives the number of bits.\n// The low half-word of each entry are the actual bits necessary to change\nexport var LATCH_TABLE = [Int32Array.from([0, (5 << 16) + 28, (5 << 16) + 30, (5 << 16) + 29, (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n]), Int32Array.from([(9 << 16) + (30 << 4) + 14, 0, (5 << 16) + 30, (5 << 16) + 29, (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n]), Int32Array.from([(4 << 16) + 14, (9 << 16) + (14 << 5) + 28, 0, (9 << 16) + (14 << 5) + 29, (14 << 16) + (14 << 10) + (29 << 5) + 30 // DIGIT -> UPPER -> MIXED -> PUNCT\n]), Int32Array.from([(5 << 16) + 29, (5 << 16) + 28, (10 << 16) + (29 << 5) + 30, 0, (5 << 16) + 30 // MIXED -> PUNCT\n]), Int32Array.from([(5 << 16) + 31, (10 << 16) + (31 << 5) + 28, (10 << 16) + (31 << 5) + 30, (10 << 16) + (31 << 5) + 29, 0])];","map":{"version":3,"sources":["../../../../../src/core/aztec/encoder/LatchTable.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAM,WAAW,GAAiB,CACvC,UAAU,CAAC,IAAX,CAAgB,CACd,CADc,EAEd,CAAC,KAAK,EAAN,IAAY,EAFE,EAGd,CAAC,KAAK,EAAN,IAAY,EAHE,EAId,CAAC,KAAK,EAAN,IAAY,EAJE,EAKd,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EALX,CAKc;AALd,CAAhB,CADuC,EAQvC,UAAU,CAAC,IAAX,CAAgB,CACd,CAAC,KAAK,EAAN,KAAa,MAAM,CAAnB,IAAwB,EADV,EAEd,CAFc,EAGd,CAAC,KAAK,EAAN,IAAY,EAHE,EAId,CAAC,KAAK,EAAN,IAAY,EAJE,EAKd,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EALX,CAKc;AALd,CAAhB,CARuC,EAevC,UAAU,CAAC,IAAX,CAAgB,CACd,CAAC,KAAK,EAAN,IAAY,EADE,EAEd,CAAC,KAAK,EAAN,KAAa,MAAM,CAAnB,IAAwB,EAFV,EAGd,CAHc,EAId,CAAC,KAAK,EAAN,KAAa,MAAM,CAAnB,IAAwB,EAJV,EAKd,CAAC,MAAM,EAAP,KAAc,MAAM,EAApB,KAA2B,MAAM,CAAjC,IAAsC,EALxB,CAMd;AANc,CAAhB,CAfuC,EAuBvC,UAAU,CAAC,IAAX,CAAgB,CACd,CAAC,KAAK,EAAN,IAAY,EADE,EAEd,CAAC,KAAK,EAAN,IAAY,EAFE,EAGd,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EAHX,EAId,CAJc,EAKd,CAAC,KAAK,EAAN,IAAY,EALE,CAKC;AALD,CAAhB,CAvBuC,EA8BvC,UAAU,CAAC,IAAX,CAAgB,CACd,CAAC,KAAK,EAAN,IAAY,EADE,EAEd,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EAFX,EAGd,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EAHX,EAId,CAAC,MAAM,EAAP,KAAc,MAAM,CAApB,IAAyB,EAJX,EAKd,CALc,CAAhB,CA9BuC,CAAlC","sourceRoot":"","sourcesContent":["// The Latch Table shows, for each pair of Modes, the optimal method for\n// getting from one mode to another.  In the worst possible case, this can\n// be up to 14 bits.  In the best possible case, we are already there!\n// The high half-word of each entry gives the number of bits.\n// The low half-word of each entry are the actual bits necessary to change\nexport var LATCH_TABLE = [\n    Int32Array.from([\n        0,\n        (5 << 16) + 28,\n        (5 << 16) + 30,\n        (5 << 16) + 29,\n        (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (9 << 16) + (30 << 4) + 14,\n        0,\n        (5 << 16) + 30,\n        (5 << 16) + 29,\n        (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (4 << 16) + 14,\n        (9 << 16) + (14 << 5) + 28,\n        0,\n        (9 << 16) + (14 << 5) + 29,\n        (14 << 16) + (14 << 10) + (29 << 5) + 30\n        // DIGIT -> UPPER -> MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (5 << 16) + 29,\n        (5 << 16) + 28,\n        (10 << 16) + (29 << 5) + 30,\n        0,\n        (5 << 16) + 30 // MIXED -> PUNCT\n    ]),\n    Int32Array.from([\n        (5 << 16) + 31,\n        (10 << 16) + (31 << 5) + 28,\n        (10 << 16) + (31 << 5) + 30,\n        (10 << 16) + (31 << 5) + 29,\n        0\n    ])\n];\n//# sourceMappingURL=LatchTable.js.map"]},"metadata":{},"sourceType":"module"}