{"ast":null,"code":"import EventProvider from \"./EventProvider.js\";\nimport RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\nimport { isRtlAware } from \"./locale/RTLAwareRegistry.js\";\nconst registeredElements = new Set();\nconst eventProvider = new EventProvider();\nconst invalidatedWebComponents = new RenderQueue(); // Queue for invalidated web components\n\nlet renderTaskPromise, renderTaskPromiseResolve;\nlet mutationObserverTimer;\nlet queuePromise;\n/**\n * Schedules a render task (if not already scheduled) to render the component\n *\n * @param webComponent\n * @returns {Promise}\n */\n\nconst renderDeferred = async webComponent => {\n  // Enqueue the web component\n  invalidatedWebComponents.add(webComponent); // Schedule a rendering task\n\n  await scheduleRenderTask();\n};\n/**\n * Renders a component synchronously and adds it to the registry of rendered components\n *\n * @param webComponent\n */\n\n\nconst renderImmediately = webComponent => {\n  eventProvider.fireEvent(\"beforeComponentRender\", webComponent);\n  registeredElements.add(webComponent);\n\n  webComponent._render();\n};\n/**\n * Cancels the rendering of a component, if awaiting to be rendered, and removes it from the registry of rendered components\n *\n * @param webComponent\n */\n\n\nconst cancelRender = webComponent => {\n  invalidatedWebComponents.remove(webComponent);\n  registeredElements.delete(webComponent);\n};\n/**\n * Schedules a rendering task, if not scheduled already\n */\n\n\nconst scheduleRenderTask = async () => {\n  if (!queuePromise) {\n    queuePromise = new Promise(resolve => {\n      window.requestAnimationFrame(() => {\n        // Render all components in the queue\n        // console.log(`--------------------RENDER TASK START------------------------------`); // eslint-disable-line\n        invalidatedWebComponents.process(renderImmediately); // console.log(`--------------------RENDER TASK END------------------------------`); // eslint-disable-line\n        // Resolve the promise so that callers of renderDeferred can continue\n\n        queuePromise = null;\n        resolve(); // Wait for Mutation observer before the render task is considered finished\n\n        if (!mutationObserverTimer) {\n          mutationObserverTimer = setTimeout(() => {\n            mutationObserverTimer = undefined;\n\n            if (invalidatedWebComponents.isEmpty()) {\n              _resolveTaskPromise();\n            }\n          }, 200);\n        }\n      });\n    });\n  }\n\n  await queuePromise;\n};\n/**\n * return a promise that will be resolved once all invalidated web components are rendered\n */\n\n\nconst whenDOMUpdated = () => {\n  if (renderTaskPromise) {\n    return renderTaskPromise;\n  }\n\n  renderTaskPromise = new Promise(resolve => {\n    renderTaskPromiseResolve = resolve;\n    window.requestAnimationFrame(() => {\n      if (invalidatedWebComponents.isEmpty()) {\n        renderTaskPromise = undefined;\n        resolve();\n      }\n    });\n  });\n  return renderTaskPromise;\n};\n\nconst whenAllCustomElementsAreDefined = () => {\n  const definedPromises = getAllRegisteredTags().map(tag => customElements.whenDefined(tag));\n  return Promise.all(definedPromises);\n};\n\nconst renderFinished = async () => {\n  await whenAllCustomElementsAreDefined();\n  await whenDOMUpdated();\n};\n\nconst _resolveTaskPromise = () => {\n  if (!invalidatedWebComponents.isEmpty()) {\n    // More updates are pending. Resolve will be called again\n    return;\n  }\n\n  if (renderTaskPromiseResolve) {\n    renderTaskPromiseResolve();\n    renderTaskPromiseResolve = undefined;\n    renderTaskPromise = undefined;\n  }\n};\n/**\n * Re-renders all UI5 Elements on the page, with the option to specify filters to rerender only some components.\n *\n * Usage:\n * reRenderAllUI5Elements() -> re-renders all components\n * reRenderAllUI5Elements({tag: \"ui5-button\"}) -> re-renders only instances of ui5-button\n * reRenderAllUI5Elements({rtlAware: true}) -> re-renders only rtlAware components\n * reRenderAllUI5Elements({languageAware: true}) -> re-renders only languageAware components\n * reRenderAllUI5Elements({rtlAware: true, languageAware: true}) -> re-renders components that are rtlAware or languageAware\n * etc...\n *\n * @public\n * @param {Object|undefined} filters - Object with keys that can be \"rtlAware\" or \"languageAware\"\n * @returns {Promise<void>}\n */\n\n\nconst reRenderAllUI5Elements = async filters => {\n  registeredElements.forEach(element => {\n    const tag = element.constructor.getMetadata().getTag();\n    const rtlAware = isRtlAware(element.constructor);\n    const languageAware = element.constructor.getMetadata().isLanguageAware();\n\n    if (!filters || filters.tag === tag || filters.rtlAware && rtlAware || filters.languageAware && languageAware) {\n      renderDeferred(element);\n    }\n  });\n  await renderFinished();\n};\n\nconst attachBeforeComponentRender = listener => {\n  eventProvider.attachEvent(\"beforeComponentRender\", listener);\n};\n\nconst detachBeforeComponentRender = listener => {\n  eventProvider.detachEvent(\"beforeComponentRender\", listener);\n};\n\nexport { renderDeferred, renderImmediately, cancelRender, renderFinished, reRenderAllUI5Elements, attachBeforeComponentRender, detachBeforeComponentRender };","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/Render.js"],"names":["EventProvider","RenderQueue","getAllRegisteredTags","isRtlAware","registeredElements","Set","eventProvider","invalidatedWebComponents","renderTaskPromise","renderTaskPromiseResolve","mutationObserverTimer","queuePromise","renderDeferred","webComponent","add","scheduleRenderTask","renderImmediately","fireEvent","_render","cancelRender","remove","delete","Promise","resolve","window","requestAnimationFrame","process","setTimeout","undefined","isEmpty","_resolveTaskPromise","whenDOMUpdated","whenAllCustomElementsAreDefined","definedPromises","map","tag","customElements","whenDefined","all","renderFinished","reRenderAllUI5Elements","filters","forEach","element","constructor","getMetadata","getTag","rtlAware","languageAware","isLanguageAware","attachBeforeComponentRender","listener","attachEvent","detachBeforeComponentRender","detachEvent"],"mappings":"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","sourcesContent":["import EventProvider from \"./EventProvider.js\";\nimport RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\nimport { isRtlAware } from \"./locale/RTLAwareRegistry.js\";\n\nconst registeredElements = new Set();\nconst eventProvider = new EventProvider();\n\nconst invalidatedWebComponents = new RenderQueue(); // Queue for invalidated web components\n\nlet renderTaskPromise,\n\trenderTaskPromiseResolve;\n\nlet mutationObserverTimer;\n\nlet queuePromise;\n\n/**\n * Schedules a render task (if not already scheduled) to render the component\n *\n * @param webComponent\n * @returns {Promise}\n */\nconst renderDeferred = async webComponent => {\n\t// Enqueue the web component\n\tinvalidatedWebComponents.add(webComponent);\n\n\t// Schedule a rendering task\n\tawait scheduleRenderTask();\n};\n\n/**\n * Renders a component synchronously and adds it to the registry of rendered components\n *\n * @param webComponent\n */\nconst renderImmediately = webComponent => {\n\teventProvider.fireEvent(\"beforeComponentRender\", webComponent);\n\tregisteredElements.add(webComponent);\n\twebComponent._render();\n};\n\n/**\n * Cancels the rendering of a component, if awaiting to be rendered, and removes it from the registry of rendered components\n *\n * @param webComponent\n */\nconst cancelRender = webComponent => {\n\tinvalidatedWebComponents.remove(webComponent);\n\tregisteredElements.delete(webComponent);\n};\n\n/**\n * Schedules a rendering task, if not scheduled already\n */\nconst scheduleRenderTask = async () => {\n\tif (!queuePromise) {\n\t\tqueuePromise = new Promise(resolve => {\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\t// Render all components in the queue\n\n\t\t\t\t// console.log(`--------------------RENDER TASK START------------------------------`); // eslint-disable-line\n\t\t\t\tinvalidatedWebComponents.process(renderImmediately);\n\t\t\t\t// console.log(`--------------------RENDER TASK END------------------------------`); // eslint-disable-line\n\n\t\t\t\t// Resolve the promise so that callers of renderDeferred can continue\n\t\t\t\tqueuePromise = null;\n\t\t\t\tresolve();\n\n\t\t\t\t// Wait for Mutation observer before the render task is considered finished\n\t\t\t\tif (!mutationObserverTimer) {\n\t\t\t\t\tmutationObserverTimer = setTimeout(() => {\n\t\t\t\t\t\tmutationObserverTimer = undefined;\n\t\t\t\t\t\tif (invalidatedWebComponents.isEmpty()) {\n\t\t\t\t\t\t\t_resolveTaskPromise();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 200);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tawait queuePromise;\n};\n\n/**\n * return a promise that will be resolved once all invalidated web components are rendered\n */\nconst whenDOMUpdated = () => {\n\tif (renderTaskPromise) {\n\t\treturn renderTaskPromise;\n\t}\n\n\trenderTaskPromise = new Promise(resolve => {\n\t\trenderTaskPromiseResolve = resolve;\n\t\twindow.requestAnimationFrame(() => {\n\t\t\tif (invalidatedWebComponents.isEmpty()) {\n\t\t\t\trenderTaskPromise = undefined;\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n\n\treturn renderTaskPromise;\n};\n\nconst whenAllCustomElementsAreDefined = () => {\n\tconst definedPromises = getAllRegisteredTags().map(tag => customElements.whenDefined(tag));\n\treturn Promise.all(definedPromises);\n};\n\nconst renderFinished = async () => {\n\tawait whenAllCustomElementsAreDefined();\n\tawait whenDOMUpdated();\n};\n\nconst _resolveTaskPromise = () => {\n\tif (!invalidatedWebComponents.isEmpty()) {\n\t\t// More updates are pending. Resolve will be called again\n\t\treturn;\n\t}\n\n\tif (renderTaskPromiseResolve) {\n\t\trenderTaskPromiseResolve();\n\t\trenderTaskPromiseResolve = undefined;\n\t\trenderTaskPromise = undefined;\n\t}\n};\n\n/**\n * Re-renders all UI5 Elements on the page, with the option to specify filters to rerender only some components.\n *\n * Usage:\n * reRenderAllUI5Elements() -> re-renders all components\n * reRenderAllUI5Elements({tag: \"ui5-button\"}) -> re-renders only instances of ui5-button\n * reRenderAllUI5Elements({rtlAware: true}) -> re-renders only rtlAware components\n * reRenderAllUI5Elements({languageAware: true}) -> re-renders only languageAware components\n * reRenderAllUI5Elements({rtlAware: true, languageAware: true}) -> re-renders components that are rtlAware or languageAware\n * etc...\n *\n * @public\n * @param {Object|undefined} filters - Object with keys that can be \"rtlAware\" or \"languageAware\"\n * @returns {Promise<void>}\n */\nconst reRenderAllUI5Elements = async filters => {\n\tregisteredElements.forEach(element => {\n\t\tconst tag = element.constructor.getMetadata().getTag();\n\t\tconst rtlAware = isRtlAware(element.constructor);\n\t\tconst languageAware = element.constructor.getMetadata().isLanguageAware();\n\t\tif (!filters || (filters.tag === tag) || (filters.rtlAware && rtlAware) || (filters.languageAware && languageAware)) {\n\t\t\trenderDeferred(element);\n\t\t}\n\t});\n\tawait renderFinished();\n};\n\nconst attachBeforeComponentRender = listener => {\n\teventProvider.attachEvent(\"beforeComponentRender\", listener);\n};\n\nconst detachBeforeComponentRender = listener => {\n\teventProvider.detachEvent(\"beforeComponentRender\", listener);\n};\n\nexport {\n\trenderDeferred,\n\trenderImmediately,\n\tcancelRender,\n\trenderFinished,\n\treRenderAllUI5Elements,\n\tattachBeforeComponentRender,\n\tdetachBeforeComponentRender,\n};\n"]},"metadata":{},"sourceType":"module"}