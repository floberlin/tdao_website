{"ast":null,"code":"import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape, isHome, isEnd } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\"; // Texts\n\nimport { RANGE_SLIDER_ARIA_DESCRIPTION, RANGE_SLIDER_START_HANDLE_DESCRIPTION, RANGE_SLIDER_END_HANDLE_DESCRIPTION } from \"./generated/i18n/i18n-defaults.js\";\n/**\n * @public\n */\n\nconst metadata = {\n  tag: \"ui5-range-slider\",\n  languageAware: true,\n  managedSlots: true,\n  properties:\n  /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */\n  {\n    /**\n     * Defines start point of a selection - position of a first handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    startValue: {\n      type: Float,\n      defaultValue: 0\n    },\n\n    /**\n     * Defines end point of a selection - position of a second handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    endValue: {\n      type: Float,\n      defaultValue: 100\n    }\n  }\n};\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\n\nclass RangeSlider extends SliderBase {\n  static get metadata() {\n    return metadata;\n  }\n\n  static get template() {\n    return RangeSliderTemplate;\n  }\n\n  static get VALUES() {\n    return {\n      start: \"startValue\",\n      end: \"endValue\"\n    };\n  }\n\n  constructor() {\n    super();\n    this._stateStorage.startValue = null;\n    this._stateStorage.endValue = null;\n  }\n\n  get tooltipStartValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\n    return this.startValue.toFixed(stepPrecision);\n  }\n\n  get tooltipEndValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\n    return this.endValue.toFixed(stepPrecision);\n  }\n\n  get _ariaDisabled() {\n    return this.disabled || undefined;\n  }\n\n  get _ariaLabelledByText() {\n    return RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n  }\n\n  get _ariaHandlesText() {\n    const isRTL = this.effectiveDir === \"rtl\";\n\n    const isReversed = this._areValuesReversed();\n\n    const ariaHandlesText = {};\n\n    if (isRTL && !isReversed || !isRTL && isReversed) {\n      ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n    } else {\n      ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n    }\n\n    return ariaHandlesText;\n  }\n  /**\n   * Check if the previously saved state is outdated. That would mean\n   * either it is the initial rendering or that a property has been changed\n   * programatically - because the previous state is always updated in\n   * the interaction handlers.\n   *\n   * Normalize current properties, update the previously stored state.\n   * Update the visual UI representation of the Slider.\n   *\n   */\n\n\n  onBeforeRendering() {\n    if (!this.isCurrentStateOutdated()) {\n      return;\n    }\n\n    this.notResized = true;\n    this.syncUIAndState(\"startValue\", \"endValue\");\n\n    this._updateHandlesAndRange(null);\n  }\n\n  _onfocusin(event) {\n    // If this is the initial focusin of the component save its initial\n    // value properties so they could be restored on ESC key press\n    if (!this._getInitialValue(\"endValue\")) {\n      this._setInitialValue(\"startValue\", this.startValue);\n\n      this._setInitialValue(\"endValue\", this.endValue);\n    }\n\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n  /**\n   * Handles focus out event of the focusable components inner elements.\n   * Prevent focusout when the focus is getting initially set within the slider before the\n   * slider customElement itself is finished focusing.\n   *\n   * Prevents the focus from leaving the Range Slider when the focus is managed between\n   * its inner elements in result of user interactions.\n   *\n   * Resets the stored Range Slider's initial values saved when it was first focused\n   *\n   * @private\n   */\n\n\n  _onfocusout(event) {\n    if (this._isFocusing()) {\n      this._preventFocusOut();\n\n      return;\n    }\n\n    this._setAffectedValue(null);\n\n    this._setInitialValue(\"startValue\", null);\n\n    this._setInitialValue(\"endValue\", null);\n\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n  /**\n  * Handles keyup logic. If one of the handles came across the other\n  * swap the start and end values. Reset the affected value by the finished\n  * user interaction.\n  *\n  * @private\n  */\n\n\n  _onkeyup(event) {\n    super._onkeyup(event);\n\n    this._swapValues();\n\n    this._setAffectedValue(null);\n  }\n\n  _handleActionKeyPress(event) {\n    if (isEscape(event)) {\n      this.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n      return;\n    } // Set the target of the interaction based on the focused inner element\n\n\n    this._setAffectedValueByFocusedElement();\n\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const affectedValue = this._valueAffected; // If home/end key is pressed and no single handle is focused the active element\n    // is the range selection - update both start and end values. Otherwise, if 'home'\n    // is pressed the 'startValue'will be used for the start-handle offset calculation,\n    // if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\n    if ((isEnd(event) || isHome(event)) && !affectedValue) {\n      this._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n\n      return;\n    } // Calculate how much the value should be increased/decreased based on the action key\n\n\n    const newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n    if (!newValueOffset) {\n      return;\n    } // Update a single value if one of the handles is focused or the range if not already at min or max\n\n\n    if (affectedValue && !this._isPressInCurrentRange) {\n      const newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n      this.update(affectedValue, newValue, null);\n    } else if (newValueOffset < 0 && this.startValue > min || newValueOffset > 0 && this.endValue < max) {\n      const newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n      const newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n      this.update(affectedValue, newStartValue, newEndValue);\n    }\n  }\n  /**\n   * Determines affected value (start/end) depending on the currently\n   * active inner element within the Range Slider - used in the keyboard handling.\n   *\n   * @private\n   */\n\n\n  _setAffectedValueByFocusedElement() {\n    if (this.shadowRoot.activeElement === this._startHandle) {\n      this._setAffectedValue(RangeSlider.VALUES.start);\n    }\n\n    if (this.shadowRoot.activeElement === this._endHandle) {\n      this._setAffectedValue(RangeSlider.VALUES.end);\n    }\n\n    if (this.shadowRoot.activeElement === this._progressBar) {\n      this._setAffectedValue(null);\n    }\n\n    this._setIsPressInCurrentRange(!this._valueAffected);\n  }\n  /**\n   * Calculates the start and end values when the 'Home\" or 'End' keys\n   * are pressed on the selected range bar.\n   *\n   * @private\n   */\n\n\n  _homeEndForSelectedRange(event, affectedValue, min, max) {\n    const newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n    const newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n    const newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n    this.update(null, newStartValue, newEndValue);\n  }\n  /**\n   * Update values, stored inner state and the visual UI representation of the component.\n   * If no specific type of value property is passed - the range is selected - update both handles,\n   * otherwise update the handle corresponding to the affected by the user interacton value prop.\n   *\n   * @private\n   */\n\n\n  update(affectedValue, startValue, endValue) {\n    if (!affectedValue) {\n      this.updateValue(\"startValue\", startValue);\n      this.updateValue(\"endValue\", endValue);\n\n      this._updateHandlesAndRange(null);\n    } else {\n      const newValue = startValue;\n\n      this._updateHandlesAndRange(newValue);\n\n      this.updateValue(affectedValue, newValue);\n    }\n  }\n  /**\n   * Called when the user starts interacting with the slider\n   *\n   * @private\n   */\n\n\n  _onmousedown(event) {\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    } // Calculate the new value from the press position of the event\n\n\n    const newValue = this.handleDownBase(event); // Determine the rest of the needed details from the start of the interaction.\n\n    this._saveInteractionStartData(event, newValue); // Do not yet update the RangeSlider if press is in range or over a handle.\n\n\n    if (this._isPressInCurrentRange || this._handeIsPressed) {\n      this._handeIsPressed = false;\n      return;\n    } // Update Slider UI and internal state\n\n\n    this.update(this._valueAffected, newValue, null);\n  }\n  /**\n   * Determines and saves needed values from the start of the interaction:\n   *\n   * Is the value calculated is within the currently selected range;\n   * Initial pageX position of the start handle affected by the interaction;\n   * Initial pageX value of the pressed postion;\n   * Affected value property by the action;\n   *\n   * @private\n   */\n\n\n  _saveInteractionStartData(event, newValue) {\n    const progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect(); // Save the state of the value properties on the start of the interaction\n\n    this._startValueAtBeginningOfAction = this.startValue;\n    this._endValueAtBeginningOfAction = this.endValue; // Save the initial press point coordinates (position)\n\n    this._initialPageXPosition = this.constructor.getPageXValueFromEvent(event); // Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\n    this._pressTargetAndAffectedValue(this._initialPageXPosition, newValue); // Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\n\n    this._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n  }\n  /**\n   * Called when the user moves the slider\n   *\n   * @private\n   */\n\n\n  _handleMove(event) {\n    event.preventDefault(); // If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    } // Update UI and state when dragging a single Range Slider handle\n\n\n    if (!this._isPressInCurrentRange) {\n      this._updateValueOnHandleDrag(event);\n\n      return;\n    } // Updates UI and state when dragging of the whole selected range\n\n\n    this._updateValueOnRangeDrag(event);\n  }\n  /**\n   * Updates UI and state when dragging a single Range Slider handle\n   *\n   * @private\n   */\n\n\n  _updateValueOnHandleDrag(event) {\n    const newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n    this.update(this._valueAffected, newValue, null);\n  }\n  /**\n   * Updates UI and state when dragging of the whole selected range\n   *\n   * @private\n   */\n\n\n  _updateValueOnRangeDrag(event) {\n    // Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n    const currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\n    const newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX); // No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\n\n    this._setAffectedValue(null); // Update the UI and the state acccording to the calculated new values\n\n\n    this.update(null, newValues[0], newValues[1]);\n  }\n\n  _handleUp() {\n    if (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n      this.fireEvent(\"change\");\n    }\n\n    this._swapValues();\n\n    this._setAffectedValueByFocusedElement();\n\n    this._setAffectedValue(null);\n\n    this._startValueAtBeginningOfAction = null;\n    this._endValueAtBeginningOfAction = null;\n\n    this._setIsPressInCurrentRange(false);\n\n    this.handleUpBase();\n  }\n  /**\n   * Determines where the press occured and which values of the Range Slider\n   * handles should be updated on further interaction.\n   *\n   * If the press is not in the selected range or over one of the Range Slider handles\n   * determines which one from the value/endValue properties has to be updated\n   * after the user action (based on closest handle).\n   *\n   * Set flags if the press is over a handle or in the selected range,\n   * in such cases no values are changed on interaction start, but could be\n   * updated later when dragging.\n   *\n   * @private\n   */\n\n\n  _pressTargetAndAffectedValue(clientX, value) {\n    const startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n    const endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\"); // Check if the press point is in the bounds of any of the Range Slider handles\n\n    const handleStartDomRect = startHandle.getBoundingClientRect();\n    const handleEndDomRect = endHandle.getBoundingClientRect();\n    const inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n    const inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right; // Remove the flag for value in current range if the press action is over one of the handles\n\n    if (inHandleEndDom || inHandleStartDom) {\n      this._handeIsPressed = true;\n    } // Return that handle that is closer to the press point\n\n\n    if (inHandleEndDom || value > this.endValue) {\n      this._setAffectedValue(RangeSlider.VALUES.end);\n    } // If one of the handle is pressed return that one\n\n\n    if (inHandleStartDom || value < this.startValue) {\n      this._setAffectedValue(RangeSlider.VALUES.start);\n    } // Flag if press is in the current select range\n\n\n    const isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\n    this._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n  }\n  /**\n   * Sets the value property (start/end) that will get updated\n   * by a user action depending on that user action's characteristics\n   * - mouse press position - cursor coordinates relative to the start/end handles\n   * - selected inner element via a keyboard navigation\n   *\n   * @param {String} valuePropAffectedByInteraction The value that will get modified by the interaction\n   * @private\n   */\n\n\n  _setAffectedValue(valuePropAffectedByInteraction) {\n    this._valueAffected = valuePropAffectedByInteraction; // If the values have been swapped reset the reversed flag\n\n    if (this._areValuesReversed()) {\n      this._setValuesAreReversed();\n    }\n  }\n  /**\n   * Flag if press action is made on the currently selected range of values\n   *\n   * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n   * @private\n   */\n\n\n  _setIsPressInCurrentRange(isPressInCurrentRange) {\n    this._isPressInCurrentRange = isPressInCurrentRange;\n  }\n  /**\n   * Manage the focus between the focusable inner elements within the component.\n   *\n   * On initial focusin or if the whole range is affected by the user interaction\n   * set the focus on the progress selection, otherwise on one of the Range Slider\n   * handles based on the determined affected value by the user action.\n   *\n   * If one of the handles came across the other one in result of a user action\n   * switch the focus between them to keep it visually consistent.\n   *\n   * Note:\n   * In some cases this function is going to get called twice on one user action.\n   *\n   * 1. When the focus is initially set to an inner element it is done in the very beginning,\n   * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n   * is still not being received, causining an immediate focusout that we prevent by\n   * calling this function once again.\n   *\n   * 2. When the focused is manually switched from one inner element to another.\n   * The focusout handler is one and the same for all focusable parts within the\n   * Range Slider and when is called it checks if it should keep the focus within\n   * the component and which part of it should get focused if that is the case.\n   *\n   * @protected\n   */\n\n\n  focusInnerElement() {\n    const isReversed = this._areValuesReversed();\n\n    const affectedValue = this._valueAffected;\n\n    if (this._isPressInCurrentRange || !affectedValue) {\n      this._progressBar.focus();\n    }\n\n    if (affectedValue === RangeSlider.VALUES.start && !isReversed || affectedValue === RangeSlider.VALUES.end && isReversed) {\n      this._startHandle.focus();\n    }\n\n    if (affectedValue === RangeSlider.VALUES.end && !isReversed || affectedValue === RangeSlider.VALUES.start && isReversed) {\n      this._endHandle.focus();\n    }\n  }\n  /**\n   * Calculates startValue/endValue properties when the whole range is moved.\n   *\n   * Uses the change of the position of the start handle and adds the initially\n   * selected range to it, to determine the whole range offset.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n\n\n  _calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n    // Return the current values if there is no difference in the\n    // possitions of the initial press and the current pointer\n    if (this._initialPageXPosition === currentPageXPos) {\n      return [this.startValue, this.endValue];\n    }\n\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const selectedRange = this.endValue - this.startValue; // Computes the new value based on the difference of the current cursor location from the start of the interaction\n\n    let startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos); // When the end handle reaches the max possible value prevent the start handle from moving\n    // And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\n\n    startValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n    return [startValue, startValue + selectedRange];\n  }\n  /**\n   * Computes the new value based on the difference of the current cursor location from the\n   * start of the interaction.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n\n\n  _calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const step = this._effectiveStep;\n    const dom = this.getBoundingClientRect();\n    let startValue;\n    let startValuePageX;\n    let positionOffset;\n    /* Depending on the dragging direction:\n    - calculate the new position of the start handle from its old pageX value combined with the movement offset;\n    - calculate the start value based on its new pageX coordinates;\n    - 'stepify' the calculated value based on the specified step property; */\n\n    if (currentPageXPos > this._initialPageXPosition) {\n      // Difference between the new position of the pointer and when the press event initial occured\n      positionOffset = currentPageXPos - this._initialPageXPosition;\n      startValuePageX = initialStartHandlePageXPos + positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    } else {\n      positionOffset = this._initialPageXPosition - currentPageXPos;\n      startValuePageX = initialStartHandlePageXPos - positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    }\n\n    return startValue;\n  }\n  /**\n   * Updates the visual representation of the component by calculating\n   * the styles of the handles and the range selection based on the new state.\n   *\n   * @private\n   */\n\n\n  _updateHandlesAndRange(newValue) {\n    const max = this._effectiveMax;\n    const min = this._effectiveMin;\n    const prevStartValue = this.getStoredPropertyState(\"startValue\");\n    const prevEndValue = this.getStoredPropertyState(\"endValue\");\n    const affectedValue = this._valueAffected; // The value according to which we update the UI can be either the startValue\n    // or the endValue property. It is determined in _getClosestHandle()\n    // depending on to which handle is closer the user interaction.\n\n    if (affectedValue === RangeSlider.VALUES.start) {\n      this._selectedRange = (prevEndValue - newValue) / (max - min);\n      this._firstHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else if (affectedValue === RangeSlider.VALUES.end) {\n      this._selectedRange = (newValue - prevStartValue) / (max - min);\n      this._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else {\n      // When both values are changed - UI sync or moving the whole selected range:\n      this._selectedRange = (this.endValue - this.startValue) / (max - min);\n      this._firstHandlePositionFromStart = (this.startValue - min) / (max - min) * 100;\n      this._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n    }\n  }\n  /**\n   * Swaps the start and end values of the handles if one came accros the other:\n   * - If the start value is greater than the endValue swap them and their handles\n   * - If the endValue become less than the start value swap them and their handles\n   *\n   * Switches the focus to the opposite of the currently focused handle.\n   *\n   * Note: Only the property values are reversed, the DOM elements of the handles\n   * corresponding to them are never switched.\n   *\n   * @private\n   */\n\n\n  _swapValues() {\n    const affectedValue = this._valueAffected;\n\n    if (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n      const prevEndValue = this.endValue;\n      this.endValue = this.startValue;\n      this.startValue = prevEndValue;\n\n      this._setValuesAreReversed();\n\n      this.focusInnerElement();\n    }\n\n    if (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n      const prevStartValue = this.startValue;\n      this.startValue = this.endValue;\n      this.endValue = prevStartValue;\n\n      this._setValuesAreReversed();\n\n      this.focusInnerElement();\n    }\n  }\n  /**\n   * Flag that we have swapped the values of the 'start' and 'end' properties,\n   * to correctly switch the focus within the component from one handle to another\n   * when the swapping is finished. As we only swap property values and not\n   * the handle elements themselves, we must also swap their focus.\n   *\n   * @private\n   */\n\n\n  _setValuesAreReversed() {\n    this._reversedValues = !this._reversedValues;\n  }\n\n  _areValuesReversed() {\n    return this._reversedValues;\n  }\n\n  get _startHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n  }\n\n  get _endHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n  }\n\n  get _progressBar() {\n    return this.shadowRoot.querySelector(\".ui5-slider-progress\");\n  }\n\n  get styles() {\n    return {\n      progress: {\n        \"width\": `${this._selectedRange * 100}%`,\n        \"transform-origin\": `${this.directionStart} top`,\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      startHandle: {\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      endHandle: {\n        [this.directionStart]: `${this._secondHandlePositionFromStart}%`\n      },\n      tickmarks: {\n        \"background\": `${this._tickmarks}`\n      },\n      label: {\n        \"width\": `${this._labelWidth}%`\n      },\n      labelContainer: {\n        \"width\": `100%`,\n        [this.directionStart]: `-${this._labelWidth / 2}%`\n      },\n      tooltip: {\n        \"visibility\": `${this._tooltipVisibility}`\n      }\n    };\n  }\n\n  static async onDefine() {\n    RangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n  }\n\n}\n\nRangeSlider.define();\nexport default RangeSlider;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents/dist/RangeSlider.js"],"names":["Float","getI18nBundle","isEscape","isHome","isEnd","SliderBase","RangeSliderTemplate","RANGE_SLIDER_ARIA_DESCRIPTION","RANGE_SLIDER_START_HANDLE_DESCRIPTION","RANGE_SLIDER_END_HANDLE_DESCRIPTION","metadata","tag","languageAware","managedSlots","properties","startValue","type","defaultValue","endValue","RangeSlider","template","VALUES","start","end","constructor","_stateStorage","tooltipStartValue","stepPrecision","_getDecimalPrecisionOfNumber","_effectiveStep","toFixed","tooltipEndValue","_ariaDisabled","disabled","undefined","_ariaLabelledByText","i18nBundle","getText","_ariaHandlesText","isRTL","effectiveDir","isReversed","_areValuesReversed","ariaHandlesText","startHandleText","endHandleText","onBeforeRendering","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","_onfocusin","event","_getInitialValue","_setInitialValue","showTooltip","_tooltipVisibility","TOOLTIP_VISIBILITY","VISIBLE","_onfocusout","_isFocusing","_preventFocusOut","_setAffectedValue","HIDDEN","_onkeyup","_swapValues","_handleActionKeyPress","update","_setAffectedValueByFocusedElement","min","_effectiveMin","max","_effectiveMax","affectedValue","_valueAffected","_homeEndForSelectedRange","newValueOffset","_handleActionKeyPressBase","_isPressInCurrentRange","newValue","clipValue","newStartValue","newEndValue","shadowRoot","activeElement","_startHandle","_endHandle","_progressBar","_setIsPressInCurrentRange","updateValue","_onmousedown","handleDownBase","_saveInteractionStartData","_handeIsPressed","progressBarDom","querySelector","getBoundingClientRect","_startValueAtBeginningOfAction","_endValueAtBeginningOfAction","_initialPageXPosition","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","_handleMove","preventDefault","_updateValueOnHandleDrag","_updateValueOnRangeDrag","getValueFromInteraction","currentPageXPos","newValues","_calculateRangeOffset","_handleUp","fireEvent","handleUpBase","clientX","value","startHandle","endHandle","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","isNewValueInCurrentRange","valuePropAffectedByInteraction","_setValuesAreReversed","isPressInCurrentRange","focusInnerElement","focus","initialStartHandlePageXPos","selectedRange","_calculateStartValueByOffset","step","dom","startValuePageX","positionOffset","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","_reversedValues","styles","progress","tickmarks","_tickmarks","label","_labelWidth","labelContainer","tooltip","onDefine","define"],"mappings":"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","sourcesContent":["import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport {\n\tisEscape,\n\tisHome,\n\tisEnd,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tRANGE_SLIDER_ARIA_DESCRIPTION,\n\tRANGE_SLIDER_START_HANDLE_DESCRIPTION,\n\tRANGE_SLIDER_END_HANDLE_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tmanagedSlots: true,\n\tproperties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */  {\n\t\t/**\n\t\t * Defines start point of a selection - position of a first handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tstartValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines end point of a selection - position of a second handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tendValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get template() {\n\t\treturn RangeSliderTemplate;\n\t}\n\n\tstatic get VALUES() {\n\t\treturn {\n\t\t\tstart: \"startValue\",\n\t\t\tend: \"endValue\",\n\t\t};\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = null;\n\t\tthis._stateStorage.endValue = null;\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tget _ariaHandlesText() {\n\t\tconst isRTL = this.effectiveDir === \"rtl\";\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst ariaHandlesText = {};\n\n\t\tif ((isRTL && !isReversed) || (!isRTL && isReversed)) {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t} else {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t}\n\n\t\treturn ariaHandlesText;\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState(\"startValue\", \"endValue\");\n\t\tthis._updateHandlesAndRange(null);\n\t}\n\n\t_onfocusin(event) {\n\t\t// If this is the initial focusin of the component save its initial\n\t\t// value properties so they could be restored on ESC key press\n\t\tif (!this._getInitialValue(\"endValue\")) {\n\t\t\tthis._setInitialValue(\"startValue\", this.startValue);\n\t\t\tthis._setInitialValue(\"endValue\", this.endValue);\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Handles focus out event of the focusable components inner elements.\n\t * Prevent focusout when the focus is getting initially set within the slider before the\n\t * slider customElement itself is finished focusing.\n\t *\n\t * Prevents the focus from leaving the Range Slider when the focus is managed between\n\t * its inner elements in result of user interactions.\n\t *\n\t * Resets the stored Range Slider's initial values saved when it was first focused\n\t *\n\t * @private\n\t */\n\t_onfocusout(event) {\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAffectedValue(null);\n\t\tthis._setInitialValue(\"startValue\", null);\n\t\tthis._setInitialValue(\"endValue\", null);\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t* Handles keyup logic. If one of the handles came across the other\n\t* swap the start and end values. Reset the affected value by the finished\n\t* user interaction.\n\t*\n\t* @private\n\t*/\n\t_onkeyup(event) {\n\t\tsuper._onkeyup(event);\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValue(null);\n\t}\n\n\t_handleActionKeyPress(event) {\n\t\tif (isEscape(event)) {\n\t\t\tthis.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the target of the interaction based on the focused inner element\n\t\tthis._setAffectedValueByFocusedElement();\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// If home/end key is pressed and no single handle is focused the active element\n\t\t// is the range selection - update both start and end values. Otherwise, if 'home'\n\t\t// is pressed the 'startValue'will be used for the start-handle offset calculation,\n\t\t// if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\t\tif ((isEnd(event) || isHome(event)) && !affectedValue) {\n\t\t\tthis._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate how much the value should be increased/decreased based on the action key\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n\t\tif (!newValueOffset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update a single value if one of the handles is focused or the range if not already at min or max\n\t\tif (affectedValue && !this._isPressInCurrentRange) {\n\t\t\tconst newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n\t\t\tthis.update(affectedValue, newValue, null);\n\t\t} else if ((newValueOffset < 0 && this.startValue > min) || (newValueOffset > 0 && this.endValue < max)) {\n\t\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\t\t\tthis.update(affectedValue, newStartValue, newEndValue);\n\t\t}\n\t}\n\n\t/**\n\t * Determines affected value (start/end) depending on the currently\n\t * active inner element within the Range Slider - used in the keyboard handling.\n\t *\n\t * @private\n\t */\n\t_setAffectedValueByFocusedElement() {\n\t\tif (this.shadowRoot.activeElement === this._startHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._endHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._progressBar) {\n\t\t\tthis._setAffectedValue(null);\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(!this._valueAffected);\n\t}\n\n\t/**\n\t * Calculates the start and end values when the 'Home\" or 'End' keys\n\t * are pressed on the selected range bar.\n\t *\n\t * @private\n\t */\n\t_homeEndForSelectedRange(event, affectedValue, min, max) {\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\n\t\tthis.update(null, newStartValue, newEndValue);\n\t}\n\n\t/**\n\t * Update values, stored inner state and the visual UI representation of the component.\n\t * If no specific type of value property is passed - the range is selected - update both handles,\n\t * otherwise update the handle corresponding to the affected by the user interacton value prop.\n\t *\n\t * @private\n\t */\n\tupdate(affectedValue, startValue, endValue) {\n\t\tif (!affectedValue) {\n\t\t\tthis.updateValue(\"startValue\", startValue);\n\t\t\tthis.updateValue(\"endValue\", endValue);\n\t\t\tthis._updateHandlesAndRange(null);\n\t\t} else {\n\t\t\tconst newValue = startValue;\n\t\t\tthis._updateHandlesAndRange(newValue);\n\t\t\tthis.updateValue(affectedValue, newValue);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t *\n\t * @private\n\t */\n\t_onmousedown(event) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(event);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(event, newValue);\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._isPressInCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t *\n\t * @private\n\t */\n\t_saveInteractionStartData(event, newValue) {\n\t\tconst progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\t// Save the initial press point coordinates (position)\n\t\tthis._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t *\n\t * @private\n\t */\n\t_handleMove(event) {\n\t\tevent.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._isPressInCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(event);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(event);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t *\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event) {\n\t\tconst newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t *\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n\t\t// No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\t\tthis._setAffectedValue(null);\n\n\t\t// Update the UI and the state acccording to the calculated new values\n\t\tthis.update(null, newValues[0], newValues[1]);\n\t}\n\n\t_handleUp() {\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValueByFocusedElement();\n\t\tthis._setAffectedValue(null);\n\n\t\tthis._startValueAtBeginningOfAction = null;\n\t\tthis._endValueAtBeginningOfAction = null;\n\t\tthis._setIsPressInCurrentRange(false);\n\n\t\tthis.handleUpBase();\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t *\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX, value) {\n\t\tconst startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t\tconst endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\t// Flag if press is in the current select range\n\t\tconst isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\t\tthis._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n\t}\n\n\t/**\n\t * Sets the value property (start/end) that will get updated\n\t * by a user action depending on that user action's characteristics\n\t * - mouse press position - cursor coordinates relative to the start/end handles\n\t * - selected inner element via a keyboard navigation\n\t *\n\t * @param {String} valuePropAffectedByInteraction The value that will get modified by the interaction\n\t * @private\n\t */\n\t_setAffectedValue(valuePropAffectedByInteraction) {\n\t\tthis._valueAffected = valuePropAffectedByInteraction;\n\n\t\t// If the values have been swapped reset the reversed flag\n\t\tif (this._areValuesReversed()) {\n\t\t\tthis._setValuesAreReversed();\n\t\t}\n\t}\n\n\t/**\n\t * Flag if press action is made on the currently selected range of values\n\t *\n\t * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n\t * @private\n\t */\n\t_setIsPressInCurrentRange(isPressInCurrentRange) {\n\t\tthis._isPressInCurrentRange = isPressInCurrentRange;\n\t}\n\n\t/**\n\t * Manage the focus between the focusable inner elements within the component.\n\t *\n\t * On initial focusin or if the whole range is affected by the user interaction\n\t * set the focus on the progress selection, otherwise on one of the Range Slider\n\t * handles based on the determined affected value by the user action.\n\t *\n\t * If one of the handles came across the other one in result of a user action\n\t * switch the focus between them to keep it visually consistent.\n\t *\n\t * Note:\n\t * In some cases this function is going to get called twice on one user action.\n\t *\n\t * 1. When the focus is initially set to an inner element it is done in the very beginning,\n\t * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n\t * is still not being received, causining an immediate focusout that we prevent by\n\t * calling this function once again.\n\t *\n\t * 2. When the focused is manually switched from one inner element to another.\n\t * The focusout handler is one and the same for all focusable parts within the\n\t * Range Slider and when is called it checks if it should keep the focus within\n\t * the component and which part of it should get focused if that is the case.\n\t *\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (this._isPressInCurrentRange || !affectedValue) {\n\t\t\tthis._progressBar.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.start && !isReversed) || (affectedValue === RangeSlider.VALUES.end && isReversed)) {\n\t\t\tthis._startHandle.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.end && !isReversed) || (affectedValue === RangeSlider.VALUES.start && isReversed)) {\n\t\t\tthis._endHandle.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\t// Return the current values if there is no difference in the\n\t\t// possitions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tstartValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tif (currentPageXPos > this._initialPageXPosition) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t/**\n\t * Updates the visual representation of the component by calculating\n\t * the styles of the handles and the range selection based on the new state.\n\t *\n\t * @private\n\t */\n\t_updateHandlesAndRange(newValue) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\");\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\");\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (affectedValue === RangeSlider.VALUES.start) {\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (affectedValue === RangeSlider.VALUES.end) {\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = ((this.endValue - min) / (max - min)) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps the start and end values of the handles if one came accros the other:\n\t * - If the start value is greater than the endValue swap them and their handles\n\t * - If the endValue become less than the start value swap them and their handles\n\t *\n\t * Switches the focus to the opposite of the currently focused handle.\n\t *\n\t * Note: Only the property values are reversed, the DOM elements of the handles\n\t * corresponding to them are never switched.\n\t *\n\t * @private\n\t */\n\t_swapValues() {\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n\t\t\tconst prevEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = prevEndValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\n\t\tif (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n\t\t\tconst prevStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = prevStartValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Flag that we have swapped the values of the 'start' and 'end' properties,\n\t * to correctly switch the focus within the component from one handle to another\n\t * when the swapping is finished. As we only swap property values and not\n\t * the handle elements themselves, we must also swap their focus.\n\t *\n\t * @private\n\t */\n\t_setValuesAreReversed() {\n\t\tthis._reversedValues = !this._reversedValues;\n\t }\n\n\t _areValuesReversed() {\n\t\treturn this._reversedValues;\n\t}\n\n\tget _startHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t}\n\n\tget _endHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\t}\n\n\tget _progressBar() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-progress\");\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"width\": `${this._selectedRange * 100}%`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\ttickmarks: {\n\t\t\t\t\"background\": `${this._tickmarks}`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tRangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"]},"metadata":{},"sourceType":"module"}