{"ast":null,"code":"import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/source-code.js\";\nimport { isEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\"; // Styles\n\nimport styles from \"./generated/themes/SliderBase.css.js\";\n/**\n * @public\n */\n\nconst metadata = {\n  properties:\n  /** @lends sap.ui.webcomponents.main.SliderBase.prototype */\n  {\n    /**\n     * Defines the minimum value of the slider.\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    min: {\n      type: Float,\n      defaultValue: 0\n    },\n\n    /**\n     * Defines the maximum value of the slider.\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    max: {\n      type: Float,\n      defaultValue: 100\n    },\n\n    /**\n     * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n     * <br><br>\n     * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n     *\n     * @type {Integer}\n     * @defaultvalue 1\n     * @public\n     */\n    step: {\n      type: Float,\n      defaultValue: 1\n    },\n\n    /**\n     * Displays a label with a value on every N-th step.\n     * <br><br>\n     * <b>Note:</b> The step and tickmarks properties must be enabled.\n     * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n     * tickmark will be labelled, which means every 4th value number.\n     *\n     * @type {Integer}\n     * @defaultvalue 0\n     * @public\n     */\n    labelInterval: {\n      type: Integer,\n      defaultValue: 0\n    },\n\n    /**\n     * Enables tickmarks visualization for each step.\n     * <br><br>\n     * <b>Note:</b> The step must be a positive number.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTickmarks: {\n      type: Boolean\n    },\n\n    /**\n     * Enables handle tooltip displaying the current value.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTooltip: {\n      type: Boolean\n    },\n\n    /**\n     * Defines whether the slider is in disabled state.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    disabled: {\n      type: Boolean\n    },\n\n    /**\n     * @private\n     */\n    _tooltipVisibility: {\n      type: String,\n      defaultValue: \"hidden\"\n    },\n    _labelsOverlapping: {\n      type: Boolean\n    },\n    _hiddenTickmarks: {\n      type: Boolean\n    }\n  },\n  events:\n  /** @lends sap.ui.webcomponents.main.SliderBase.prototype */\n  {\n    /**\n     * Fired when the value changes and the user has finished interacting with the slider.\n     *\n     * @event\n     * @public\n    */\n    change: {},\n\n    /**\n     * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n     *\n     * @event\n     * @public\n    */\n    input: {}\n  }\n};\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\n\nclass SliderBase extends UI5Element {\n  constructor() {\n    super();\n    this._resizeHandler = this._handleResize.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._upHandler = this._handleUp.bind(this);\n    this._stateStorage = {\n      step: null,\n      min: null,\n      max: null,\n      labelInterval: null\n    };\n  }\n\n  static get metadata() {\n    return metadata;\n  }\n\n  static get render() {\n    return litRender;\n  }\n\n  static get styles() {\n    return styles;\n  }\n\n  static get TICKMARK_COLOR_MAP() {\n    return {\n      sap_fiori_3: \"#89919a\",\n      sap_fiori_3_dark: \"#89919a\",\n      sap_fiori_3_hcw: \"#000000\",\n      sap_fiori_3_hcb: \"#ffffff\",\n      sap_belize: \"#bfbfbf\",\n      sap_belize_hcw: \"#000000\",\n      sap_belize_hcb: \"#ffffff\",\n      sap_horizon: \"#89919a\"\n    };\n  }\n\n  static get UP_EVENTS() {\n    return [\"mouseup\", \"touchend\"];\n  }\n\n  static get MOVE_EVENT_MAP() {\n    return {\n      mousedown: \"mousemove\",\n      touchstart: \"touchmove\"\n    };\n  }\n\n  static get ACTION_KEYS() {\n    return [isLeft, isRight, isUp, isDown, isLeftCtrl, isRightCtrl, isUpCtrl, isDownCtrl, isPlus, isMinus, isHome, isEnd, isPageUp, isPageDown, isEscape];\n  }\n\n  static get MIN_SPACE_BETWEEN_TICKMARKS() {\n    return 8;\n  }\n\n  static get TOOLTIP_VISIBILITY() {\n    return {\n      VISIBLE: \"visible\",\n      HIDDEN: \"hidden\"\n    };\n  }\n\n  get classes() {\n    return {\n      root: {\n        \"ui5-slider-root-phone\": isPhone()\n      },\n      labelContainer: {\n        \"ui5-slider-hidden-labels\": this._labelsOverlapping\n      }\n    };\n  }\n\n  onEnterDOM() {\n    ResizeHandler.register(this, this._resizeHandler);\n  }\n\n  onExitDOM() {\n    ResizeHandler.deregister(this, this._handleResize);\n  }\n\n  onAfterRendering() {\n    // Only call if the resize is triggered by a state changes other than\n    // the ones that occured on the previous resize and those caused by user interaction.\n    if (this.notResized) {\n      this._resizeHandler();\n    }\n  }\n\n  _ontouchstart(event) {\n    this._onmousedown(event);\n  }\n  /** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n\n\n  _onmouseover(event) {\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n  /**\n   * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n\n\n  _onmouseout(event) {\n    if (this.showTooltip && !this.shadowRoot.activeElement) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n  /**\n   * Sets initial value when the component is focused in, can be restored with ESC key\n   *\n   * @private\n   */\n\n\n  _setInitialValue(valueType, value) {\n    this[`_${valueType}Initial`] = value;\n  }\n\n  _getInitialValue(valueType) {\n    return this[`_${valueType}Initial`];\n  }\n\n  _onkeydown(event) {\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n\n    if (SliderBase._isActionKey(event)) {\n      event.preventDefault();\n      this._isUserInteraction = true;\n\n      this._handleActionKeyPress(event);\n    }\n  }\n\n  _onkeyup(event) {\n    if (this.disabled) {\n      return;\n    }\n\n    this._isUserInteraction = false;\n  }\n  /**\n   * Flags if an inner element is currently being focused\n   *\n   * @private\n   */\n\n\n  _preserveFocus(isFocusing) {\n    this._isInnerElementFocusing = isFocusing;\n  }\n  /**\n   * Return if an inside element within the component is currently being focused\n   *\n   * @private\n   */\n\n\n  _isFocusing() {\n    return this._isInnerElementFocusing;\n  }\n  /**\n   * Prevent focus out when inner element within the component is currently being in process of focusing in.\n   * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n   * the .attachShadow() customElement method is set to true, or if we forward it manually.\n  \t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n   * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n   * removed as it will become redundant.\n   *\n   * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n   * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n   * is set to the customElement (ui5-slider) causing a 'race condition'.\n   *\n   * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n   * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n   * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n   * in both initial focusing and switching the focus between inner elements of the component cases.\n  \t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n   * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n   * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n   * because of the nature of the component and its available drag interactions.\n   *\n   * @private\n   */\n\n\n  _preventFocusOut() {\n    this.focusInnerElement();\n  }\n  /**\n   * Manages the focus between the component's inner elements\n   * @protected\n   */\n\n\n  focusInnerElement() {\n    this.focus();\n  }\n  /**\n   * Handle the responsiveness of the Slider's UI elements when resizing\n   *\n   * @private\n   */\n\n\n  _handleResize() {\n    if (!this.showTickmarks) {\n      return;\n    } // Mark resizing to avoid unneccessary calls to that function after rendering\n\n\n    this.notResized = false; // Convert the string represented calculation expression to a normal one\n    // Check the distance  in pixels exist between every tickmark\n\n    const spaceBetweenTickmarks = this._spaceBetweenTickmarks(); // If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n    // In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\n\n    if (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n      this._hiddenTickmarks = true;\n      this._labelsOverlapping = true;\n    } else {\n      this._hiddenTickmarks = false;\n    }\n\n    if (this.labelInterval <= 0 || this._hiddenTickmarks) {\n      return;\n    } // Check if there are any overlapping labels.\n    // If so - only the first and the last one should be visible\n\n\n    const labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n    this._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n  }\n  /**\n   * Called when the user starts interacting with the slider.\n   * After a down event on the slider root, listen for move events on window, so the slider value\n   * is updated even if the user drags the pointer outside the slider root.\n   *\n   * @protected\n   */\n\n\n  handleDownBase(event) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const domRect = this.getBoundingClientRect();\n    const directionStart = this.directionStart;\n    const step = this._effectiveStep;\n    const newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart); // Mark start of a user interaction\n\n    this._isUserInteraction = true; // Only allow one type of move event to be listened to (the first one registered after the down event)\n\n    this._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n    SliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n    window.addEventListener(this._moveEventType, this._moveHandler);\n\n    this._handleFocusOnMouseDown(event);\n\n    return newValue;\n  }\n  /**\n   * Forward the focus to an inner inner part within the component on press\n   *\n   * @private\n   */\n\n\n  _handleFocusOnMouseDown(event) {\n    const focusedElement = this.shadowRoot.activeElement;\n\n    if (!focusedElement || focusedElement !== event.target) {\n      this._preserveFocus(true);\n\n      this.focusInnerElement();\n    }\n  }\n  /**\n   * Called when the user finish interacting with the slider\n   * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n   *\n   * @protected\n   */\n\n\n  handleUpBase(valueType) {\n    SliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n    window.removeEventListener(this._moveEventType, this._moveHandler);\n    this._moveEventType = null;\n    this._isUserInteraction = false;\n\n    this._preserveFocus(false);\n  }\n  /**\n   * Updates value property of the component that has been changed due to a user action.\n   * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n   *\n   * @protected\n   */\n\n\n  updateValue(valueType, value) {\n    this[valueType] = value;\n    this.storePropertyState(valueType);\n\n    if (this._isUserInteraction) {\n      this.fireEvent(\"input\");\n    }\n  }\n  /**\n   * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n   *\n   * @private\n   */\n\n\n  static _isActionKey(event) {\n    return this.ACTION_KEYS.some(actionKey => actionKey(event));\n  }\n  /**\n   * Locks the given value between min and max boundaries based on slider properties\n   *\n   * @protected\n   */\n\n\n  static clipValue(value, min, max) {\n    value = Math.min(Math.max(value, min), max);\n    return value;\n  }\n  /**\n   * Sets the slider value from an event\n   *\n   * @protected\n   */\n\n\n  static getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n    const pageX = this.getPageXValueFromEvent(event);\n    const value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n    const steppedValue = this.getSteppedValue(value, stepSize, min);\n    return this.clipValue(steppedValue, min, max);\n  }\n  /**\n   * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n   *\n   * @protected\n   */\n\n\n  static getSteppedValue(value, stepSize, min) {\n    const stepModuloValue = Math.abs((value - min) % stepSize);\n\n    if (stepSize === 0 || stepModuloValue === 0) {\n      return value;\n    } // Clip (snap) the new value to the nearest step\n\n\n    value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue; // If the step value is not a round number get its precision\n\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\n    return value.toFixed(stepPrecision);\n  }\n  /**\n   * Gets pageX value from event on user interaction with the Slider\n   *\n   * @protected\n   */\n\n\n  static getPageXValueFromEvent(event) {\n    if (event.targetTouches && event.targetTouches.length > 0) {\n      return event.targetTouches[0].pageX;\n    }\n\n    return event.pageX;\n  }\n  /**\n   * Computes the new value (in %) from the pageX position of the cursor.\n   * Returns the value rounded to a precision of at most 2 digits after decimal point.\n   *\n   * @protected\n   */\n\n\n  static computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n    // Determine pageX position relative to the Slider DOM\n    const xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX; // Calculate the percentage complete (the \"progress\")\n\n    const percentageComplete = xRelativePosition / boundingClientRect.width; // Fit (map) the complete percentage between the min/max value range\n\n    return min + percentageComplete * (max - min);\n  }\n  /**\n   * Calculates the precision (decimal places) of a number, returns 0 if integer\n   * Handles scientific notation cases.\n   * @private\n   */\n\n\n  static _getDecimalPrecisionOfNumber(value) {\n    if (Number.isInteger(value)) {\n      return 0;\n    }\n\n    const match = String(value).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n  }\n  /**\n   * Normalize current properties, update the previously stored state.\n   *\n   * @protected\n   */\n\n\n  syncUIAndState(...values) {\n    // Validate step and update the stored state for the step property.\n    if (this.isPropertyUpdated(\"step\")) {\n      this._validateStep(this.step);\n\n      this.storePropertyState(\"step\");\n    } // Recalculate the tickmarks and labels and update the stored state.\n\n\n    if (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n      this.storePropertyState(\"min\", \"max\"); // Here the value props are changed programatically (not by user interaction)\n      // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n      // min and max bounderies and update the previous state reference.\n\n      values.forEach(valueType => {\n        const normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n        this.updateValue(valueType, normalizedValue);\n        this.storePropertyState(valueType);\n      });\n    } // Labels must be updated if any of the min/max/step/labelInterval props are changed\n\n\n    if (this.labelInterval && this.showTickmarks) {\n      this._createLabels();\n    } // Update the stored state for the labelInterval, if changed\n\n\n    if (this.isPropertyUpdated(\"labelInterval\")) {\n      this.storePropertyState(\"labelInterval\");\n    }\n  }\n  /**\n   * In order to always keep the visual UI representation and the internal\n   * state in sync, the component has a 'state storage' that is updated when the\n   * current state is changed due to a user action.\n   *\n   * Check if the previously saved state is outdated. That would mean\n   * a property has been changed programatically because the previous state\n   * is always updated in the interaction handlers.\n   *\n   * Will return true if any of the properties is not equal to its previously\n   * stored value.\n   *\n   * @protected\n   */\n\n\n  isCurrentStateOutdated() {\n    return Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n  }\n  /**\n   * Returns the last stored value of a property\n   *\n   * @protected\n   */\n\n\n  getStoredPropertyState(property) {\n    return this._stateStorage[property];\n  }\n  /**\n   * Check if one or more properties have been updated compared to their last\n   * saved values in the state storage.\n   *\n   * @protected\n   */\n\n\n  isPropertyUpdated(...properties) {\n    return properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n  }\n  /**\n   * Updates the previously saved in the _stateStorage values of one or more properties.\n   *\n   * @protected\n   */\n\n\n  storePropertyState(...props) {\n    props.forEach(property => {\n      this._stateStorage[property] = this[property];\n    });\n  }\n  /**\n   * Returns the start side of a direction - left for LTR, right for RTL\n   */\n\n\n  get directionStart() {\n    return this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n  }\n  /**\n   * Calculates and draws the tickmarks with a CSS gradient style\n   *\n   * @private\n   */\n\n\n  get _tickmarks() {\n    if (!this.showTickmarks || !this._effectiveStep) {\n      return;\n    }\n\n    if (this._hiddenTickmarks) {\n      return `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n    } // Convert number values to strings to let the CSS do calculations better\n    // rounding/subpixel behavior\" and the most precise tickmarks distribution\n\n\n    const maxStr = String(this._effectiveMax);\n    const minStr = String(this._effectiveMin);\n    const stepStr = String(this._effectiveStep); // There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n    // respect the variable for more than one theme. It has to be set here for now.\n\n    const currentTheme = getTheme();\n    const tickmarkWidth = \"1px\";\n    const currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n    this._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n    this._hiddenTickmarks = false; // Transparent CSS gradient background\n\n    const tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `; // Draw the tickmarks as a patern over the gradient background\n\n    const tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`; // Combine to get the complete CSS background gradient property value\n\n    return `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n  }\n  /**\n   * Calculates the labels amout, width and text and creates them\n   *\n   * @private\n   */\n\n\n  _createLabels() {\n    if (!this.labelInterval || !this.showTickmarks) {\n      return;\n    }\n\n    const labelInterval = this.labelInterval;\n    const step = this._effectiveStep;\n    const newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval); // If the required labels are already rendered\n\n    if (newNumberOfLabels === this._oldNumberOfLabels) {\n      return;\n    }\n\n    this._oldNumberOfLabels = newNumberOfLabels;\n    this._labelWidth = 100 / newNumberOfLabels;\n    this._labelValues = []; // If the step value is not a round number get its precision\n\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step); // numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n    // calculation to be precize (exactly the same as the distance between the tickmarks).\n    // That's ok as the loop stop condition is set to an integer, so it will practically\n    // \"floor\" the number of labels anyway.\n\n\n    for (let i = 0; i <= newNumberOfLabels; i++) {\n      // Format the label numbers with the same decimal precision as the value of the step property\n      const labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);\n\n      this._labelValues.push(labelItemNumber);\n    }\n  }\n\n  _handleActionKeyPressBase(event, affectedValue) {\n    const isUpAction = SliderBase._isIncreaseValueAction(event);\n\n    const isBigStep = SliderBase._isBigStepAction(event);\n\n    const currentValue = this[affectedValue];\n    const min = this._effectiveMin;\n    const max = this._effectiveMax; // We need to take into consideration the effective direction of the slider - rtl or ltr.\n    // While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\n    let step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep; // If the action key corresponds to a long step and the slider has more than 10 normal steps,\n    // make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\n    step = isBigStep && (max - min) / step > 10 ? (max - min) / 10 : step;\n\n    if (isEnd(event)) {\n      return max - currentValue;\n    }\n\n    if (isHome(event)) {\n      return (currentValue - min) * -1;\n    }\n\n    return isUpAction ? step : step * -1;\n  }\n\n  static _isDecreaseValueAction(event) {\n    return isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n  }\n\n  static _isIncreaseValueAction(event) {\n    return isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n  }\n\n  static _isBigStepAction(event) {\n    return isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n  }\n  /**\n   * Calculates space between tickmarks\n   *\n   * @private\n   */\n\n\n  _spaceBetweenTickmarks() {\n    const tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\n    const tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n    return this.getBoundingClientRect().width / tickmarksAmount;\n  }\n  /**\n   * Notify in case of a invalid step value type\n   *\n   * @private\n   */\n\n\n  _validateStep(step) {\n    if (step === 0) {\n      console.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n    }\n\n    if (step < 0) {\n      console.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n    }\n\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      console.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n    }\n  }\n\n  get _labels() {\n    return this._labelValues || [];\n  }\n  /**\n   * Normalizes a new <code>step</code> property value.\n   * If tickmarks are enabled recreates them according to it.\n   *\n   * @private\n   */\n\n\n  get _effectiveStep() {\n    let step = this.step;\n\n    if (step < 0) {\n      step = Math.abs(step);\n    }\n\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      step = 1;\n    }\n\n    return step;\n  }\n\n  get _effectiveMin() {\n    return Math.min(this.min, this.max);\n  }\n\n  get _effectiveMax() {\n    return Math.max(this.min, this.max);\n  }\n\n  get tabIndex() {\n    return this.disabled ? \"-1\" : \"0\";\n  }\n\n}\n\nexport default SliderBase;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents/dist/SliderBase.js"],"names":["UI5Element","litRender","Float","Integer","ResizeHandler","isPhone","isEscape","isHome","isEnd","isUp","isDown","isRight","isLeft","isUpCtrl","isDownCtrl","isRightCtrl","isLeftCtrl","isPlus","isMinus","isPageUp","isPageDown","getTheme","styles","metadata","properties","min","type","defaultValue","max","step","labelInterval","showTickmarks","Boolean","showTooltip","disabled","_tooltipVisibility","String","_labelsOverlapping","_hiddenTickmarks","events","change","input","SliderBase","constructor","_resizeHandler","_handleResize","bind","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","render","TICKMARK_COLOR_MAP","sap_fiori_3","sap_fiori_3_dark","sap_fiori_3_hcw","sap_fiori_3_hcb","sap_belize","sap_belize_hcw","sap_belize_hcb","sap_horizon","UP_EVENTS","MOVE_EVENT_MAP","mousedown","touchstart","ACTION_KEYS","MIN_SPACE_BETWEEN_TICKMARKS","TOOLTIP_VISIBILITY","VISIBLE","HIDDEN","classes","root","labelContainer","onEnterDOM","register","onExitDOM","deregister","onAfterRendering","notResized","_ontouchstart","event","_onmousedown","_onmouseover","_onmouseout","shadowRoot","activeElement","_setInitialValue","valueType","value","_getInitialValue","_onkeydown","_effectiveStep","_isActionKey","preventDefault","_isUserInteraction","_handleActionKeyPress","_onkeyup","_preserveFocus","isFocusing","_isInnerElementFocusing","_isFocusing","_preventFocusOut","focusInnerElement","focus","spaceBetweenTickmarks","_spaceBetweenTickmarks","labelItems","querySelectorAll","some","label","scrollWidth","clientWidth","handleDownBase","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","newValue","getValueFromInteraction","_moveEventType","forEach","upEventType","window","addEventListener","_handleFocusOnMouseDown","focusedElement","target","handleUpBase","removeEventListener","updateValue","storePropertyState","fireEvent","actionKey","clipValue","Math","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","abs","stepPrecision","_getDecimalPrecisionOfNumber","toFixed","targetTouches","length","xRelativePosition","percentageComplete","width","Number","isInteger","match","syncUIAndState","values","isPropertyUpdated","_validateStep","normalizedValue","_createLabels","isCurrentStateOutdated","Object","entries","propName","propValue","getStoredPropertyState","property","prop","props","effectiveDir","_tickmarks","maxStr","minStr","stepStr","currentTheme","tickmarkWidth","currentColor","_tickmarksAmount","tickmarksGradientBase","tickmarksGradientdPattern","newNumberOfLabels","_oldNumberOfLabels","_labelWidth","_labelValues","i","labelItemNumber","push","_handleActionKeyPressBase","affectedValue","isUpAction","_isIncreaseValueAction","isBigStep","_isBigStepAction","currentValue","_isDecreaseValueAction","tickmarksAmountStrCalc","split","tickmarksAmount","console","warn","isNaN","_labels","tabIndex"],"mappings":"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","sourcesContent":["import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/source-code.js\";\nimport {\n\tisEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\tproperties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */  {\n\t\t/**\n\t\t * Defines the minimum value of the slider.\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tmin: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines the maximum value of the slider.\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tmax: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t\t/**\n\t\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t\t * <br><br>\n\t\t * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 1\n\t\t * @public\n\t\t */\n\t\tstep: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 1,\n\t\t},\n\t\t/**\n\t\t * Displays a label with a value on every N-th step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step and tickmarks properties must be enabled.\n\t\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t\t * tickmark will be labelled, which means every 4th value number.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tlabelInterval: {\n\t\t\ttype: Integer,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Enables tickmarks visualization for each step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step must be a positive number.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Enables handle tooltip displaying the current value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTooltip: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Defines whether the slider is in disabled state.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tooltipVisibility: {\n\t\t\ttype: String,\n\t\t\tdefaultValue: \"hidden\",\n\t\t},\n\t\t_labelsOverlapping: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t_hiddenTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n\tevents: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */ {\n\t\t/**\n\t\t * Fired when the value changes and the user has finished interacting with the slider.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tchange: {},\n\t\t/**\n\t\t * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tinput: {},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: null,\n\t\t\tmin: null,\n\t\t\tmax: null,\n\t\t\tlabelInterval: null,\n\t\t};\n\t}\n\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get render() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn styles;\n\t}\n\n\tstatic get TICKMARK_COLOR_MAP() {\n\t\treturn {\n\t\t\tsap_fiori_3: \"#89919a\",\n\t\t\tsap_fiori_3_dark: \"#89919a\",\n\t\t\tsap_fiori_3_hcw: \"#000000\",\n\t\t\tsap_fiori_3_hcb: \"#ffffff\",\n\t\t\tsap_belize: \"#bfbfbf\",\n\t\t\tsap_belize_hcw: \"#000000\",\n\t\t\tsap_belize_hcb: \"#ffffff\",\n\t\t\tsap_horizon: \"#89919a\",\n\t\t};\n\t}\n\n\tstatic get UP_EVENTS() {\n\t\treturn [\"mouseup\", \"touchend\"];\n\t}\n\n\tstatic get MOVE_EVENT_MAP() {\n\t\treturn {\n\t\t\tmousedown: \"mousemove\",\n\t\t\ttouchstart: \"touchmove\",\n\t\t};\n\t}\n\n\tstatic get ACTION_KEYS() {\n\t\treturn [\n\t\t\tisLeft,\n\t\t\tisRight,\n\t\t\tisUp,\n\t\t\tisDown,\n\t\t\tisLeftCtrl,\n\t\t\tisRightCtrl,\n\t\t\tisUpCtrl,\n\t\t\tisDownCtrl,\n\t\t\tisPlus,\n\t\t\tisMinus,\n\t\t\tisHome,\n\t\t\tisEnd,\n\t\t\tisPageUp,\n\t\t\tisPageDown,\n\t\t\tisEscape,\n\t\t];\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tstatic get TOOLTIP_VISIBILITY() {\n\t\treturn {\n\t\t\tVISIBLE: \"visible\",\n\t\t\tHIDDEN: \"hidden\",\n\t\t};\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\troot: {\n\t\t\t\t\"ui5-slider-root-phone\": isPhone(),\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._handleResize);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t_ontouchstart(event) {\n\t\tthis._onmousedown(event);\n\t}\n\n\t/** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseover(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseout(event) {\n\t\tif (this.showTooltip && !this.shadowRoot.activeElement) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t * Sets initial value when the component is focused in, can be restored with ESC key\n\t *\n\t * @private\n\t */\n\t_setInitialValue(valueType, value) {\n\t\tthis[`_${valueType}Initial`] = value;\n\t}\n\n\t_getInitialValue(valueType) {\n\t\treturn this[`_${valueType}Initial`];\n\t}\n\n\t_onkeydown(event) {\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (SliderBase._isActionKey(event)) {\n\t\t\tevent.preventDefault();\n\n\t\t\tthis._isUserInteraction = true;\n\t\t\tthis._handleActionKeyPress(event);\n\t\t}\n\t}\n\n\t_onkeyup(event) {\n\t\tif (this.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Flags if an inner element is currently being focused\n\t *\n\t * @private\n\t */\n\t_preserveFocus(isFocusing) {\n\t\tthis._isInnerElementFocusing = isFocusing;\n\t}\n\n\t/**\n\t * Return if an inside element within the component is currently being focused\n\t *\n\t * @private\n\t */\n\t_isFocusing() {\n\t\treturn this._isInnerElementFocusing;\n\t}\n\n\t/**\n\t * Prevent focus out when inner element within the component is currently being in process of focusing in.\n\t * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n\t * the .attachShadow() customElement method is set to true, or if we forward it manually.\n\n\t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n\t * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n\t * removed as it will become redundant.\n\t *\n\t * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n\t * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n\t * is set to the customElement (ui5-slider) causing a 'race condition'.\n\t *\n\t * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n\t * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n\t * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n\t * in both initial focusing and switching the focus between inner elements of the component cases.\n\n\t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n\t * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n\t * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n\t * because of the nature of the component and its available drag interactions.\n\t *\n\t * @private\n\t */\n\t_preventFocusOut() {\n\t\tthis.focusInnerElement();\n\t}\n\n\t/**\n\t * Manages the focus between the component's inner elements\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tthis.focus();\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t *\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t *\n\t * @protected\n\t */\n\thandleDownBase(event) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tthis._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n\t\twindow.addEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._handleFocusOnMouseDown(event);\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Forward the focus to an inner inner part within the component on press\n\t *\n\t * @private\n\t */\n\t_handleFocusOnMouseDown(event) {\n\t\tconst focusedElement = this.shadowRoot.activeElement;\n\n\t\tif (!focusedElement || focusedElement !== event.target) {\n\t\t\tthis._preserveFocus(true);\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n\t *\n\t * @protected\n\t */\n\thandleUpBase(valueType) {\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n\t\twindow.removeEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._moveEventType = null;\n\t\tthis._isUserInteraction = false;\n\t\tthis._preserveFocus(false);\n\t}\n\n\t/**\n\t * Updates value property of the component that has been changed due to a user action.\n\t * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n\t *\n\t * @protected\n\t */\n\tupdateValue(valueType, value) {\n\t\tthis[valueType] = value;\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n\t *\n\t * @private\n\t */\n\tstatic _isActionKey(event) {\n\t\treturn this.ACTION_KEYS.some(actionKey => actionKey(event));\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t *\n\t * @protected\n\t */\n\tstatic clipValue(value, min, max) {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t *\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n\t\tconst pageX = this.getPageXValueFromEvent(event);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t *\n\t * @protected\n\t */\n\tstatic getSteppedValue(value, stepSize, min) {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn value.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t *\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(event) {\n\t\tif (event.targetTouches && event.targetTouches.length > 0) {\n\t\t\treturn event.targetTouches[0].pageX;\n\t\t}\n\n\t\treturn event.pageX;\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t *\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * Normalize current properties, update the previously stored state.\n\t *\n\t * @protected\n\t */\n\tsyncUIAndState(...values) {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tvalues.forEach(valueType => {\n\t\t\t\tconst normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n\t\t\t\tthis.updateValue(valueType, normalizedValue);\n\t\t\t\tthis.storePropertyState(valueType);\n\t\t\t});\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t *\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t *\n\t * @protected\n\t */\n\tgetStoredPropertyState(property) {\n\t\treturn this._stateStorage[property];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t *\n\t * @protected\n\t */\n\tisPropertyUpdated(...properties) {\n\t\treturn properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t *\n\t * @protected\n\t */\n\tstorePropertyState(...props) {\n\t\tprops.forEach(property => {\n\t\t\tthis._stateStorage[property] = this[property];\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates and draws the tickmarks with a CSS gradient style\n\t *\n\t * @private\n\t */\n\tget _tickmarks() {\n\t\tif (!this.showTickmarks || !this._effectiveStep) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n\t\t}\n\n\t\t// Convert number values to strings to let the CSS do calculations better\n\t\t// rounding/subpixel behavior\" and the most precise tickmarks distribution\n\t\tconst maxStr = String(this._effectiveMax);\n\t\tconst minStr = String(this._effectiveMin);\n\t\tconst stepStr = String(this._effectiveStep);\n\n\t\t// There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n\t\t// respect the variable for more than one theme. It has to be set here for now.\n\t\tconst currentTheme = getTheme();\n\t\tconst tickmarkWidth = \"1px\";\n\t\tconst currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n\n\t\tthis._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n\t\tthis._hiddenTickmarks = false;\n\n\t\t// Transparent CSS gradient background\n\t\tconst tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `;\n\n\t\t// Draw the tickmarks as a patern over the gradient background\n\t\tconst tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`;\n\n\t\t// Combine to get the complete CSS background gradient property value\n\t\treturn `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n\t}\n\n\t/**\n\t * Calculates the labels amout, width and text and creates them\n\t *\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\t_handleActionKeyPressBase(event, affectedValue) {\n\t\tconst isUpAction = SliderBase._isIncreaseValueAction(event);\n\t\tconst isBigStep = SliderBase._isBigStepAction(event);\n\n\t\tconst currentValue = this[affectedValue];\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\n\t\t// We need to take into consideration the effective direction of the slider - rtl or ltr.\n\t\t// While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\t\tlet step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n\n\t\t// If the action key corresponds to a long step and the slider has more than 10 normal steps,\n\t\t// make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\t\tstep = isBigStep && ((max - min) / step > 10) ? (max - min) / 10 : step;\n\n\t\tif (isEnd(event)) {\n\t\t\treturn max - currentValue;\n\t\t}\n\n\t\tif (isHome(event)) {\n\t\t\treturn (currentValue - min) * -1;\n\t\t}\n\n\t\treturn isUpAction ? step : step * -1;\n\t}\n\n\tstatic _isDecreaseValueAction(event) {\n\t\treturn isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n\t}\n\n\tstatic _isIncreaseValueAction(event) {\n\t\treturn isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n\t}\n\n\tstatic _isBigStepAction(event) {\n\t\treturn isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t *\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\tconst tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\t\tconst tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n\n\t\treturn this.getBoundingClientRect().width / tickmarksAmount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t *\n\t * @private\n\t */\n\t_validateStep(step) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Normalizes a new <code>step</code> property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t *\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n\n\tget tabIndex() {\n\t\treturn this.disabled ? \"-1\" : \"0\";\n\t}\n}\n\nexport default SliderBase;\n"]},"metadata":{},"sourceType":"module"}