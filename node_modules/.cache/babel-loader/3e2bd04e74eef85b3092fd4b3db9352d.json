{"ast":null,"code":"import { isDown, isUp, isLeft, isRight, isHome, isEnd } from \"../Keys.js\";\nimport getActiveElement from \"../util/getActiveElement.js\";\nimport NavigationMode from \"../types/NavigationMode.js\";\nimport ItemNavigationBehavior from \"../types/ItemNavigationBehavior.js\";\n/**\n * The ItemNavigation class manages the calculations to determine the correct \"tabindex\" for a group of related items inside a root component.\n * Important: ItemNavigation only does the calculations and does not change \"tabindex\" directly, this is a responsibility of the developer.\n *\n * The keys that trigger ItemNavigation are:\n *  - Up/down\n *  - Left/right\n *  - Home/End\n *\n * Usage:\n * 1) Use the \"getItemsCallback\" constructor property to pass a callback to ItemNavigation, which, whenever called, will return the list of items to navigate among.\n *\n * Each item passed to ItemNavigation via \"getItemsCallback\" must be:\n *  - A) either a UI5Element with a \"_tabIndex\" property\n *  - B) or an Object with \"id\" and \"_tabIndex\" properties which represents a part of the root component's shadow DOM.\n *    The \"id\" must be a valid ID within the shadow root of the component ItemNavigation operates on.\n *    This object must not be a DOM object because, as said, ItemNavigation will not set \"tabindex\" on it. It must be a representation of a DOM object only\n *    and the developer has the responsibility to update the \"tabindex\" in the component's DOM.\n *  - C) a combination of the above\n *\n * Whenever the user navigates with the keyboard, ItemNavigation will modify the \"_tabIndex\" properties of the items.\n * It is the items' responsibilities to re-render themselves and apply the correct value of \"tabindex\" (i.e. to map the \"_tabIndex\" ItemNavigation set to them to the \"tabindex\" property).\n * If the items of the ItemNavigation are UI5Elements themselves, this can happen naturally since they will be invalidated by their \"_tabIndex\" property.\n * If the items are Objects with \"id\" and \"_tabIndex\" however, it is the developer's responsibility to apply these and the easiest way is to have the root component invalidated by ItemNavigation.\n * To do so, set the \"affectedPropertiesNames\" constructor property to point to one or more of the root component's properties that need refreshing when \"_tabIndex\" is changed deeply.\n *\n * 2) Call the \"setCurrentItem\" method of ItemNavigation whenever you want to change the current item.\n * This is most commonly required if the user for example clicks on an item and thus selects it directly.\n * Pass as the only argument to \"setCurrentItem\" the item that becomes current (must be one of the items, returned by \"getItemsCallback\").\n *\n * @class\n * @public\n */\n\nclass ItemNavigation {\n  /**\n   *\n   * @param rootWebComponent the component to operate on (component that slots or contains within its shadow root the items the user navigates among)\n   * @param options Object with configuration options:\n   *  - currentIndex: the index of the item that will be initially selected (from which navigation will begin)\n   *  - navigationMode (Auto|Horizontal|Vertical): whether the items are displayed horizontally (Horizontal), vertically (Vertical) or as a matrix (Auto) meaning the user can navigate in both directions (up/down and left/right)\n   *  - rowSize: tells how many items per row there are when the items are not rendered as a flat list but rather as a matrix. Relevant for navigationMode=Auto\n   *  - behavior (Static|Cycling): tells what to do when trying to navigate beyond the first and last items\n   *    Static means that nothing happens if the user tries to navigate beyond the first/last item.\n   *    Cycling means that when the user navigates beyond the last item they go to the first and vice versa.\n   *  - getItemsCallback: function that, when called, returns an array with all items the user can navigate among\n   *  - affectedPropertiesNames: a list of metadata properties on the root component which, upon user navigation, will be reassigned by address thus causing the root component to invalidate\n   */\n  constructor(rootWebComponent, options = {}) {\n    this._setRootComponent(rootWebComponent);\n\n    this._initOptions(options);\n  }\n\n  _setRootComponent(rootWebComponent) {\n    if (!rootWebComponent.isUI5Element) {\n      throw new Error(\"The root web component must be a UI5 Element instance\");\n    }\n\n    this.rootWebComponent = rootWebComponent;\n    this.rootWebComponent.addEventListener(\"keydown\", this._onkeydown.bind(this));\n\n    this.rootWebComponent._onComponentStateFinalized = () => {\n      this._init();\n    };\n  }\n\n  _initOptions(options) {\n    if (typeof options.getItemsCallback !== \"function\") {\n      throw new Error(\"getItemsCallback is required\");\n    }\n\n    this._getItems = options.getItemsCallback;\n    this._currentIndex = options.currentIndex || 0;\n    this._rowSize = options.rowSize || 1;\n    this._behavior = options.behavior || ItemNavigationBehavior.Static;\n    this._navigationMode = options.navigationMode || NavigationMode.Auto;\n    this._affectedPropertiesNames = options.affectedPropertiesNames || [];\n  }\n  /**\n   * Call this method to set a new \"current\" (selected) item in the item navigation\n   * Note: the item passed to this function must be one of the items, returned by the getItemsCallback function\n   *\n   * @public\n   * @param current the new selected item\n   */\n\n\n  setCurrentItem(current) {\n    const currentItemIndex = this._getItems().indexOf(current);\n\n    if (currentItemIndex === -1) {\n      console.warn(`The provided item is not managed by ItemNavigation`, current); // eslint-disable-line\n\n      return;\n    }\n\n    this._currentIndex = currentItemIndex;\n\n    this._applyTabIndex();\n  }\n  /**\n   * Call this method to dynamically change the row size\n   *\n   * @public\n   * @param newRowSize\n   */\n\n\n  setRowSize(newRowSize) {\n    this._rowSize = newRowSize;\n  }\n\n  _init() {\n    this._getItems().forEach((item, idx) => {\n      item._tabIndex = idx === this._currentIndex ? \"0\" : \"-1\";\n    });\n  }\n\n  _onkeydown(event) {\n    if (!this._canNavigate()) {\n      return;\n    }\n\n    const horizontalNavigationOn = this._navigationMode === NavigationMode.Horizontal || this._navigationMode === NavigationMode.Auto;\n    const verticalNavigationOn = this._navigationMode === NavigationMode.Vertical || this._navigationMode === NavigationMode.Auto;\n\n    if (isUp(event) && verticalNavigationOn) {\n      this._handleUp();\n    } else if (isDown(event) && verticalNavigationOn) {\n      this._handleDown();\n    } else if (isLeft(event) && horizontalNavigationOn) {\n      this._handleLeft();\n    } else if (isRight(event) && horizontalNavigationOn) {\n      this._handleRight();\n    } else if (isHome(event)) {\n      this._handleHome();\n    } else if (isEnd(event)) {\n      this._handleEnd();\n    } else {\n      return; // if none of the supported keys is pressed, we don't want to prevent the event or update the item navigation\n    }\n\n    event.preventDefault();\n\n    this._applyTabIndex();\n\n    this._focusCurrentItem();\n  }\n\n  _handleUp() {\n    const itemsLength = this._getItems().length;\n\n    if (this._currentIndex - this._rowSize >= 0) {\n      // no border reached, just decrease the index by a row\n      this._currentIndex -= this._rowSize;\n      return;\n    }\n\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // if cyclic, go to the **last** item in the **previous** column\n      const firstItemInThisColumnIndex = this._currentIndex % this._rowSize;\n      const firstItemInPreviousColumnIndex = firstItemInThisColumnIndex === 0 ? this._rowSize - 1 : firstItemInThisColumnIndex - 1; // find the first item in the previous column (if the current column is the first column -> move to the last column)\n\n      const rows = Math.ceil(itemsLength / this._rowSize); // how many rows there are (even if incomplete, f.e. for 14 items and _rowSize=4 -> 4 rows total, although only 2 items on the last row)\n\n      let lastItemInPreviousColumnIndex = firstItemInPreviousColumnIndex + (rows - 1) * this._rowSize; // multiply rows by columns, and add the column's first item's index\n\n      if (lastItemInPreviousColumnIndex > itemsLength - 1) {\n        // for incomplete rows, use the previous row's last item, as for them the last item is missing\n        lastItemInPreviousColumnIndex -= this._rowSize;\n      }\n\n      this._currentIndex = lastItemInPreviousColumnIndex;\n    } else {\n      // not cyclic, so just go to the first item\n      this._currentIndex = 0;\n    }\n  }\n\n  _handleDown() {\n    const itemsLength = this._getItems().length;\n\n    if (this._currentIndex + this._rowSize < itemsLength) {\n      // no border reached, just increase the index by a row\n      this._currentIndex += this._rowSize;\n      return;\n    }\n\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // if cyclic, go to the **first** item in the **next** column\n      const firstItemInThisColumnIndex = this._currentIndex % this._rowSize; // find the first item in the current column first\n\n      const firstItemInNextColumnIndex = (firstItemInThisColumnIndex + 1) % this._rowSize; // to get the first item in the next column, just increase the index by 1. The modulo by rows is for the case when we are at the last column\n\n      this._currentIndex = firstItemInNextColumnIndex;\n    } else {\n      // not cyclic, so just go to the last item\n      this._currentIndex = itemsLength - 1;\n    }\n  }\n\n  _handleLeft() {\n    const itemsLength = this._getItems().length;\n\n    if (this._currentIndex > 0) {\n      this._currentIndex -= 1;\n      return;\n    }\n\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // go to the first item in the next column\n      this._currentIndex = itemsLength - 1;\n    }\n  }\n\n  _handleRight() {\n    const itemsLength = this._getItems().length;\n\n    if (this._currentIndex < itemsLength - 1) {\n      this._currentIndex += 1;\n      return;\n    }\n\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // go to the first item in the next column\n      this._currentIndex = 0;\n    }\n  }\n\n  _handleHome() {\n    const homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n    this._currentIndex -= this._currentIndex % homeEndRange;\n  }\n\n  _handleEnd() {\n    const homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n    this._currentIndex += homeEndRange - 1 - this._currentIndex % homeEndRange; // eslint-disable-line\n  }\n\n  _applyTabIndex() {\n    const items = this._getItems();\n\n    for (let i = 0; i < items.length; i++) {\n      items[i]._tabIndex = i === this._currentIndex ? \"0\" : \"-1\";\n    }\n\n    this._affectedPropertiesNames.forEach(propName => {\n      const prop = this.rootWebComponent[propName];\n      this.rootWebComponent[propName] = Array.isArray(prop) ? [...prop] : { ...prop\n      };\n    });\n  }\n\n  _focusCurrentItem() {\n    const currentItem = this._getCurrentItem();\n\n    if (currentItem) {\n      currentItem.focus();\n    }\n  }\n\n  _canNavigate() {\n    const currentItem = this._getCurrentItem();\n\n    const activeElement = getActiveElement();\n    return currentItem && currentItem === activeElement;\n  }\n\n  _getCurrentItem() {\n    const items = this._getItems();\n\n    if (!items.length) {\n      return null;\n    } // normalize the index\n\n\n    while (this._currentIndex >= items.length) {\n      this._currentIndex -= this._rowSize;\n    }\n\n    if (this._currentIndex < 0) {\n      this._currentIndex = 0;\n    }\n\n    const currentItem = items[this._currentIndex];\n\n    if (!currentItem) {\n      return;\n    }\n\n    if (currentItem.isUI5Element) {\n      return currentItem.getFocusDomRef();\n    }\n\n    if (!this.rootWebComponent.getDomRef()) {\n      return;\n    }\n\n    return this.rootWebComponent.getDomRef().querySelector(`#${currentItem.id}`);\n  }\n\n}\n\nexport default ItemNavigation;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/delegate/ItemNavigation.js"],"names":["isDown","isUp","isLeft","isRight","isHome","isEnd","getActiveElement","NavigationMode","ItemNavigationBehavior","ItemNavigation","constructor","rootWebComponent","options","_setRootComponent","_initOptions","isUI5Element","Error","addEventListener","_onkeydown","bind","_onComponentStateFinalized","_init","getItemsCallback","_getItems","_currentIndex","currentIndex","_rowSize","rowSize","_behavior","behavior","Static","_navigationMode","navigationMode","Auto","_affectedPropertiesNames","affectedPropertiesNames","setCurrentItem","current","currentItemIndex","indexOf","console","warn","_applyTabIndex","setRowSize","newRowSize","forEach","item","idx","_tabIndex","event","_canNavigate","horizontalNavigationOn","Horizontal","verticalNavigationOn","Vertical","_handleUp","_handleDown","_handleLeft","_handleRight","_handleHome","_handleEnd","preventDefault","_focusCurrentItem","itemsLength","length","Cyclic","firstItemInThisColumnIndex","firstItemInPreviousColumnIndex","rows","Math","ceil","lastItemInPreviousColumnIndex","firstItemInNextColumnIndex","homeEndRange","items","i","propName","prop","Array","isArray","currentItem","_getCurrentItem","focus","activeElement","getFocusDomRef","getDomRef","querySelector","id"],"mappings":"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","sourcesContent":["import {\n\tisDown,\n\tisUp,\n\tisLeft,\n\tisRight,\n\tisHome,\n\tisEnd,\n} from \"../Keys.js\";\nimport getActiveElement from \"../util/getActiveElement.js\";\n\nimport NavigationMode from \"../types/NavigationMode.js\";\nimport ItemNavigationBehavior from \"../types/ItemNavigationBehavior.js\";\n\n/**\n * The ItemNavigation class manages the calculations to determine the correct \"tabindex\" for a group of related items inside a root component.\n * Important: ItemNavigation only does the calculations and does not change \"tabindex\" directly, this is a responsibility of the developer.\n *\n * The keys that trigger ItemNavigation are:\n *  - Up/down\n *  - Left/right\n *  - Home/End\n *\n * Usage:\n * 1) Use the \"getItemsCallback\" constructor property to pass a callback to ItemNavigation, which, whenever called, will return the list of items to navigate among.\n *\n * Each item passed to ItemNavigation via \"getItemsCallback\" must be:\n *  - A) either a UI5Element with a \"_tabIndex\" property\n *  - B) or an Object with \"id\" and \"_tabIndex\" properties which represents a part of the root component's shadow DOM.\n *    The \"id\" must be a valid ID within the shadow root of the component ItemNavigation operates on.\n *    This object must not be a DOM object because, as said, ItemNavigation will not set \"tabindex\" on it. It must be a representation of a DOM object only\n *    and the developer has the responsibility to update the \"tabindex\" in the component's DOM.\n *  - C) a combination of the above\n *\n * Whenever the user navigates with the keyboard, ItemNavigation will modify the \"_tabIndex\" properties of the items.\n * It is the items' responsibilities to re-render themselves and apply the correct value of \"tabindex\" (i.e. to map the \"_tabIndex\" ItemNavigation set to them to the \"tabindex\" property).\n * If the items of the ItemNavigation are UI5Elements themselves, this can happen naturally since they will be invalidated by their \"_tabIndex\" property.\n * If the items are Objects with \"id\" and \"_tabIndex\" however, it is the developer's responsibility to apply these and the easiest way is to have the root component invalidated by ItemNavigation.\n * To do so, set the \"affectedPropertiesNames\" constructor property to point to one or more of the root component's properties that need refreshing when \"_tabIndex\" is changed deeply.\n *\n * 2) Call the \"setCurrentItem\" method of ItemNavigation whenever you want to change the current item.\n * This is most commonly required if the user for example clicks on an item and thus selects it directly.\n * Pass as the only argument to \"setCurrentItem\" the item that becomes current (must be one of the items, returned by \"getItemsCallback\").\n *\n * @class\n * @public\n */\nclass ItemNavigation {\n\t/**\n\t *\n\t * @param rootWebComponent the component to operate on (component that slots or contains within its shadow root the items the user navigates among)\n\t * @param options Object with configuration options:\n\t *  - currentIndex: the index of the item that will be initially selected (from which navigation will begin)\n\t *  - navigationMode (Auto|Horizontal|Vertical): whether the items are displayed horizontally (Horizontal), vertically (Vertical) or as a matrix (Auto) meaning the user can navigate in both directions (up/down and left/right)\n\t *  - rowSize: tells how many items per row there are when the items are not rendered as a flat list but rather as a matrix. Relevant for navigationMode=Auto\n\t *  - behavior (Static|Cycling): tells what to do when trying to navigate beyond the first and last items\n\t *    Static means that nothing happens if the user tries to navigate beyond the first/last item.\n\t *    Cycling means that when the user navigates beyond the last item they go to the first and vice versa.\n\t *  - getItemsCallback: function that, when called, returns an array with all items the user can navigate among\n\t *  - affectedPropertiesNames: a list of metadata properties on the root component which, upon user navigation, will be reassigned by address thus causing the root component to invalidate\n\t */\n\tconstructor(rootWebComponent, options = {}) {\n\t\tthis._setRootComponent(rootWebComponent);\n\t\tthis._initOptions(options);\n\t}\n\n\t_setRootComponent(rootWebComponent) {\n\t\tif (!rootWebComponent.isUI5Element) {\n\t\t\tthrow new Error(\"The root web component must be a UI5 Element instance\");\n\t\t}\n\t\tthis.rootWebComponent = rootWebComponent;\n\t\tthis.rootWebComponent.addEventListener(\"keydown\", this._onkeydown.bind(this));\n\t\tthis.rootWebComponent._onComponentStateFinalized = () => {\n\t\t\tthis._init();\n\t\t};\n\t}\n\n\t_initOptions(options) {\n\t\tif (typeof options.getItemsCallback !== \"function\") {\n\t\t\tthrow new Error(\"getItemsCallback is required\");\n\t\t}\n\n\t\tthis._getItems = options.getItemsCallback;\n\t\tthis._currentIndex = options.currentIndex || 0;\n\t\tthis._rowSize = options.rowSize || 1;\n\t\tthis._behavior = options.behavior || ItemNavigationBehavior.Static;\n\t\tthis._navigationMode = options.navigationMode || NavigationMode.Auto;\n\t\tthis._affectedPropertiesNames = options.affectedPropertiesNames || [];\n\t}\n\n\t/**\n\t * Call this method to set a new \"current\" (selected) item in the item navigation\n\t * Note: the item passed to this function must be one of the items, returned by the getItemsCallback function\n\t *\n\t * @public\n\t * @param current the new selected item\n\t */\n\tsetCurrentItem(current) {\n\t\tconst currentItemIndex = this._getItems().indexOf(current);\n\n\t\tif (currentItemIndex === -1) {\n\t\t\tconsole.warn(`The provided item is not managed by ItemNavigation`, current); // eslint-disable-line\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentIndex = currentItemIndex;\n\t\tthis._applyTabIndex();\n\t}\n\n\t/**\n\t * Call this method to dynamically change the row size\n\t *\n\t * @public\n\t * @param newRowSize\n\t */\n\tsetRowSize(newRowSize) {\n\t\tthis._rowSize = newRowSize;\n\t}\n\n\t_init() {\n\t\tthis._getItems().forEach((item, idx) => {\n\t\t\titem._tabIndex = (idx === this._currentIndex) ? \"0\" : \"-1\";\n\t\t});\n\t}\n\n\t_onkeydown(event) {\n\t\tif (!this._canNavigate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst horizontalNavigationOn = this._navigationMode === NavigationMode.Horizontal || this._navigationMode === NavigationMode.Auto;\n\t\tconst verticalNavigationOn = this._navigationMode === NavigationMode.Vertical || this._navigationMode === NavigationMode.Auto;\n\n\t\tif (isUp(event) && verticalNavigationOn) {\n\t\t\tthis._handleUp();\n\t\t} else if (isDown(event) && verticalNavigationOn) {\n\t\t\tthis._handleDown();\n\t\t} else if (isLeft(event) && horizontalNavigationOn) {\n\t\t\tthis._handleLeft();\n\t\t} else if (isRight(event) && horizontalNavigationOn) {\n\t\t\tthis._handleRight();\n\t\t} else if (isHome(event)) {\n\t\t\tthis._handleHome();\n\t\t} else if (isEnd(event)) {\n\t\t\tthis._handleEnd();\n\t\t} else {\n\t\t\treturn; // if none of the supported keys is pressed, we don't want to prevent the event or update the item navigation\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tthis._applyTabIndex();\n\t\tthis._focusCurrentItem();\n\t}\n\n\t_handleUp() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex - this._rowSize >= 0) { // no border reached, just decrease the index by a row\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **last** item in the **previous** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize;\n\t\t\tconst firstItemInPreviousColumnIndex = firstItemInThisColumnIndex === 0 ? this._rowSize - 1 : firstItemInThisColumnIndex - 1; // find the first item in the previous column (if the current column is the first column -> move to the last column)\n\t\t\tconst rows = Math.ceil(itemsLength / this._rowSize); // how many rows there are (even if incomplete, f.e. for 14 items and _rowSize=4 -> 4 rows total, although only 2 items on the last row)\n\t\t\tlet lastItemInPreviousColumnIndex = firstItemInPreviousColumnIndex + (rows - 1) * this._rowSize; // multiply rows by columns, and add the column's first item's index\n\t\t\tif (lastItemInPreviousColumnIndex > itemsLength - 1) { // for incomplete rows, use the previous row's last item, as for them the last item is missing\n\t\t\t\tlastItemInPreviousColumnIndex -= this._rowSize;\n\t\t\t}\n\t\t\tthis._currentIndex = lastItemInPreviousColumnIndex;\n\t\t} else { // not cyclic, so just go to the first item\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleDown() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex + this._rowSize < itemsLength) { // no border reached, just increase the index by a row\n\t\t\tthis._currentIndex += this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **first** item in the **next** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize; // find the first item in the current column first\n\t\t\tconst firstItemInNextColumnIndex = (firstItemInThisColumnIndex + 1) % this._rowSize; // to get the first item in the next column, just increase the index by 1. The modulo by rows is for the case when we are at the last column\n\t\t\tthis._currentIndex = firstItemInNextColumnIndex;\n\t\t} else { // not cyclic, so just go to the last item\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleLeft() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex > 0) {\n\t\t\tthis._currentIndex -= 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleRight() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex < itemsLength - 1) {\n\t\t\tthis._currentIndex += 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleHome() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex -= this._currentIndex % homeEndRange;\n\t}\n\n\t_handleEnd() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex += (homeEndRange - 1 - this._currentIndex % homeEndRange); // eslint-disable-line\n\t}\n\n\t_applyTabIndex() {\n\t\tconst items = this._getItems();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\titems[i]._tabIndex = i === this._currentIndex ? \"0\" : \"-1\";\n\t\t}\n\n\t\tthis._affectedPropertiesNames.forEach(propName => {\n\t\t\tconst prop = this.rootWebComponent[propName];\n\t\t\tthis.rootWebComponent[propName] = Array.isArray(prop) ? [...prop] : { ...prop };\n\t\t});\n\t}\n\n\t_focusCurrentItem() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tif (currentItem) {\n\t\t\tcurrentItem.focus();\n\t\t}\n\t}\n\n\t_canNavigate() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tconst activeElement = getActiveElement();\n\n\t\treturn currentItem && currentItem === activeElement;\n\t}\n\n\t_getCurrentItem() {\n\t\tconst items = this._getItems();\n\n\t\tif (!items.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// normalize the index\n\t\twhile (this._currentIndex >= items.length) {\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t}\n\n\t\tif (this._currentIndex < 0) {\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\n\t\tconst currentItem = items[this._currentIndex];\n\n\t\tif (!currentItem) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (currentItem.isUI5Element) {\n\t\t\treturn currentItem.getFocusDomRef();\n\t\t}\n\n\t\tif (!this.rootWebComponent.getDomRef()) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.rootWebComponent.getDomRef().querySelector(`#${currentItem.id}`);\n\t}\n}\n\nexport default ItemNavigation;\n"]},"metadata":{},"sourceType":"module"}