{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction useRect(nodeRef, initialRect) {\n  if (initialRect === void 0) {\n    initialRect = {\n      width: 0,\n      height: 0\n    };\n  }\n\n  var _React$useState = React.useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var _React$useReducer = React.useReducer(rectReducer, initialRect),\n      rect = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n\n      var _rect = element.getBoundingClientRect();\n\n      dispatch({\n        rect: _rect\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    if (!element) {\n      return;\n    }\n\n    var observer = observeRect(element, function (rect) {\n      dispatch({\n        rect: rect\n      });\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\n\nfunction rectReducer(state, action) {\n  var rect = action.rect;\n\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect;\n  }\n\n  return state;\n}\n\nvar defaultEstimateSize = function defaultEstimateSize() {\n  return 50;\n};\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\n\nvar defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n  var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n  return el[key];\n};\n\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.start - range.overscan, 0);\n  var end = Math.min(range.end + range.overscan, range.size - 1);\n  var arr = [];\n\n  for (var i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nvar useElementScroll = function useElementScroll(_ref) {\n  var parentRef = _ref.parentRef,\n      horizontal = _ref.horizontal,\n      useObserver = _ref.useObserver,\n      initialRect = _ref.initialRect;\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n\n  var _React$useState = React.useState(0),\n      scrollOffset = _React$useState[0],\n      setScrollOffset = _React$useState[1];\n\n  var _React$useState2 = React.useState(parentRef.current),\n      element = _React$useState2[0],\n      setElement = _React$useState2[1];\n\n  useIsomorphicLayoutEffect(function () {\n    setElement(parentRef.current);\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      setScrollOffset(0);\n      return;\n    }\n\n    var onScroll = function onScroll() {\n      setScrollOffset(element[scrollKey]);\n    };\n\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey]);\n  var scrollToFn = React.useCallback(function (offset) {\n    if (parentRef.current) {\n      parentRef.current[scrollKey] = offset;\n    }\n  }, [parentRef, scrollKey]);\n  var useMeasureParent = useObserver || useRect;\n  var sizeKey = horizontal ? 'width' : 'height';\n\n  var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n      outerSize = _useMeasureParent[sizeKey];\n\n  return {\n    outerSize: outerSize,\n    scrollOffset: scrollOffset,\n    scrollToFn: scrollToFn\n  };\n};\n\nvar useWindowRect = function useWindowRect(windowRef, initialRect) {\n  if (initialRect === void 0) {\n    initialRect = {\n      width: 0,\n      height: 0\n    };\n  }\n\n  var _React$useState3 = React.useState(initialRect),\n      rect = _React$useState3[0],\n      setRect = _React$useState3[1];\n\n  var _React$useState4 = React.useState(windowRef.current),\n      element = _React$useState4[0],\n      setElement = _React$useState4[1];\n\n  useIsomorphicLayoutEffect(function () {\n    setElement(windowRef.current);\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      return;\n    }\n\n    function resizeHandler() {\n      var next = {\n        width: element.innerWidth,\n        height: element.innerHeight\n      };\n      setRect(function (prev) {\n        return prev.height !== next.height || prev.width !== next.width ? next : prev;\n      });\n    }\n\n    resizeHandler();\n    element.addEventListener('resize', resizeHandler);\n    return function () {\n      element.removeEventListener('resize', resizeHandler);\n    };\n  }, [element]);\n  return rect;\n};\n\nvar useWindowScroll = function useWindowScroll(_ref2) {\n  var windowRef = _ref2.windowRef,\n      parentRef = _ref2.parentRef,\n      horizontal = _ref2.horizontal,\n      useWindowObserver = _ref2.useWindowObserver,\n      initialRect = _ref2.initialRect;\n\n  var _React$useState5 = React.useState(0),\n      scrollOffset = _React$useState5[0],\n      setScrollOffset = _React$useState5[1];\n\n  var _React$useState6 = React.useState(windowRef.current),\n      element = _React$useState6[0],\n      setElement = _React$useState6[1];\n\n  var parentOffsetRef = React.useRef(0);\n  var rectKey = horizontal ? 'left' : 'top';\n  var scrollKey = horizontal ? 'scrollX' : 'scrollY';\n  useIsomorphicLayoutEffect(function () {\n    setElement(windowRef.current);\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      parentOffsetRef.current = 0;\n      setScrollOffset(0);\n      return;\n    }\n\n    if (parentRef.current) {\n      parentOffsetRef.current = element[scrollKey] + parentRef.current.getBoundingClientRect()[rectKey];\n    }\n\n    var onScroll = function onScroll() {\n      var offset = element[scrollKey] - parentOffsetRef.current;\n      setScrollOffset(offset);\n    };\n\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey, rectKey, parentRef]);\n  var scrollToFn = React.useCallback(function (offset, reason) {\n    if (windowRef.current) {\n      var _windowRef$current$sc;\n\n      var delta = ['ToIndex', 'SizeChanged'].includes(reason) ? parentOffsetRef.current : 0;\n      windowRef.current.scrollTo((_windowRef$current$sc = {}, _windowRef$current$sc[rectKey] = offset + delta, _windowRef$current$sc));\n    }\n  }, [windowRef, rectKey]);\n  var useMeasureParent = useWindowObserver || useWindowRect;\n  var sizeKey = horizontal ? 'width' : 'height';\n\n  var _useMeasureParent2 = useMeasureParent(windowRef, initialRect),\n      outerSize = _useMeasureParent2[sizeKey];\n\n  return {\n    outerSize: outerSize,\n    scrollOffset: scrollOffset,\n    scrollToFn: scrollToFn\n  };\n};\n\nvar useDefaultScroll = function useDefaultScroll(props) {\n  var parentRef = props.parentRef,\n      windowRef = props.windowRef;\n  var useWindow = windowRef !== undefined;\n  var emptyRef = React.useRef(null);\n  var elementRes = useElementScroll(_extends(_extends({}, props), {}, {\n    parentRef: useWindow ? emptyRef : parentRef\n  }));\n  var windowRes = useWindowScroll(_extends(_extends({}, props), {}, {\n    windowRef: useWindow ? windowRef : emptyRef\n  }));\n  return useWindow ? windowRes : elementRes;\n};\n\nfunction useVirtual(_ref3) {\n  var _measurements;\n\n  var _ref3$size = _ref3.size,\n      size = _ref3$size === void 0 ? 0 : _ref3$size,\n      _ref3$estimateSize = _ref3.estimateSize,\n      estimateSize = _ref3$estimateSize === void 0 ? defaultEstimateSize : _ref3$estimateSize,\n      _ref3$overscan = _ref3.overscan,\n      overscan = _ref3$overscan === void 0 ? 1 : _ref3$overscan,\n      _ref3$paddingStart = _ref3.paddingStart,\n      paddingStart = _ref3$paddingStart === void 0 ? 0 : _ref3$paddingStart,\n      _ref3$paddingEnd = _ref3.paddingEnd,\n      paddingEnd = _ref3$paddingEnd === void 0 ? 0 : _ref3$paddingEnd,\n      parentRef = _ref3.parentRef,\n      windowRef = _ref3.windowRef,\n      horizontal = _ref3.horizontal,\n      scrollToFn = _ref3.scrollToFn,\n      useObserver = _ref3.useObserver,\n      useWindowObserver = _ref3.useWindowObserver,\n      initialRect = _ref3.initialRect,\n      _ref3$keyExtractor = _ref3.keyExtractor,\n      keyExtractor = _ref3$keyExtractor === void 0 ? defaultKeyExtractor : _ref3$keyExtractor,\n      _ref3$measureSize = _ref3.measureSize,\n      measureSize = _ref3$measureSize === void 0 ? defaultMeasureSize : _ref3$measureSize,\n      _ref3$rangeExtractor = _ref3.rangeExtractor,\n      rangeExtractor = _ref3$rangeExtractor === void 0 ? defaultRangeExtractor : _ref3$rangeExtractor,\n      _ref3$useScroll = _ref3.useScroll,\n      useScroll = _ref3$useScroll === void 0 ? useDefaultScroll : _ref3$useScroll;\n  var latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: []\n  });\n\n  var _useScroll = useScroll({\n    windowRef: windowRef,\n    parentRef: parentRef,\n    horizontal: horizontal,\n    useObserver: useObserver,\n    useWindowObserver: useWindowObserver,\n    initialRect: initialRect\n  }),\n      outerSize = _useScroll.outerSize,\n      scrollOffset = _useScroll.scrollOffset,\n      defaultScrollToFn = _useScroll.scrollToFn;\n\n  var scrollOffsetWithAdjustmentsRef = React.useRef(scrollOffset);\n\n  if (latestRef.current.scrollOffset !== scrollOffset) {\n    scrollOffsetWithAdjustmentsRef.current = scrollOffset;\n  }\n\n  latestRef.current.outerSize = outerSize;\n  latestRef.current.scrollOffset = scrollOffset;\n  var scrollTo = React.useCallback(function (offset, reason) {\n    var resolvedScrollToFn = scrollToFn || function (offset) {\n      return defaultScrollToFn(offset, reason);\n    };\n\n    resolvedScrollToFn(offset, defaultScrollToFn);\n  }, [scrollToFn, defaultScrollToFn]);\n\n  var _React$useState7 = React.useState({}),\n      measuredCache = _React$useState7[0],\n      setMeasuredCache = _React$useState7[1];\n\n  var measure = React.useCallback(function () {\n    return setMeasuredCache({});\n  }, []);\n  var pendingMeasuredCacheIndexesRef = React.useRef([]);\n  var measurements = React.useMemo(function () {\n    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n    pendingMeasuredCacheIndexesRef.current = [];\n    var measurements = latestRef.current.measurements.slice(0, min);\n\n    for (var i = min; i < size; i++) {\n      var key = keyExtractor(i);\n      var measuredSize = measuredCache[key];\n\n      var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n\n      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n\n      var _end = _start + _size;\n\n      measurements[i] = {\n        index: i,\n        start: _start,\n        size: _size,\n        end: _end,\n        key: key\n      };\n    }\n\n    return measurements;\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || 0) + paddingEnd;\n  latestRef.current.measurements = measurements;\n  latestRef.current.totalSize = totalSize;\n\n  var _calculateRange = calculateRange(latestRef.current),\n      start = _calculateRange.start,\n      end = _calculateRange.end;\n\n  var indexes = React.useMemo(function () {\n    return rangeExtractor({\n      start: start,\n      end: end,\n      overscan: overscan,\n      size: measurements.length\n    });\n  }, [start, end, overscan, measurements.length, rangeExtractor]);\n  var measureSizeRef = React.useRef(measureSize);\n  measureSizeRef.current = measureSize;\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n\n    var _loop = function _loop(k, len) {\n      var i = indexes[k];\n      var measurement = measurements[i];\n\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          if (el) {\n            var measuredSize = measureSizeRef.current(el, horizontal);\n\n            if (measuredSize !== item.size) {\n              var _scrollOffset = latestRef.current.scrollOffset;\n\n              if (item.start < _scrollOffset) {\n                var delta = measuredSize - item.size;\n                scrollOffsetWithAdjustmentsRef.current += delta;\n                defaultScrollToFn(scrollOffsetWithAdjustmentsRef.current, 'SizeChanged');\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i);\n              setMeasuredCache(function (old) {\n                var _extends2;\n\n                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n              });\n            }\n          }\n        }\n      });\n\n      virtualItems.push(item);\n    };\n\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      _loop(k);\n    }\n\n    return virtualItems;\n  }, [indexes, defaultScrollToFn, horizontal, measurements]);\n  var mountedRef = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      setMeasuredCache({});\n    }\n\n    mountedRef.current = true;\n  }, [estimateSize]);\n  var scrollToOffset = React.useCallback(function (toOffset, _temp, reason) {\n    var _ref4 = _temp === void 0 ? {} : _temp,\n        _ref4$align = _ref4.align,\n        align = _ref4$align === void 0 ? 'start' : _ref4$align;\n\n    if (reason === void 0) {\n      reason = 'ToOffset';\n    }\n\n    var _latestRef$current = latestRef.current,\n        scrollOffset = _latestRef$current.scrollOffset,\n        outerSize = _latestRef$current.outerSize;\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start';\n      } else if (toOffset >= scrollOffset + outerSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n\n    if (align === 'start') {\n      scrollTo(toOffset, reason);\n    } else if (align === 'end') {\n      scrollTo(toOffset - outerSize, reason);\n    } else if (align === 'center') {\n      scrollTo(toOffset - outerSize / 2, reason);\n    }\n  }, [scrollTo]);\n  var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref5 = _temp2 === void 0 ? {} : _temp2,\n        _ref5$align = _ref5.align,\n        align = _ref5$align === void 0 ? 'auto' : _ref5$align,\n        rest = _objectWithoutPropertiesLoose(_ref5, [\"align\"]);\n\n    var _latestRef$current2 = latestRef.current,\n        measurements = _latestRef$current2.measurements,\n        scrollOffset = _latestRef$current2.scrollOffset,\n        outerSize = _latestRef$current2.outerSize;\n    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n\n    if (!measurement) {\n      return;\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffset + outerSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n\n    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(toOffset, _extends({\n      align: align\n    }, rest), 'ToIndex');\n  }, [scrollToOffset, size]);\n  var scrollToIndex = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    } // We do a double request here because of\n    // dynamic sizes which can cause offset shift\n    // and end up in the wrong spot. Unfortunately,\n    // we can't know about those dynamic sizes until\n    // we try and render them. So double down!\n\n\n    tryScrollToIndex.apply(void 0, args);\n    requestAnimationFrame(function () {\n      tryScrollToIndex.apply(void 0, args);\n    });\n  }, [tryScrollToIndex]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex,\n    measure: measure\n  };\n}\n\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref6) {\n  var measurements = _ref6.measurements,\n      outerSize = _ref6.outerSize,\n      scrollOffset = _ref6.scrollOffset;\n  var size = measurements.length - 1;\n\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n\n  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n  var end = start;\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexport { defaultRangeExtractor, useDefaultScroll, useElementScroll, useVirtual, useWindowScroll };","map":{"version":3,"sources":["../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useIsomorphicLayoutEffect.js","../src/useRect.js","../src/index.js"],"names":["props","rectChanged","b","observedNodes","run","changedStates","newRect","node","state","rafId","window","observeRect","cb","observe","wasEmpty","rect","hasRectChanged","callbacks","unobserve","index","cancelAnimationFrame","React","initialRect","width","height","element","setElement","nodeRef","dispatch","initialRectSet","useIsomorphicLayoutEffect","observer","action","defaultEstimateSize","defaultKeyExtractor","defaultMeasureSize","key","horizontal","el","defaultRangeExtractor","start","Math","range","end","arr","i","useElementScroll","parentRef","useObserver","scrollKey","scrollOffset","setScrollOffset","onScroll","capture","passive","scrollToFn","useMeasureParent","sizeKey","outerSize","useWindowRect","setRect","windowRef","next","innerHeight","prev","resizeHandler","useWindowScroll","useWindowObserver","parentOffsetRef","rectKey","offset","delta","useDefaultScroll","useWindow","emptyRef","elementRes","windowRes","size","estimateSize","overscan","paddingStart","paddingEnd","keyExtractor","measureSize","rangeExtractor","useScroll","latestRef","measurements","defaultScrollToFn","scrollOffsetWithAdjustmentsRef","scrollTo","resolvedScrollToFn","measuredCache","setMeasuredCache","measure","pendingMeasuredCacheIndexesRef","min","measuredSize","totalSize","calculateRange","indexes","length","measureSizeRef","virtualItems","k","len","measurement","item","measureRef","mountedRef","scrollToOffset","align","reason","toOffset","tryScrollToIndex","rest","scrollToIndex","args","requestAnimationFrame","findNearestBinarySearch","low","middle","currentValue","getCurrentValue","high","getOffset"],"mappings":"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","sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(\n  nodeRef,\n  initialRect = { width: 0, height: 0 }\n) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n","import React from 'react'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const useElementScroll = ({\n  parentRef,\n  horizontal,\n  useObserver,\n  initialRect,\n}) => {\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  const [element, setElement] = React.useState(parentRef.current)\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(parentRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = () => {\n      setScrollOffset(element[scrollKey])\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const scrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const useMeasureParent = useObserver || useRect\n\n  const sizeKey = horizontal ? 'width' : 'height'\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  return {\n    outerSize,\n    scrollOffset,\n    scrollToFn,\n  }\n}\n\nconst useWindowRect = (windowRef, initialRect = { width: 0, height: 0 }) => {\n  const [rect, setRect] = React.useState(initialRect)\n  const [element, setElement] = React.useState(windowRef.current)\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(windowRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return\n    }\n\n    function resizeHandler() {\n      const next = {\n        width: element.innerWidth,\n        height: element.innerHeight,\n      }\n\n      setRect(prev =>\n        prev.height !== next.height || prev.width !== next.width ? next : prev\n      )\n    }\n    resizeHandler()\n\n    element.addEventListener('resize', resizeHandler)\n\n    return () => {\n      element.removeEventListener('resize', resizeHandler)\n    }\n  }, [element])\n\n  return rect\n}\n\nexport const useWindowScroll = ({\n  windowRef,\n  parentRef,\n  horizontal,\n  useWindowObserver,\n  initialRect,\n}) => {\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  const [element, setElement] = React.useState(windowRef.current)\n\n  const parentOffsetRef = React.useRef(0)\n\n  const rectKey = horizontal ? 'left' : 'top'\n  const scrollKey = horizontal ? 'scrollX' : 'scrollY'\n\n  useIsomorphicLayoutEffect(() => {\n    setElement(windowRef.current)\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      parentOffsetRef.current = 0\n      setScrollOffset(0)\n\n      return\n    }\n\n    if (parentRef.current) {\n      parentOffsetRef.current =\n        element[scrollKey] + parentRef.current.getBoundingClientRect()[rectKey]\n    }\n\n    const onScroll = () => {\n      const offset = element[scrollKey] - parentOffsetRef.current\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, rectKey, parentRef])\n\n  const scrollToFn = React.useCallback(\n    (offset, reason) => {\n      if (windowRef.current) {\n        const delta = ['ToIndex', 'SizeChanged'].includes(reason)\n          ? parentOffsetRef.current\n          : 0\n\n        windowRef.current.scrollTo({ [rectKey]: offset + delta })\n      }\n    },\n    [windowRef, rectKey]\n  )\n\n  const useMeasureParent = useWindowObserver || useWindowRect\n\n  const sizeKey = horizontal ? 'width' : 'height'\n\n  const { [sizeKey]: outerSize } = useMeasureParent(windowRef, initialRect)\n\n  return {\n    outerSize,\n    scrollOffset,\n    scrollToFn,\n  }\n}\n\nexport const useDefaultScroll = props => {\n  const { parentRef, windowRef } = props\n\n  const useWindow = windowRef !== undefined\n\n  const emptyRef = React.useRef(null)\n\n  const elementRes = useElementScroll({\n    ...props,\n    parentRef: useWindow ? emptyRef : parentRef,\n  })\n\n  const windowRes = useWindowScroll({\n    ...props,\n    windowRef: useWindow ? windowRef : emptyRef,\n  })\n\n  return useWindow ? windowRes : elementRes\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  windowRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  useWindowObserver,\n  initialRect,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n  useScroll = useDefaultScroll,\n}) {\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n\n  const { outerSize, scrollOffset, scrollToFn: defaultScrollToFn } = useScroll({\n    windowRef,\n    parentRef,\n    horizontal,\n    useObserver,\n    useWindowObserver,\n    initialRect,\n  })\n\n  const scrollOffsetWithAdjustmentsRef = React.useRef(scrollOffset)\n  if (latestRef.current.scrollOffset !== scrollOffset) {\n    scrollOffsetWithAdjustmentsRef.current = scrollOffset\n  }\n\n  latestRef.current.outerSize = outerSize\n  latestRef.current.scrollOffset = scrollOffset\n\n  const scrollTo = React.useCallback(\n    (offset, reason) => {\n      const resolvedScrollToFn =\n        scrollToFn || (offset => defaultScrollToFn(offset, reason))\n\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [scrollToFn, defaultScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor]\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                const delta = measuredSize - item.size\n                scrollOffsetWithAdjustmentsRef.current += delta\n\n                defaultScrollToFn(\n                  scrollOffsetWithAdjustmentsRef.current,\n                  'SizeChanged'\n                )\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}, reason = 'ToOffset') => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollTo(toOffset, reason)\n      } else if (align === 'end') {\n        scrollTo(toOffset - outerSize, reason)\n      } else if (align === 'center') {\n        scrollTo(toOffset - outerSize / 2, reason)\n      }\n    },\n    [scrollTo]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest }, 'ToIndex')\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"]},"metadata":{},"sourceType":"module"}