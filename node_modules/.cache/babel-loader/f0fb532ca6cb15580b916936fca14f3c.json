{"ast":null,"code":"import _regeneratorRuntime from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape, isHome, isEnd } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\"; // Texts\n\nimport { RANGE_SLIDER_ARIA_DESCRIPTION, RANGE_SLIDER_START_HANDLE_DESCRIPTION, RANGE_SLIDER_END_HANDLE_DESCRIPTION } from \"./generated/i18n/i18n-defaults.js\";\n/**\n * @public\n */\n\nvar metadata = {\n  tag: \"ui5-range-slider\",\n  languageAware: true,\n  managedSlots: true,\n  properties:\n  /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */\n  {\n    /**\n     * Defines start point of a selection - position of a first handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    startValue: {\n      type: Float,\n      defaultValue: 0\n    },\n\n    /**\n     * Defines end point of a selection - position of a second handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    endValue: {\n      type: Float,\n      defaultValue: 100\n    }\n  }\n};\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\n\nvar RangeSlider = /*#__PURE__*/function (_SliderBase) {\n  _inherits(RangeSlider, _SliderBase);\n\n  var _super = _createSuper(RangeSlider);\n\n  function RangeSlider() {\n    var _this;\n\n    _classCallCheck(this, RangeSlider);\n\n    _this = _super.call(this);\n    _this._stateStorage.startValue = null;\n    _this._stateStorage.endValue = null;\n    return _this;\n  }\n\n  _createClass(RangeSlider, [{\n    key: \"tooltipStartValue\",\n    get: function get() {\n      var stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\n      return this.startValue.toFixed(stepPrecision);\n    }\n  }, {\n    key: \"tooltipEndValue\",\n    get: function get() {\n      var stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\n      return this.endValue.toFixed(stepPrecision);\n    }\n  }, {\n    key: \"_ariaDisabled\",\n    get: function get() {\n      return this.disabled || undefined;\n    }\n  }, {\n    key: \"_ariaLabelledByText\",\n    get: function get() {\n      return RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n    }\n  }, {\n    key: \"_ariaHandlesText\",\n    get: function get() {\n      var isRTL = this.effectiveDir === \"rtl\";\n\n      var isReversed = this._areValuesReversed();\n\n      var ariaHandlesText = {};\n\n      if (isRTL && !isReversed || !isRTL && isReversed) {\n        ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n        ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n      } else {\n        ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n        ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n      }\n\n      return ariaHandlesText;\n    }\n    /**\n     * Check if the previously saved state is outdated. That would mean\n     * either it is the initial rendering or that a property has been changed\n     * programatically - because the previous state is always updated in\n     * the interaction handlers.\n     *\n     * Normalize current properties, update the previously stored state.\n     * Update the visual UI representation of the Slider.\n     *\n     */\n\n  }, {\n    key: \"onBeforeRendering\",\n    value: function onBeforeRendering() {\n      if (!this.isCurrentStateOutdated()) {\n        return;\n      }\n\n      this.notResized = true;\n      this.syncUIAndState(\"startValue\", \"endValue\");\n\n      this._updateHandlesAndRange(null);\n    }\n  }, {\n    key: \"_onfocusin\",\n    value: function _onfocusin(event) {\n      // If this is the initial focusin of the component save its initial\n      // value properties so they could be restored on ESC key press\n      if (!this._getInitialValue(\"endValue\")) {\n        this._setInitialValue(\"startValue\", this.startValue);\n\n        this._setInitialValue(\"endValue\", this.endValue);\n      }\n\n      if (this.showTooltip) {\n        this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n      }\n    }\n    /**\n     * Handles focus out event of the focusable components inner elements.\n     * Prevent focusout when the focus is getting initially set within the slider before the\n     * slider customElement itself is finished focusing.\n     *\n     * Prevents the focus from leaving the Range Slider when the focus is managed between\n     * its inner elements in result of user interactions.\n     *\n     * Resets the stored Range Slider's initial values saved when it was first focused\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onfocusout\",\n    value: function _onfocusout(event) {\n      if (this._isFocusing()) {\n        this._preventFocusOut();\n\n        return;\n      }\n\n      this._setAffectedValue(null);\n\n      this._setInitialValue(\"startValue\", null);\n\n      this._setInitialValue(\"endValue\", null);\n\n      if (this.showTooltip) {\n        this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n      }\n    }\n    /**\n    * Handles keyup logic. If one of the handles came across the other\n    * swap the start and end values. Reset the affected value by the finished\n    * user interaction.\n    *\n    * @private\n    */\n\n  }, {\n    key: \"_onkeyup\",\n    value: function _onkeyup(event) {\n      _get(_getPrototypeOf(RangeSlider.prototype), \"_onkeyup\", this).call(this, event);\n\n      this._swapValues();\n\n      this._setAffectedValue(null);\n    }\n  }, {\n    key: \"_handleActionKeyPress\",\n    value: function _handleActionKeyPress(event) {\n      if (isEscape(event)) {\n        this.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n        return;\n      } // Set the target of the interaction based on the focused inner element\n\n\n      this._setAffectedValueByFocusedElement();\n\n      var min = this._effectiveMin;\n      var max = this._effectiveMax;\n      var affectedValue = this._valueAffected; // If home/end key is pressed and no single handle is focused the active element\n      // is the range selection - update both start and end values. Otherwise, if 'home'\n      // is pressed the 'startValue'will be used for the start-handle offset calculation,\n      // if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\n      if ((isEnd(event) || isHome(event)) && !affectedValue) {\n        this._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n\n        return;\n      } // Calculate how much the value should be increased/decreased based on the action key\n\n\n      var newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n      if (!newValueOffset) {\n        return;\n      } // Update a single value if one of the handles is focused or the range if not already at min or max\n\n\n      if (affectedValue && !this._isPressInCurrentRange) {\n        var newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n        this.update(affectedValue, newValue, null);\n      } else if (newValueOffset < 0 && this.startValue > min || newValueOffset > 0 && this.endValue < max) {\n        var newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n        var newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n        this.update(affectedValue, newStartValue, newEndValue);\n      }\n    }\n    /**\n     * Determines affected value (start/end) depending on the currently\n     * active inner element within the Range Slider - used in the keyboard handling.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setAffectedValueByFocusedElement\",\n    value: function _setAffectedValueByFocusedElement() {\n      if (this.shadowRoot.activeElement === this._startHandle) {\n        this._setAffectedValue(RangeSlider.VALUES.start);\n      }\n\n      if (this.shadowRoot.activeElement === this._endHandle) {\n        this._setAffectedValue(RangeSlider.VALUES.end);\n      }\n\n      if (this.shadowRoot.activeElement === this._progressBar) {\n        this._setAffectedValue(null);\n      }\n\n      this._setIsPressInCurrentRange(!this._valueAffected);\n    }\n    /**\n     * Calculates the start and end values when the 'Home\" or 'End' keys\n     * are pressed on the selected range bar.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_homeEndForSelectedRange\",\n    value: function _homeEndForSelectedRange(event, affectedValue, min, max) {\n      var newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n      var newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n      var newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n      this.update(null, newStartValue, newEndValue);\n    }\n    /**\n     * Update values, stored inner state and the visual UI representation of the component.\n     * If no specific type of value property is passed - the range is selected - update both handles,\n     * otherwise update the handle corresponding to the affected by the user interacton value prop.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(affectedValue, startValue, endValue) {\n      if (!affectedValue) {\n        this.updateValue(\"startValue\", startValue);\n        this.updateValue(\"endValue\", endValue);\n\n        this._updateHandlesAndRange(null);\n      } else {\n        var newValue = startValue;\n\n        this._updateHandlesAndRange(newValue);\n\n        this.updateValue(affectedValue, newValue);\n      }\n    }\n    /**\n     * Called when the user starts interacting with the slider\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onmousedown\",\n    value: function _onmousedown(event) {\n      // If step is 0 no interaction is available because there is no constant\n      // (equal for all user environments) quantitative representation of the value\n      if (this.disabled || this._effectiveStep === 0) {\n        return;\n      } // Calculate the new value from the press position of the event\n\n\n      var newValue = this.handleDownBase(event); // Determine the rest of the needed details from the start of the interaction.\n\n      this._saveInteractionStartData(event, newValue); // Do not yet update the RangeSlider if press is in range or over a handle.\n\n\n      if (this._isPressInCurrentRange || this._handeIsPressed) {\n        this._handeIsPressed = false;\n        return;\n      } // Update Slider UI and internal state\n\n\n      this.update(this._valueAffected, newValue, null);\n    }\n    /**\n     * Determines and saves needed values from the start of the interaction:\n     *\n     * Is the value calculated is within the currently selected range;\n     * Initial pageX position of the start handle affected by the interaction;\n     * Initial pageX value of the pressed postion;\n     * Affected value property by the action;\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_saveInteractionStartData\",\n    value: function _saveInteractionStartData(event, newValue) {\n      var progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect(); // Save the state of the value properties on the start of the interaction\n\n      this._startValueAtBeginningOfAction = this.startValue;\n      this._endValueAtBeginningOfAction = this.endValue; // Save the initial press point coordinates (position)\n\n      this._initialPageXPosition = this.constructor.getPageXValueFromEvent(event); // Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\n      this._pressTargetAndAffectedValue(this._initialPageXPosition, newValue); // Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\n\n      this._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n    }\n    /**\n     * Called when the user moves the slider\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_handleMove\",\n    value: function _handleMove(event) {\n      event.preventDefault(); // If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\n      if (this.disabled || this._effectiveStep === 0) {\n        return;\n      } // Update UI and state when dragging a single Range Slider handle\n\n\n      if (!this._isPressInCurrentRange) {\n        this._updateValueOnHandleDrag(event);\n\n        return;\n      } // Updates UI and state when dragging of the whole selected range\n\n\n      this._updateValueOnRangeDrag(event);\n    }\n    /**\n     * Updates UI and state when dragging a single Range Slider handle\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateValueOnHandleDrag\",\n    value: function _updateValueOnHandleDrag(event) {\n      var newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n      this.update(this._valueAffected, newValue, null);\n    }\n    /**\n     * Updates UI and state when dragging of the whole selected range\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateValueOnRangeDrag\",\n    value: function _updateValueOnRangeDrag(event) {\n      // Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n      var currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\n      var newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX); // No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\n\n      this._setAffectedValue(null); // Update the UI and the state acccording to the calculated new values\n\n\n      this.update(null, newValues[0], newValues[1]);\n    }\n  }, {\n    key: \"_handleUp\",\n    value: function _handleUp() {\n      if (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n        this.fireEvent(\"change\");\n      }\n\n      this._swapValues();\n\n      this._setAffectedValueByFocusedElement();\n\n      this._setAffectedValue(null);\n\n      this._startValueAtBeginningOfAction = null;\n      this._endValueAtBeginningOfAction = null;\n\n      this._setIsPressInCurrentRange(false);\n\n      this.handleUpBase();\n    }\n    /**\n     * Determines where the press occured and which values of the Range Slider\n     * handles should be updated on further interaction.\n     *\n     * If the press is not in the selected range or over one of the Range Slider handles\n     * determines which one from the value/endValue properties has to be updated\n     * after the user action (based on closest handle).\n     *\n     * Set flags if the press is over a handle or in the selected range,\n     * in such cases no values are changed on interaction start, but could be\n     * updated later when dragging.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_pressTargetAndAffectedValue\",\n    value: function _pressTargetAndAffectedValue(clientX, value) {\n      var startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n      var endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\"); // Check if the press point is in the bounds of any of the Range Slider handles\n\n      var handleStartDomRect = startHandle.getBoundingClientRect();\n      var handleEndDomRect = endHandle.getBoundingClientRect();\n      var inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n      var inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right; // Remove the flag for value in current range if the press action is over one of the handles\n\n      if (inHandleEndDom || inHandleStartDom) {\n        this._handeIsPressed = true;\n      } // Return that handle that is closer to the press point\n\n\n      if (inHandleEndDom || value > this.endValue) {\n        this._setAffectedValue(RangeSlider.VALUES.end);\n      } // If one of the handle is pressed return that one\n\n\n      if (inHandleStartDom || value < this.startValue) {\n        this._setAffectedValue(RangeSlider.VALUES.start);\n      } // Flag if press is in the current select range\n\n\n      var isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\n      this._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n    }\n    /**\n     * Sets the value property (start/end) that will get updated\n     * by a user action depending on that user action's characteristics\n     * - mouse press position - cursor coordinates relative to the start/end handles\n     * - selected inner element via a keyboard navigation\n     *\n     * @param {String} valuePropAffectedByInteraction The value that will get modified by the interaction\n     * @private\n     */\n\n  }, {\n    key: \"_setAffectedValue\",\n    value: function _setAffectedValue(valuePropAffectedByInteraction) {\n      this._valueAffected = valuePropAffectedByInteraction; // If the values have been swapped reset the reversed flag\n\n      if (this._areValuesReversed()) {\n        this._setValuesAreReversed();\n      }\n    }\n    /**\n     * Flag if press action is made on the currently selected range of values\n     *\n     * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n     * @private\n     */\n\n  }, {\n    key: \"_setIsPressInCurrentRange\",\n    value: function _setIsPressInCurrentRange(isPressInCurrentRange) {\n      this._isPressInCurrentRange = isPressInCurrentRange;\n    }\n    /**\n     * Manage the focus between the focusable inner elements within the component.\n     *\n     * On initial focusin or if the whole range is affected by the user interaction\n     * set the focus on the progress selection, otherwise on one of the Range Slider\n     * handles based on the determined affected value by the user action.\n     *\n     * If one of the handles came across the other one in result of a user action\n     * switch the focus between them to keep it visually consistent.\n     *\n     * Note:\n     * In some cases this function is going to get called twice on one user action.\n     *\n     * 1. When the focus is initially set to an inner element it is done in the very beginning,\n     * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n     * is still not being received, causining an immediate focusout that we prevent by\n     * calling this function once again.\n     *\n     * 2. When the focused is manually switched from one inner element to another.\n     * The focusout handler is one and the same for all focusable parts within the\n     * Range Slider and when is called it checks if it should keep the focus within\n     * the component and which part of it should get focused if that is the case.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"focusInnerElement\",\n    value: function focusInnerElement() {\n      var isReversed = this._areValuesReversed();\n\n      var affectedValue = this._valueAffected;\n\n      if (this._isPressInCurrentRange || !affectedValue) {\n        this._progressBar.focus();\n      }\n\n      if (affectedValue === RangeSlider.VALUES.start && !isReversed || affectedValue === RangeSlider.VALUES.end && isReversed) {\n        this._startHandle.focus();\n      }\n\n      if (affectedValue === RangeSlider.VALUES.end && !isReversed || affectedValue === RangeSlider.VALUES.start && isReversed) {\n        this._endHandle.focus();\n      }\n    }\n    /**\n     * Calculates startValue/endValue properties when the whole range is moved.\n     *\n     * Uses the change of the position of the start handle and adds the initially\n     * selected range to it, to determine the whole range offset.\n     *\n     * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n     * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_calculateRangeOffset\",\n    value: function _calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n      // Return the current values if there is no difference in the\n      // possitions of the initial press and the current pointer\n      if (this._initialPageXPosition === currentPageXPos) {\n        return [this.startValue, this.endValue];\n      }\n\n      var min = this._effectiveMin;\n      var max = this._effectiveMax;\n      var selectedRange = this.endValue - this.startValue; // Computes the new value based on the difference of the current cursor location from the start of the interaction\n\n      var startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos); // When the end handle reaches the max possible value prevent the start handle from moving\n      // And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\n\n      startValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n      return [startValue, startValue + selectedRange];\n    }\n    /**\n     * Computes the new value based on the difference of the current cursor location from the\n     * start of the interaction.\n     *\n     * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n     * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_calculateStartValueByOffset\",\n    value: function _calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n      var min = this._effectiveMin;\n      var max = this._effectiveMax;\n      var step = this._effectiveStep;\n      var dom = this.getBoundingClientRect();\n      var startValue;\n      var startValuePageX;\n      var positionOffset;\n      /* Depending on the dragging direction:\n      - calculate the new position of the start handle from its old pageX value combined with the movement offset;\n      - calculate the start value based on its new pageX coordinates;\n      - 'stepify' the calculated value based on the specified step property; */\n\n      if (currentPageXPos > this._initialPageXPosition) {\n        // Difference between the new position of the pointer and when the press event initial occured\n        positionOffset = currentPageXPos - this._initialPageXPosition;\n        startValuePageX = initialStartHandlePageXPos + positionOffset;\n        startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n        startValue = this.constructor.getSteppedValue(startValue, step, min);\n      } else {\n        positionOffset = this._initialPageXPosition - currentPageXPos;\n        startValuePageX = initialStartHandlePageXPos - positionOffset;\n        startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n        startValue = this.constructor.getSteppedValue(startValue, step, min);\n      }\n\n      return startValue;\n    }\n    /**\n     * Updates the visual representation of the component by calculating\n     * the styles of the handles and the range selection based on the new state.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateHandlesAndRange\",\n    value: function _updateHandlesAndRange(newValue) {\n      var max = this._effectiveMax;\n      var min = this._effectiveMin;\n      var prevStartValue = this.getStoredPropertyState(\"startValue\");\n      var prevEndValue = this.getStoredPropertyState(\"endValue\");\n      var affectedValue = this._valueAffected; // The value according to which we update the UI can be either the startValue\n      // or the endValue property. It is determined in _getClosestHandle()\n      // depending on to which handle is closer the user interaction.\n\n      if (affectedValue === RangeSlider.VALUES.start) {\n        this._selectedRange = (prevEndValue - newValue) / (max - min);\n        this._firstHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n      } else if (affectedValue === RangeSlider.VALUES.end) {\n        this._selectedRange = (newValue - prevStartValue) / (max - min);\n        this._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n      } else {\n        // When both values are changed - UI sync or moving the whole selected range:\n        this._selectedRange = (this.endValue - this.startValue) / (max - min);\n        this._firstHandlePositionFromStart = (this.startValue - min) / (max - min) * 100;\n        this._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n      }\n    }\n    /**\n     * Swaps the start and end values of the handles if one came accros the other:\n     * - If the start value is greater than the endValue swap them and their handles\n     * - If the endValue become less than the start value swap them and their handles\n     *\n     * Switches the focus to the opposite of the currently focused handle.\n     *\n     * Note: Only the property values are reversed, the DOM elements of the handles\n     * corresponding to them are never switched.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_swapValues\",\n    value: function _swapValues() {\n      var affectedValue = this._valueAffected;\n\n      if (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n        var prevEndValue = this.endValue;\n        this.endValue = this.startValue;\n        this.startValue = prevEndValue;\n\n        this._setValuesAreReversed();\n\n        this.focusInnerElement();\n      }\n\n      if (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n        var prevStartValue = this.startValue;\n        this.startValue = this.endValue;\n        this.endValue = prevStartValue;\n\n        this._setValuesAreReversed();\n\n        this.focusInnerElement();\n      }\n    }\n    /**\n     * Flag that we have swapped the values of the 'start' and 'end' properties,\n     * to correctly switch the focus within the component from one handle to another\n     * when the swapping is finished. As we only swap property values and not\n     * the handle elements themselves, we must also swap their focus.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setValuesAreReversed\",\n    value: function _setValuesAreReversed() {\n      this._reversedValues = !this._reversedValues;\n    }\n  }, {\n    key: \"_areValuesReversed\",\n    value: function _areValuesReversed() {\n      return this._reversedValues;\n    }\n  }, {\n    key: \"_startHandle\",\n    get: function get() {\n      return this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n    }\n  }, {\n    key: \"_endHandle\",\n    get: function get() {\n      return this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n    }\n  }, {\n    key: \"_progressBar\",\n    get: function get() {\n      return this.shadowRoot.querySelector(\".ui5-slider-progress\");\n    }\n  }, {\n    key: \"styles\",\n    get: function get() {\n      return {\n        progress: _defineProperty({\n          \"width\": \"\".concat(this._selectedRange * 100, \"%\"),\n          \"transform-origin\": \"\".concat(this.directionStart, \" top\")\n        }, this.directionStart, \"\".concat(this._firstHandlePositionFromStart, \"%\")),\n        startHandle: _defineProperty({}, this.directionStart, \"\".concat(this._firstHandlePositionFromStart, \"%\")),\n        endHandle: _defineProperty({}, this.directionStart, \"\".concat(this._secondHandlePositionFromStart, \"%\")),\n        tickmarks: {\n          \"background\": \"\".concat(this._tickmarks)\n        },\n        label: {\n          \"width\": \"\".concat(this._labelWidth, \"%\")\n        },\n        labelContainer: _defineProperty({\n          \"width\": \"100%\"\n        }, this.directionStart, \"-\".concat(this._labelWidth / 2, \"%\")),\n        tooltip: {\n          \"visibility\": \"\".concat(this._tooltipVisibility)\n        }\n      };\n    }\n  }], [{\n    key: \"metadata\",\n    get: function get() {\n      return metadata;\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return RangeSliderTemplate;\n    }\n  }, {\n    key: \"VALUES\",\n    get: function get() {\n      return {\n        start: \"startValue\",\n        end: \"endValue\"\n      };\n    }\n  }, {\n    key: \"onDefine\",\n    value: function () {\n      var _onDefine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return getI18nBundle(\"@ui5/webcomponents\");\n\n              case 2:\n                RangeSlider.i18nBundle = _context.sent;\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function onDefine() {\n        return _onDefine.apply(this, arguments);\n      }\n\n      return onDefine;\n    }()\n  }]);\n\n  return RangeSlider;\n}(SliderBase);\n\nRangeSlider.define();\nexport default RangeSlider;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents/dist/RangeSlider.js"],"names":["Float","getI18nBundle","isEscape","isHome","isEnd","SliderBase","RangeSliderTemplate","RANGE_SLIDER_ARIA_DESCRIPTION","RANGE_SLIDER_START_HANDLE_DESCRIPTION","RANGE_SLIDER_END_HANDLE_DESCRIPTION","metadata","tag","languageAware","managedSlots","properties","startValue","type","defaultValue","endValue","RangeSlider","_stateStorage","stepPrecision","constructor","_getDecimalPrecisionOfNumber","_effectiveStep","toFixed","disabled","undefined","i18nBundle","getText","isRTL","effectiveDir","isReversed","_areValuesReversed","ariaHandlesText","startHandleText","endHandleText","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","event","_getInitialValue","_setInitialValue","showTooltip","_tooltipVisibility","TOOLTIP_VISIBILITY","VISIBLE","_isFocusing","_preventFocusOut","_setAffectedValue","HIDDEN","_swapValues","update","_setAffectedValueByFocusedElement","min","_effectiveMin","max","_effectiveMax","affectedValue","_valueAffected","_homeEndForSelectedRange","newValueOffset","_handleActionKeyPressBase","_isPressInCurrentRange","newValue","clipValue","newStartValue","newEndValue","shadowRoot","activeElement","_startHandle","VALUES","start","_endHandle","end","_progressBar","_setIsPressInCurrentRange","updateValue","handleDownBase","_saveInteractionStartData","_handeIsPressed","progressBarDom","querySelector","getBoundingClientRect","_startValueAtBeginningOfAction","_endValueAtBeginningOfAction","_initialPageXPosition","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","preventDefault","_updateValueOnHandleDrag","_updateValueOnRangeDrag","getValueFromInteraction","currentPageXPos","newValues","_calculateRangeOffset","fireEvent","handleUpBase","clientX","value","startHandle","endHandle","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","isNewValueInCurrentRange","valuePropAffectedByInteraction","_setValuesAreReversed","isPressInCurrentRange","focus","initialStartHandlePageXPos","selectedRange","_calculateStartValueByOffset","step","dom","startValuePageX","positionOffset","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","focusInnerElement","_reversedValues","progress","tickmarks","_tickmarks","label","_labelWidth","labelContainer","tooltip","define"],"mappings":"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","sourcesContent":["import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport {\n\tisEscape,\n\tisHome,\n\tisEnd,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tRANGE_SLIDER_ARIA_DESCRIPTION,\n\tRANGE_SLIDER_START_HANDLE_DESCRIPTION,\n\tRANGE_SLIDER_END_HANDLE_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tmanagedSlots: true,\n\tproperties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */  {\n\t\t/**\n\t\t * Defines start point of a selection - position of a first handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tstartValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines end point of a selection - position of a second handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tendValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get template() {\n\t\treturn RangeSliderTemplate;\n\t}\n\n\tstatic get VALUES() {\n\t\treturn {\n\t\t\tstart: \"startValue\",\n\t\t\tend: \"endValue\",\n\t\t};\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = null;\n\t\tthis._stateStorage.endValue = null;\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tget _ariaHandlesText() {\n\t\tconst isRTL = this.effectiveDir === \"rtl\";\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst ariaHandlesText = {};\n\n\t\tif ((isRTL && !isReversed) || (!isRTL && isReversed)) {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t} else {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t}\n\n\t\treturn ariaHandlesText;\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState(\"startValue\", \"endValue\");\n\t\tthis._updateHandlesAndRange(null);\n\t}\n\n\t_onfocusin(event) {\n\t\t// If this is the initial focusin of the component save its initial\n\t\t// value properties so they could be restored on ESC key press\n\t\tif (!this._getInitialValue(\"endValue\")) {\n\t\t\tthis._setInitialValue(\"startValue\", this.startValue);\n\t\t\tthis._setInitialValue(\"endValue\", this.endValue);\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Handles focus out event of the focusable components inner elements.\n\t * Prevent focusout when the focus is getting initially set within the slider before the\n\t * slider customElement itself is finished focusing.\n\t *\n\t * Prevents the focus from leaving the Range Slider when the focus is managed between\n\t * its inner elements in result of user interactions.\n\t *\n\t * Resets the stored Range Slider's initial values saved when it was first focused\n\t *\n\t * @private\n\t */\n\t_onfocusout(event) {\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAffectedValue(null);\n\t\tthis._setInitialValue(\"startValue\", null);\n\t\tthis._setInitialValue(\"endValue\", null);\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t* Handles keyup logic. If one of the handles came across the other\n\t* swap the start and end values. Reset the affected value by the finished\n\t* user interaction.\n\t*\n\t* @private\n\t*/\n\t_onkeyup(event) {\n\t\tsuper._onkeyup(event);\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValue(null);\n\t}\n\n\t_handleActionKeyPress(event) {\n\t\tif (isEscape(event)) {\n\t\t\tthis.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the target of the interaction based on the focused inner element\n\t\tthis._setAffectedValueByFocusedElement();\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// If home/end key is pressed and no single handle is focused the active element\n\t\t// is the range selection - update both start and end values. Otherwise, if 'home'\n\t\t// is pressed the 'startValue'will be used for the start-handle offset calculation,\n\t\t// if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\t\tif ((isEnd(event) || isHome(event)) && !affectedValue) {\n\t\t\tthis._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate how much the value should be increased/decreased based on the action key\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n\t\tif (!newValueOffset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update a single value if one of the handles is focused or the range if not already at min or max\n\t\tif (affectedValue && !this._isPressInCurrentRange) {\n\t\t\tconst newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n\t\t\tthis.update(affectedValue, newValue, null);\n\t\t} else if ((newValueOffset < 0 && this.startValue > min) || (newValueOffset > 0 && this.endValue < max)) {\n\t\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\t\t\tthis.update(affectedValue, newStartValue, newEndValue);\n\t\t}\n\t}\n\n\t/**\n\t * Determines affected value (start/end) depending on the currently\n\t * active inner element within the Range Slider - used in the keyboard handling.\n\t *\n\t * @private\n\t */\n\t_setAffectedValueByFocusedElement() {\n\t\tif (this.shadowRoot.activeElement === this._startHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._endHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._progressBar) {\n\t\t\tthis._setAffectedValue(null);\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(!this._valueAffected);\n\t}\n\n\t/**\n\t * Calculates the start and end values when the 'Home\" or 'End' keys\n\t * are pressed on the selected range bar.\n\t *\n\t * @private\n\t */\n\t_homeEndForSelectedRange(event, affectedValue, min, max) {\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\n\t\tthis.update(null, newStartValue, newEndValue);\n\t}\n\n\t/**\n\t * Update values, stored inner state and the visual UI representation of the component.\n\t * If no specific type of value property is passed - the range is selected - update both handles,\n\t * otherwise update the handle corresponding to the affected by the user interacton value prop.\n\t *\n\t * @private\n\t */\n\tupdate(affectedValue, startValue, endValue) {\n\t\tif (!affectedValue) {\n\t\t\tthis.updateValue(\"startValue\", startValue);\n\t\t\tthis.updateValue(\"endValue\", endValue);\n\t\t\tthis._updateHandlesAndRange(null);\n\t\t} else {\n\t\t\tconst newValue = startValue;\n\t\t\tthis._updateHandlesAndRange(newValue);\n\t\t\tthis.updateValue(affectedValue, newValue);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t *\n\t * @private\n\t */\n\t_onmousedown(event) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(event);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(event, newValue);\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._isPressInCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t *\n\t * @private\n\t */\n\t_saveInteractionStartData(event, newValue) {\n\t\tconst progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\t// Save the initial press point coordinates (position)\n\t\tthis._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t *\n\t * @private\n\t */\n\t_handleMove(event) {\n\t\tevent.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._isPressInCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(event);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(event);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t *\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event) {\n\t\tconst newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t *\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n\t\t// No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\t\tthis._setAffectedValue(null);\n\n\t\t// Update the UI and the state acccording to the calculated new values\n\t\tthis.update(null, newValues[0], newValues[1]);\n\t}\n\n\t_handleUp() {\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValueByFocusedElement();\n\t\tthis._setAffectedValue(null);\n\n\t\tthis._startValueAtBeginningOfAction = null;\n\t\tthis._endValueAtBeginningOfAction = null;\n\t\tthis._setIsPressInCurrentRange(false);\n\n\t\tthis.handleUpBase();\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t *\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX, value) {\n\t\tconst startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t\tconst endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\t// Flag if press is in the current select range\n\t\tconst isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\t\tthis._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n\t}\n\n\t/**\n\t * Sets the value property (start/end) that will get updated\n\t * by a user action depending on that user action's characteristics\n\t * - mouse press position - cursor coordinates relative to the start/end handles\n\t * - selected inner element via a keyboard navigation\n\t *\n\t * @param {String} valuePropAffectedByInteraction The value that will get modified by the interaction\n\t * @private\n\t */\n\t_setAffectedValue(valuePropAffectedByInteraction) {\n\t\tthis._valueAffected = valuePropAffectedByInteraction;\n\n\t\t// If the values have been swapped reset the reversed flag\n\t\tif (this._areValuesReversed()) {\n\t\t\tthis._setValuesAreReversed();\n\t\t}\n\t}\n\n\t/**\n\t * Flag if press action is made on the currently selected range of values\n\t *\n\t * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n\t * @private\n\t */\n\t_setIsPressInCurrentRange(isPressInCurrentRange) {\n\t\tthis._isPressInCurrentRange = isPressInCurrentRange;\n\t}\n\n\t/**\n\t * Manage the focus between the focusable inner elements within the component.\n\t *\n\t * On initial focusin or if the whole range is affected by the user interaction\n\t * set the focus on the progress selection, otherwise on one of the Range Slider\n\t * handles based on the determined affected value by the user action.\n\t *\n\t * If one of the handles came across the other one in result of a user action\n\t * switch the focus between them to keep it visually consistent.\n\t *\n\t * Note:\n\t * In some cases this function is going to get called twice on one user action.\n\t *\n\t * 1. When the focus is initially set to an inner element it is done in the very beginning,\n\t * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n\t * is still not being received, causining an immediate focusout that we prevent by\n\t * calling this function once again.\n\t *\n\t * 2. When the focused is manually switched from one inner element to another.\n\t * The focusout handler is one and the same for all focusable parts within the\n\t * Range Slider and when is called it checks if it should keep the focus within\n\t * the component and which part of it should get focused if that is the case.\n\t *\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (this._isPressInCurrentRange || !affectedValue) {\n\t\t\tthis._progressBar.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.start && !isReversed) || (affectedValue === RangeSlider.VALUES.end && isReversed)) {\n\t\t\tthis._startHandle.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.end && !isReversed) || (affectedValue === RangeSlider.VALUES.start && isReversed)) {\n\t\t\tthis._endHandle.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\t// Return the current values if there is no difference in the\n\t\t// possitions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tstartValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tif (currentPageXPos > this._initialPageXPosition) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t/**\n\t * Updates the visual representation of the component by calculating\n\t * the styles of the handles and the range selection based on the new state.\n\t *\n\t * @private\n\t */\n\t_updateHandlesAndRange(newValue) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\");\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\");\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (affectedValue === RangeSlider.VALUES.start) {\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (affectedValue === RangeSlider.VALUES.end) {\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = ((this.endValue - min) / (max - min)) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps the start and end values of the handles if one came accros the other:\n\t * - If the start value is greater than the endValue swap them and their handles\n\t * - If the endValue become less than the start value swap them and their handles\n\t *\n\t * Switches the focus to the opposite of the currently focused handle.\n\t *\n\t * Note: Only the property values are reversed, the DOM elements of the handles\n\t * corresponding to them are never switched.\n\t *\n\t * @private\n\t */\n\t_swapValues() {\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n\t\t\tconst prevEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = prevEndValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\n\t\tif (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n\t\t\tconst prevStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = prevStartValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Flag that we have swapped the values of the 'start' and 'end' properties,\n\t * to correctly switch the focus within the component from one handle to another\n\t * when the swapping is finished. As we only swap property values and not\n\t * the handle elements themselves, we must also swap their focus.\n\t *\n\t * @private\n\t */\n\t_setValuesAreReversed() {\n\t\tthis._reversedValues = !this._reversedValues;\n\t }\n\n\t _areValuesReversed() {\n\t\treturn this._reversedValues;\n\t}\n\n\tget _startHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t}\n\n\tget _endHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\t}\n\n\tget _progressBar() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-progress\");\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"width\": `${this._selectedRange * 100}%`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\ttickmarks: {\n\t\t\t\t\"background\": `${this._tickmarks}`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tRangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"]},"metadata":{},"sourceType":"module"}