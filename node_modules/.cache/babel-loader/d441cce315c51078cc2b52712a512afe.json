{"ast":null,"code":"import _slicedToArray from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/source-code.js\";\nimport { isEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\"; // Styles\n\nimport styles from \"./generated/themes/SliderBase.css.js\";\n/**\n * @public\n */\n\nvar metadata = {\n  properties:\n  /** @lends sap.ui.webcomponents.main.SliderBase.prototype */\n  {\n    /**\n     * Defines the minimum value of the slider.\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    min: {\n      type: Float,\n      defaultValue: 0\n    },\n\n    /**\n     * Defines the maximum value of the slider.\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    max: {\n      type: Float,\n      defaultValue: 100\n    },\n\n    /**\n     * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n     * <br><br>\n     * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n     *\n     * @type {Integer}\n     * @defaultvalue 1\n     * @public\n     */\n    step: {\n      type: Float,\n      defaultValue: 1\n    },\n\n    /**\n     * Displays a label with a value on every N-th step.\n     * <br><br>\n     * <b>Note:</b> The step and tickmarks properties must be enabled.\n     * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n     * tickmark will be labelled, which means every 4th value number.\n     *\n     * @type {Integer}\n     * @defaultvalue 0\n     * @public\n     */\n    labelInterval: {\n      type: Integer,\n      defaultValue: 0\n    },\n\n    /**\n     * Enables tickmarks visualization for each step.\n     * <br><br>\n     * <b>Note:</b> The step must be a positive number.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTickmarks: {\n      type: Boolean\n    },\n\n    /**\n     * Enables handle tooltip displaying the current value.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTooltip: {\n      type: Boolean\n    },\n\n    /**\n     * Defines whether the slider is in disabled state.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    disabled: {\n      type: Boolean\n    },\n\n    /**\n     * @private\n     */\n    _tooltipVisibility: {\n      type: String,\n      defaultValue: \"hidden\"\n    },\n    _labelsOverlapping: {\n      type: Boolean\n    },\n    _hiddenTickmarks: {\n      type: Boolean\n    }\n  },\n  events:\n  /** @lends sap.ui.webcomponents.main.SliderBase.prototype */\n  {\n    /**\n     * Fired when the value changes and the user has finished interacting with the slider.\n     *\n     * @event\n     * @public\n    */\n    change: {},\n\n    /**\n     * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n     *\n     * @event\n     * @public\n    */\n    input: {}\n  }\n};\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\n\nvar SliderBase = /*#__PURE__*/function (_UI5Element) {\n  _inherits(SliderBase, _UI5Element);\n\n  var _super = _createSuper(SliderBase);\n\n  function SliderBase() {\n    var _this;\n\n    _classCallCheck(this, SliderBase);\n\n    _this = _super.call(this);\n    _this._resizeHandler = _this._handleResize.bind(_assertThisInitialized(_this));\n    _this._moveHandler = _this._handleMove.bind(_assertThisInitialized(_this));\n    _this._upHandler = _this._handleUp.bind(_assertThisInitialized(_this));\n    _this._stateStorage = {\n      step: null,\n      min: null,\n      max: null,\n      labelInterval: null\n    };\n    return _this;\n  }\n\n  _createClass(SliderBase, [{\n    key: \"classes\",\n    get: function get() {\n      return {\n        root: {\n          \"ui5-slider-root-phone\": isPhone()\n        },\n        labelContainer: {\n          \"ui5-slider-hidden-labels\": this._labelsOverlapping\n        }\n      };\n    }\n  }, {\n    key: \"onEnterDOM\",\n    value: function onEnterDOM() {\n      ResizeHandler.register(this, this._resizeHandler);\n    }\n  }, {\n    key: \"onExitDOM\",\n    value: function onExitDOM() {\n      ResizeHandler.deregister(this, this._handleResize);\n    }\n  }, {\n    key: \"onAfterRendering\",\n    value: function onAfterRendering() {\n      // Only call if the resize is triggered by a state changes other than\n      // the ones that occured on the previous resize and those caused by user interaction.\n      if (this.notResized) {\n        this._resizeHandler();\n      }\n    }\n  }, {\n    key: \"_ontouchstart\",\n    value: function _ontouchstart(event) {\n      this._onmousedown(event);\n    }\n    /** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onmouseover\",\n    value: function _onmouseover(event) {\n      if (this.showTooltip) {\n        this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n      }\n    }\n    /**\n     * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onmouseout\",\n    value: function _onmouseout(event) {\n      if (this.showTooltip && !this.shadowRoot.activeElement) {\n        this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n      }\n    }\n    /**\n     * Sets initial value when the component is focused in, can be restored with ESC key\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setInitialValue\",\n    value: function _setInitialValue(valueType, value) {\n      this[\"_\".concat(valueType, \"Initial\")] = value;\n    }\n  }, {\n    key: \"_getInitialValue\",\n    value: function _getInitialValue(valueType) {\n      return this[\"_\".concat(valueType, \"Initial\")];\n    }\n  }, {\n    key: \"_onkeydown\",\n    value: function _onkeydown(event) {\n      if (this.disabled || this._effectiveStep === 0) {\n        return;\n      }\n\n      if (SliderBase._isActionKey(event)) {\n        event.preventDefault();\n        this._isUserInteraction = true;\n\n        this._handleActionKeyPress(event);\n      }\n    }\n  }, {\n    key: \"_onkeyup\",\n    value: function _onkeyup(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      this._isUserInteraction = false;\n    }\n    /**\n     * Flags if an inner element is currently being focused\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_preserveFocus\",\n    value: function _preserveFocus(isFocusing) {\n      this._isInnerElementFocusing = isFocusing;\n    }\n    /**\n     * Return if an inside element within the component is currently being focused\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_isFocusing\",\n    value: function _isFocusing() {\n      return this._isInnerElementFocusing;\n    }\n    /**\n     * Prevent focus out when inner element within the component is currently being in process of focusing in.\n     * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n     * the .attachShadow() customElement method is set to true, or if we forward it manually.\n    \t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n     * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n     * removed as it will become redundant.\n     *\n     * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n     * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n     * is set to the customElement (ui5-slider) causing a 'race condition'.\n     *\n     * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n     * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n     * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n     * in both initial focusing and switching the focus between inner elements of the component cases.\n    \t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n     * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n     * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n     * because of the nature of the component and its available drag interactions.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_preventFocusOut\",\n    value: function _preventFocusOut() {\n      this.focusInnerElement();\n    }\n    /**\n     * Manages the focus between the component's inner elements\n     * @protected\n     */\n\n  }, {\n    key: \"focusInnerElement\",\n    value: function focusInnerElement() {\n      this.focus();\n    }\n    /**\n     * Handle the responsiveness of the Slider's UI elements when resizing\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_handleResize\",\n    value: function _handleResize() {\n      if (!this.showTickmarks) {\n        return;\n      } // Mark resizing to avoid unneccessary calls to that function after rendering\n\n\n      this.notResized = false; // Convert the string represented calculation expression to a normal one\n      // Check the distance  in pixels exist between every tickmark\n\n      var spaceBetweenTickmarks = this._spaceBetweenTickmarks(); // If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n      // In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\n\n      if (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n        this._hiddenTickmarks = true;\n        this._labelsOverlapping = true;\n      } else {\n        this._hiddenTickmarks = false;\n      }\n\n      if (this.labelInterval <= 0 || this._hiddenTickmarks) {\n        return;\n      } // Check if there are any overlapping labels.\n      // If so - only the first and the last one should be visible\n\n\n      var labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n      this._labelsOverlapping = _toConsumableArray(labelItems).some(function (label) {\n        return label.scrollWidth > label.clientWidth;\n      });\n    }\n    /**\n     * Called when the user starts interacting with the slider.\n     * After a down event on the slider root, listen for move events on window, so the slider value\n     * is updated even if the user drags the pointer outside the slider root.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"handleDownBase\",\n    value: function handleDownBase(event) {\n      var _this2 = this;\n\n      var min = this._effectiveMin;\n      var max = this._effectiveMax;\n      var domRect = this.getBoundingClientRect();\n      var directionStart = this.directionStart;\n      var step = this._effectiveStep;\n      var newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart); // Mark start of a user interaction\n\n      this._isUserInteraction = true; // Only allow one type of move event to be listened to (the first one registered after the down event)\n\n      this._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n      SliderBase.UP_EVENTS.forEach(function (upEventType) {\n        return window.addEventListener(upEventType, _this2._upHandler);\n      });\n      window.addEventListener(this._moveEventType, this._moveHandler);\n\n      this._handleFocusOnMouseDown(event);\n\n      return newValue;\n    }\n    /**\n     * Forward the focus to an inner inner part within the component on press\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_handleFocusOnMouseDown\",\n    value: function _handleFocusOnMouseDown(event) {\n      var focusedElement = this.shadowRoot.activeElement;\n\n      if (!focusedElement || focusedElement !== event.target) {\n        this._preserveFocus(true);\n\n        this.focusInnerElement();\n      }\n    }\n    /**\n     * Called when the user finish interacting with the slider\n     * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"handleUpBase\",\n    value: function handleUpBase(valueType) {\n      var _this3 = this;\n\n      SliderBase.UP_EVENTS.forEach(function (upEventType) {\n        return window.removeEventListener(upEventType, _this3._upHandler);\n      });\n      window.removeEventListener(this._moveEventType, this._moveHandler);\n      this._moveEventType = null;\n      this._isUserInteraction = false;\n\n      this._preserveFocus(false);\n    }\n    /**\n     * Updates value property of the component that has been changed due to a user action.\n     * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"updateValue\",\n    value: function updateValue(valueType, value) {\n      this[valueType] = value;\n      this.storePropertyState(valueType);\n\n      if (this._isUserInteraction) {\n        this.fireEvent(\"input\");\n      }\n    }\n    /**\n     * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"syncUIAndState\",\n    value:\n    /**\n     * Normalize current properties, update the previously stored state.\n     *\n     * @protected\n     */\n    function syncUIAndState() {\n      var _this4 = this;\n\n      // Validate step and update the stored state for the step property.\n      if (this.isPropertyUpdated(\"step\")) {\n        this._validateStep(this.step);\n\n        this.storePropertyState(\"step\");\n      } // Recalculate the tickmarks and labels and update the stored state.\n\n\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      if (this.isPropertyUpdated.apply(this, [\"min\", \"max\"].concat(values))) {\n        this.storePropertyState(\"min\", \"max\"); // Here the value props are changed programatically (not by user interaction)\n        // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n        // min and max bounderies and update the previous state reference.\n\n        values.forEach(function (valueType) {\n          var normalizedValue = SliderBase.clipValue(_this4[valueType], _this4._effectiveMin, _this4._effectiveMax);\n\n          _this4.updateValue(valueType, normalizedValue);\n\n          _this4.storePropertyState(valueType);\n        });\n      } // Labels must be updated if any of the min/max/step/labelInterval props are changed\n\n\n      if (this.labelInterval && this.showTickmarks) {\n        this._createLabels();\n      } // Update the stored state for the labelInterval, if changed\n\n\n      if (this.isPropertyUpdated(\"labelInterval\")) {\n        this.storePropertyState(\"labelInterval\");\n      }\n    }\n    /**\n     * In order to always keep the visual UI representation and the internal\n     * state in sync, the component has a 'state storage' that is updated when the\n     * current state is changed due to a user action.\n     *\n     * Check if the previously saved state is outdated. That would mean\n     * a property has been changed programatically because the previous state\n     * is always updated in the interaction handlers.\n     *\n     * Will return true if any of the properties is not equal to its previously\n     * stored value.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"isCurrentStateOutdated\",\n    value: function isCurrentStateOutdated() {\n      var _this5 = this;\n\n      return Object.entries(this._stateStorage).some(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            propName = _ref2[0],\n            propValue = _ref2[1];\n\n        return _this5[propName] !== propValue;\n      });\n    }\n    /**\n     * Returns the last stored value of a property\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"getStoredPropertyState\",\n    value: function getStoredPropertyState(property) {\n      return this._stateStorage[property];\n    }\n    /**\n     * Check if one or more properties have been updated compared to their last\n     * saved values in the state storage.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"isPropertyUpdated\",\n    value: function isPropertyUpdated() {\n      var _this6 = this;\n\n      for (var _len2 = arguments.length, properties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        properties[_key2] = arguments[_key2];\n      }\n\n      return properties.some(function (prop) {\n        return _this6.getStoredPropertyState(prop) !== _this6[prop];\n      });\n    }\n    /**\n     * Updates the previously saved in the _stateStorage values of one or more properties.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"storePropertyState\",\n    value: function storePropertyState() {\n      var _this7 = this;\n\n      for (var _len3 = arguments.length, props = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        props[_key3] = arguments[_key3];\n      }\n\n      props.forEach(function (property) {\n        _this7._stateStorage[property] = _this7[property];\n      });\n    }\n    /**\n     * Returns the start side of a direction - left for LTR, right for RTL\n     */\n\n  }, {\n    key: \"directionStart\",\n    get: function get() {\n      return this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n    }\n    /**\n     * Calculates and draws the tickmarks with a CSS gradient style\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_tickmarks\",\n    get: function get() {\n      if (!this.showTickmarks || !this._effectiveStep) {\n        return;\n      }\n\n      if (this._hiddenTickmarks) {\n        return \"linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x\";\n      } // Convert number values to strings to let the CSS do calculations better\n      // rounding/subpixel behavior\" and the most precise tickmarks distribution\n\n\n      var maxStr = String(this._effectiveMax);\n      var minStr = String(this._effectiveMin);\n      var stepStr = String(this._effectiveStep); // There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n      // respect the variable for more than one theme. It has to be set here for now.\n\n      var currentTheme = getTheme();\n      var tickmarkWidth = \"1px\";\n      var currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n      this._tickmarksAmount = \"\".concat(maxStr - minStr, \" / \").concat(stepStr);\n      this._hiddenTickmarks = false; // Transparent CSS gradient background\n\n      var tickmarksGradientBase = \"linear-gradient(to right, \".concat(currentColor, \" \").concat(tickmarkWidth, \", transparent 0) \"); // Draw the tickmarks as a patern over the gradient background\n\n      var tickmarksGradientdPattern = \"0 center / calc((100% - \".concat(tickmarkWidth, \") / (\").concat(this._tickmarksAmount, \")) 100% repeat-x\"); // Combine to get the complete CSS background gradient property value\n\n      return \"\".concat(tickmarksGradientBase + tickmarksGradientdPattern);\n    }\n    /**\n     * Calculates the labels amout, width and text and creates them\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_createLabels\",\n    value: function _createLabels() {\n      if (!this.labelInterval || !this.showTickmarks) {\n        return;\n      }\n\n      var labelInterval = this.labelInterval;\n      var step = this._effectiveStep;\n      var newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval); // If the required labels are already rendered\n\n      if (newNumberOfLabels === this._oldNumberOfLabels) {\n        return;\n      }\n\n      this._oldNumberOfLabels = newNumberOfLabels;\n      this._labelWidth = 100 / newNumberOfLabels;\n      this._labelValues = []; // If the step value is not a round number get its precision\n\n      var stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step); // numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n      // calculation to be precize (exactly the same as the distance between the tickmarks).\n      // That's ok as the loop stop condition is set to an integer, so it will practically\n      // \"floor\" the number of labels anyway.\n\n\n      for (var i = 0; i <= newNumberOfLabels; i++) {\n        // Format the label numbers with the same decimal precision as the value of the step property\n        var labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);\n\n        this._labelValues.push(labelItemNumber);\n      }\n    }\n  }, {\n    key: \"_handleActionKeyPressBase\",\n    value: function _handleActionKeyPressBase(event, affectedValue) {\n      var isUpAction = SliderBase._isIncreaseValueAction(event);\n\n      var isBigStep = SliderBase._isBigStepAction(event);\n\n      var currentValue = this[affectedValue];\n      var min = this._effectiveMin;\n      var max = this._effectiveMax; // We need to take into consideration the effective direction of the slider - rtl or ltr.\n      // While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\n      var step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep; // If the action key corresponds to a long step and the slider has more than 10 normal steps,\n      // make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\n      step = isBigStep && (max - min) / step > 10 ? (max - min) / 10 : step;\n\n      if (isEnd(event)) {\n        return max - currentValue;\n      }\n\n      if (isHome(event)) {\n        return (currentValue - min) * -1;\n      }\n\n      return isUpAction ? step : step * -1;\n    }\n  }, {\n    key: \"_spaceBetweenTickmarks\",\n    value:\n    /**\n     * Calculates space between tickmarks\n     *\n     * @private\n     */\n    function _spaceBetweenTickmarks() {\n      var tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\n      var tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n      return this.getBoundingClientRect().width / tickmarksAmount;\n    }\n    /**\n     * Notify in case of a invalid step value type\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_validateStep\",\n    value: function _validateStep(step) {\n      if (step === 0) {\n        console.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n      }\n\n      if (step < 0) {\n        console.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n      }\n\n      if (typeof step !== \"number\" || Number.isNaN(step)) {\n        console.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n      }\n    }\n  }, {\n    key: \"_labels\",\n    get: function get() {\n      return this._labelValues || [];\n    }\n    /**\n     * Normalizes a new <code>step</code> property value.\n     * If tickmarks are enabled recreates them according to it.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_effectiveStep\",\n    get: function get() {\n      var step = this.step;\n\n      if (step < 0) {\n        step = Math.abs(step);\n      }\n\n      if (typeof step !== \"number\" || Number.isNaN(step)) {\n        step = 1;\n      }\n\n      return step;\n    }\n  }, {\n    key: \"_effectiveMin\",\n    get: function get() {\n      return Math.min(this.min, this.max);\n    }\n  }, {\n    key: \"_effectiveMax\",\n    get: function get() {\n      return Math.max(this.min, this.max);\n    }\n  }, {\n    key: \"tabIndex\",\n    get: function get() {\n      return this.disabled ? \"-1\" : \"0\";\n    }\n  }], [{\n    key: \"metadata\",\n    get: function get() {\n      return metadata;\n    }\n  }, {\n    key: \"render\",\n    get: function get() {\n      return litRender;\n    }\n  }, {\n    key: \"styles\",\n    get: function get() {\n      return styles;\n    }\n  }, {\n    key: \"TICKMARK_COLOR_MAP\",\n    get: function get() {\n      return {\n        sap_fiori_3: \"#89919a\",\n        sap_fiori_3_dark: \"#89919a\",\n        sap_fiori_3_hcw: \"#000000\",\n        sap_fiori_3_hcb: \"#ffffff\",\n        sap_belize: \"#bfbfbf\",\n        sap_belize_hcw: \"#000000\",\n        sap_belize_hcb: \"#ffffff\",\n        sap_horizon: \"#89919a\"\n      };\n    }\n  }, {\n    key: \"UP_EVENTS\",\n    get: function get() {\n      return [\"mouseup\", \"touchend\"];\n    }\n  }, {\n    key: \"MOVE_EVENT_MAP\",\n    get: function get() {\n      return {\n        mousedown: \"mousemove\",\n        touchstart: \"touchmove\"\n      };\n    }\n  }, {\n    key: \"ACTION_KEYS\",\n    get: function get() {\n      return [isLeft, isRight, isUp, isDown, isLeftCtrl, isRightCtrl, isUpCtrl, isDownCtrl, isPlus, isMinus, isHome, isEnd, isPageUp, isPageDown, isEscape];\n    }\n  }, {\n    key: \"MIN_SPACE_BETWEEN_TICKMARKS\",\n    get: function get() {\n      return 8;\n    }\n  }, {\n    key: \"TOOLTIP_VISIBILITY\",\n    get: function get() {\n      return {\n        VISIBLE: \"visible\",\n        HIDDEN: \"hidden\"\n      };\n    }\n  }, {\n    key: \"_isActionKey\",\n    value: function _isActionKey(event) {\n      return this.ACTION_KEYS.some(function (actionKey) {\n        return actionKey(event);\n      });\n    }\n    /**\n     * Locks the given value between min and max boundaries based on slider properties\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"clipValue\",\n    value: function clipValue(value, min, max) {\n      value = Math.min(Math.max(value, min), max);\n      return value;\n    }\n    /**\n     * Sets the slider value from an event\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"getValueFromInteraction\",\n    value: function getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n      var pageX = this.getPageXValueFromEvent(event);\n      var value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n      var steppedValue = this.getSteppedValue(value, stepSize, min);\n      return this.clipValue(steppedValue, min, max);\n    }\n    /**\n     * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"getSteppedValue\",\n    value: function getSteppedValue(value, stepSize, min) {\n      var stepModuloValue = Math.abs((value - min) % stepSize);\n\n      if (stepSize === 0 || stepModuloValue === 0) {\n        return value;\n      } // Clip (snap) the new value to the nearest step\n\n\n      value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue; // If the step value is not a round number get its precision\n\n      var stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\n      return value.toFixed(stepPrecision);\n    }\n    /**\n     * Gets pageX value from event on user interaction with the Slider\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"getPageXValueFromEvent\",\n    value: function getPageXValueFromEvent(event) {\n      if (event.targetTouches && event.targetTouches.length > 0) {\n        return event.targetTouches[0].pageX;\n      }\n\n      return event.pageX;\n    }\n    /**\n     * Computes the new value (in %) from the pageX position of the cursor.\n     * Returns the value rounded to a precision of at most 2 digits after decimal point.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"computedValueFromPageX\",\n    value: function computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n      // Determine pageX position relative to the Slider DOM\n      var xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX; // Calculate the percentage complete (the \"progress\")\n\n      var percentageComplete = xRelativePosition / boundingClientRect.width; // Fit (map) the complete percentage between the min/max value range\n\n      return min + percentageComplete * (max - min);\n    }\n    /**\n     * Calculates the precision (decimal places) of a number, returns 0 if integer\n     * Handles scientific notation cases.\n     * @private\n     */\n\n  }, {\n    key: \"_getDecimalPrecisionOfNumber\",\n    value: function _getDecimalPrecisionOfNumber(value) {\n      if (Number.isInteger(value)) {\n        return 0;\n      }\n\n      var match = String(value).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n      return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n    }\n  }, {\n    key: \"_isDecreaseValueAction\",\n    value: function _isDecreaseValueAction(event) {\n      return isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n    }\n  }, {\n    key: \"_isIncreaseValueAction\",\n    value: function _isIncreaseValueAction(event) {\n      return isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n    }\n  }, {\n    key: \"_isBigStepAction\",\n    value: function _isBigStepAction(event) {\n      return isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n    }\n  }]);\n\n  return SliderBase;\n}(UI5Element);\n\nexport default SliderBase;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents/dist/SliderBase.js"],"names":["UI5Element","litRender","Float","Integer","ResizeHandler","isPhone","isEscape","isHome","isEnd","isUp","isDown","isRight","isLeft","isUpCtrl","isDownCtrl","isRightCtrl","isLeftCtrl","isPlus","isMinus","isPageUp","isPageDown","getTheme","styles","metadata","properties","min","type","defaultValue","max","step","labelInterval","showTickmarks","Boolean","showTooltip","disabled","_tooltipVisibility","String","_labelsOverlapping","_hiddenTickmarks","events","change","input","SliderBase","_resizeHandler","_handleResize","bind","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","root","labelContainer","register","deregister","notResized","event","_onmousedown","TOOLTIP_VISIBILITY","VISIBLE","shadowRoot","activeElement","HIDDEN","valueType","value","_effectiveStep","_isActionKey","preventDefault","_isUserInteraction","_handleActionKeyPress","isFocusing","_isInnerElementFocusing","focusInnerElement","focus","spaceBetweenTickmarks","_spaceBetweenTickmarks","MIN_SPACE_BETWEEN_TICKMARKS","labelItems","querySelectorAll","some","label","scrollWidth","clientWidth","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","newValue","getValueFromInteraction","_moveEventType","MOVE_EVENT_MAP","UP_EVENTS","forEach","upEventType","window","addEventListener","_handleFocusOnMouseDown","focusedElement","target","_preserveFocus","removeEventListener","storePropertyState","fireEvent","isPropertyUpdated","_validateStep","values","normalizedValue","clipValue","updateValue","_createLabels","Object","entries","propName","propValue","property","prop","getStoredPropertyState","props","effectiveDir","maxStr","minStr","stepStr","currentTheme","tickmarkWidth","currentColor","TICKMARK_COLOR_MAP","_tickmarksAmount","tickmarksGradientBase","tickmarksGradientdPattern","newNumberOfLabels","_oldNumberOfLabels","_labelWidth","_labelValues","stepPrecision","_getDecimalPrecisionOfNumber","i","labelItemNumber","toFixed","push","affectedValue","isUpAction","_isIncreaseValueAction","isBigStep","_isBigStepAction","currentValue","tickmarksAmountStrCalc","split","tickmarksAmount","width","console","warn","Number","isNaN","Math","abs","sap_fiori_3","sap_fiori_3_dark","sap_fiori_3_hcw","sap_fiori_3_hcb","sap_belize","sap_belize_hcw","sap_belize_hcb","sap_horizon","mousedown","touchstart","ACTION_KEYS","actionKey","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","targetTouches","length","xRelativePosition","percentageComplete","isInteger","match"],"mappings":"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","sourcesContent":["import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/source-code.js\";\nimport {\n\tisEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\tproperties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */  {\n\t\t/**\n\t\t * Defines the minimum value of the slider.\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tmin: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines the maximum value of the slider.\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tmax: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t\t/**\n\t\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t\t * <br><br>\n\t\t * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 1\n\t\t * @public\n\t\t */\n\t\tstep: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 1,\n\t\t},\n\t\t/**\n\t\t * Displays a label with a value on every N-th step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step and tickmarks properties must be enabled.\n\t\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t\t * tickmark will be labelled, which means every 4th value number.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tlabelInterval: {\n\t\t\ttype: Integer,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Enables tickmarks visualization for each step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step must be a positive number.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Enables handle tooltip displaying the current value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTooltip: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Defines whether the slider is in disabled state.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tooltipVisibility: {\n\t\t\ttype: String,\n\t\t\tdefaultValue: \"hidden\",\n\t\t},\n\t\t_labelsOverlapping: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t_hiddenTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n\tevents: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */ {\n\t\t/**\n\t\t * Fired when the value changes and the user has finished interacting with the slider.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tchange: {},\n\t\t/**\n\t\t * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tinput: {},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: null,\n\t\t\tmin: null,\n\t\t\tmax: null,\n\t\t\tlabelInterval: null,\n\t\t};\n\t}\n\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get render() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn styles;\n\t}\n\n\tstatic get TICKMARK_COLOR_MAP() {\n\t\treturn {\n\t\t\tsap_fiori_3: \"#89919a\",\n\t\t\tsap_fiori_3_dark: \"#89919a\",\n\t\t\tsap_fiori_3_hcw: \"#000000\",\n\t\t\tsap_fiori_3_hcb: \"#ffffff\",\n\t\t\tsap_belize: \"#bfbfbf\",\n\t\t\tsap_belize_hcw: \"#000000\",\n\t\t\tsap_belize_hcb: \"#ffffff\",\n\t\t\tsap_horizon: \"#89919a\",\n\t\t};\n\t}\n\n\tstatic get UP_EVENTS() {\n\t\treturn [\"mouseup\", \"touchend\"];\n\t}\n\n\tstatic get MOVE_EVENT_MAP() {\n\t\treturn {\n\t\t\tmousedown: \"mousemove\",\n\t\t\ttouchstart: \"touchmove\",\n\t\t};\n\t}\n\n\tstatic get ACTION_KEYS() {\n\t\treturn [\n\t\t\tisLeft,\n\t\t\tisRight,\n\t\t\tisUp,\n\t\t\tisDown,\n\t\t\tisLeftCtrl,\n\t\t\tisRightCtrl,\n\t\t\tisUpCtrl,\n\t\t\tisDownCtrl,\n\t\t\tisPlus,\n\t\t\tisMinus,\n\t\t\tisHome,\n\t\t\tisEnd,\n\t\t\tisPageUp,\n\t\t\tisPageDown,\n\t\t\tisEscape,\n\t\t];\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tstatic get TOOLTIP_VISIBILITY() {\n\t\treturn {\n\t\t\tVISIBLE: \"visible\",\n\t\t\tHIDDEN: \"hidden\",\n\t\t};\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\troot: {\n\t\t\t\t\"ui5-slider-root-phone\": isPhone(),\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._handleResize);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t_ontouchstart(event) {\n\t\tthis._onmousedown(event);\n\t}\n\n\t/** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseover(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseout(event) {\n\t\tif (this.showTooltip && !this.shadowRoot.activeElement) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t * Sets initial value when the component is focused in, can be restored with ESC key\n\t *\n\t * @private\n\t */\n\t_setInitialValue(valueType, value) {\n\t\tthis[`_${valueType}Initial`] = value;\n\t}\n\n\t_getInitialValue(valueType) {\n\t\treturn this[`_${valueType}Initial`];\n\t}\n\n\t_onkeydown(event) {\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (SliderBase._isActionKey(event)) {\n\t\t\tevent.preventDefault();\n\n\t\t\tthis._isUserInteraction = true;\n\t\t\tthis._handleActionKeyPress(event);\n\t\t}\n\t}\n\n\t_onkeyup(event) {\n\t\tif (this.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Flags if an inner element is currently being focused\n\t *\n\t * @private\n\t */\n\t_preserveFocus(isFocusing) {\n\t\tthis._isInnerElementFocusing = isFocusing;\n\t}\n\n\t/**\n\t * Return if an inside element within the component is currently being focused\n\t *\n\t * @private\n\t */\n\t_isFocusing() {\n\t\treturn this._isInnerElementFocusing;\n\t}\n\n\t/**\n\t * Prevent focus out when inner element within the component is currently being in process of focusing in.\n\t * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n\t * the .attachShadow() customElement method is set to true, or if we forward it manually.\n\n\t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n\t * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n\t * removed as it will become redundant.\n\t *\n\t * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n\t * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n\t * is set to the customElement (ui5-slider) causing a 'race condition'.\n\t *\n\t * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n\t * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n\t * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n\t * in both initial focusing and switching the focus between inner elements of the component cases.\n\n\t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n\t * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n\t * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n\t * because of the nature of the component and its available drag interactions.\n\t *\n\t * @private\n\t */\n\t_preventFocusOut() {\n\t\tthis.focusInnerElement();\n\t}\n\n\t/**\n\t * Manages the focus between the component's inner elements\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tthis.focus();\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t *\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t *\n\t * @protected\n\t */\n\thandleDownBase(event) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tthis._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n\t\twindow.addEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._handleFocusOnMouseDown(event);\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Forward the focus to an inner inner part within the component on press\n\t *\n\t * @private\n\t */\n\t_handleFocusOnMouseDown(event) {\n\t\tconst focusedElement = this.shadowRoot.activeElement;\n\n\t\tif (!focusedElement || focusedElement !== event.target) {\n\t\t\tthis._preserveFocus(true);\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n\t *\n\t * @protected\n\t */\n\thandleUpBase(valueType) {\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n\t\twindow.removeEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._moveEventType = null;\n\t\tthis._isUserInteraction = false;\n\t\tthis._preserveFocus(false);\n\t}\n\n\t/**\n\t * Updates value property of the component that has been changed due to a user action.\n\t * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n\t *\n\t * @protected\n\t */\n\tupdateValue(valueType, value) {\n\t\tthis[valueType] = value;\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n\t *\n\t * @private\n\t */\n\tstatic _isActionKey(event) {\n\t\treturn this.ACTION_KEYS.some(actionKey => actionKey(event));\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t *\n\t * @protected\n\t */\n\tstatic clipValue(value, min, max) {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t *\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n\t\tconst pageX = this.getPageXValueFromEvent(event);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t *\n\t * @protected\n\t */\n\tstatic getSteppedValue(value, stepSize, min) {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn value.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t *\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(event) {\n\t\tif (event.targetTouches && event.targetTouches.length > 0) {\n\t\t\treturn event.targetTouches[0].pageX;\n\t\t}\n\n\t\treturn event.pageX;\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t *\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * Normalize current properties, update the previously stored state.\n\t *\n\t * @protected\n\t */\n\tsyncUIAndState(...values) {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tvalues.forEach(valueType => {\n\t\t\t\tconst normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n\t\t\t\tthis.updateValue(valueType, normalizedValue);\n\t\t\t\tthis.storePropertyState(valueType);\n\t\t\t});\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t *\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t *\n\t * @protected\n\t */\n\tgetStoredPropertyState(property) {\n\t\treturn this._stateStorage[property];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t *\n\t * @protected\n\t */\n\tisPropertyUpdated(...properties) {\n\t\treturn properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t *\n\t * @protected\n\t */\n\tstorePropertyState(...props) {\n\t\tprops.forEach(property => {\n\t\t\tthis._stateStorage[property] = this[property];\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates and draws the tickmarks with a CSS gradient style\n\t *\n\t * @private\n\t */\n\tget _tickmarks() {\n\t\tif (!this.showTickmarks || !this._effectiveStep) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n\t\t}\n\n\t\t// Convert number values to strings to let the CSS do calculations better\n\t\t// rounding/subpixel behavior\" and the most precise tickmarks distribution\n\t\tconst maxStr = String(this._effectiveMax);\n\t\tconst minStr = String(this._effectiveMin);\n\t\tconst stepStr = String(this._effectiveStep);\n\n\t\t// There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n\t\t// respect the variable for more than one theme. It has to be set here for now.\n\t\tconst currentTheme = getTheme();\n\t\tconst tickmarkWidth = \"1px\";\n\t\tconst currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n\n\t\tthis._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n\t\tthis._hiddenTickmarks = false;\n\n\t\t// Transparent CSS gradient background\n\t\tconst tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `;\n\n\t\t// Draw the tickmarks as a patern over the gradient background\n\t\tconst tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`;\n\n\t\t// Combine to get the complete CSS background gradient property value\n\t\treturn `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n\t}\n\n\t/**\n\t * Calculates the labels amout, width and text and creates them\n\t *\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\t_handleActionKeyPressBase(event, affectedValue) {\n\t\tconst isUpAction = SliderBase._isIncreaseValueAction(event);\n\t\tconst isBigStep = SliderBase._isBigStepAction(event);\n\n\t\tconst currentValue = this[affectedValue];\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\n\t\t// We need to take into consideration the effective direction of the slider - rtl or ltr.\n\t\t// While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\t\tlet step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n\n\t\t// If the action key corresponds to a long step and the slider has more than 10 normal steps,\n\t\t// make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\t\tstep = isBigStep && ((max - min) / step > 10) ? (max - min) / 10 : step;\n\n\t\tif (isEnd(event)) {\n\t\t\treturn max - currentValue;\n\t\t}\n\n\t\tif (isHome(event)) {\n\t\t\treturn (currentValue - min) * -1;\n\t\t}\n\n\t\treturn isUpAction ? step : step * -1;\n\t}\n\n\tstatic _isDecreaseValueAction(event) {\n\t\treturn isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n\t}\n\n\tstatic _isIncreaseValueAction(event) {\n\t\treturn isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n\t}\n\n\tstatic _isBigStepAction(event) {\n\t\treturn isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t *\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\tconst tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\t\tconst tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n\n\t\treturn this.getBoundingClientRect().width / tickmarksAmount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t *\n\t * @private\n\t */\n\t_validateStep(step) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Normalizes a new <code>step</code> property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t *\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n\n\tget tabIndex() {\n\t\treturn this.disabled ? \"-1\" : \"0\";\n\t}\n}\n\nexport default SliderBase;\n"]},"metadata":{},"sourceType":"module"}