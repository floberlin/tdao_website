{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport BitArray from '../../common/BitArray';\nimport IllegalArgumentException from '../../IllegalArgumentException';\nimport StringUtils from '../../common/StringUtils';\nimport BitMatrix from '../../common/BitMatrix';\nimport AztecCode from './AztecCode';\nimport ReedSolomonEncoder from '../../common/reedsolomon/ReedSolomonEncoder';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport Integer from '../../util/Integer';\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// package com.google.zxing.aztec.encoder;\n// import com.google.zxing.common.BitArray;\n// import com.google.zxing.common.BitMatrix;\n// import com.google.zxing.common.reedsolomon.GenericGF;\n// import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n\n/**\n * Generates Aztec 2D barcodes.\n *\n * @author Rustam Abdullaev\n */\n\nvar Encoder = function () {\n  function Encoder() {}\n  /**\n   * Encodes the given binary content as an Aztec symbol\n   *\n   * @param data input data string\n   * @return Aztec symbol matrix with metadata\n   */\n\n\n  Encoder.encodeBytes = function (data) {\n    return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);\n  };\n  /**\n   * Encodes the given binary content as an Aztec symbol\n   *\n   * @param data input data string\n   * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n   *                      a minimum of 23% + 3 words is recommended)\n   * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n   * @return Aztec symbol matrix with metadata\n   */\n\n\n  Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {\n    // High-level encode\n    var bits = new HighLevelEncoder(data).encode(); // stuff bits and choose symbol size\n\n    var eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;\n    var totalSizeBits = bits.getSize() + eccBits;\n    var compact;\n    var layers;\n    var totalBitsInLayer;\n    var wordSize;\n    var stuffedBits;\n\n    if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {\n      compact = userSpecifiedLayers < 0;\n      layers = Math.abs(userSpecifiedLayers);\n\n      if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {\n        throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));\n      }\n\n      totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n      wordSize = Encoder.WORD_SIZE[layers];\n      var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n      stuffedBits = Encoder.stuffBits(bits, wordSize);\n\n      if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n        throw new IllegalArgumentException('Data to large for user specified layer');\n      }\n\n      if (compact && stuffedBits.getSize() > wordSize * 64) {\n        // Compact format only allows 64 data words, though C4 can hold more words than that\n        throw new IllegalArgumentException('Data to large for user specified layer');\n      }\n    } else {\n      wordSize = 0;\n      stuffedBits = null; // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n      // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n      // is the same size, but has more data.\n\n      for (var i\n      /*int*/\n      = 0;; i++) {\n        if (i > Encoder.MAX_NB_BITS) {\n          throw new IllegalArgumentException('Data too large for an Aztec code');\n        }\n\n        compact = i <= 3;\n        layers = compact ? i + 1 : i;\n        totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n\n        if (totalSizeBits > totalBitsInLayer) {\n          continue;\n        } // [Re]stuff the bits if this is the first opportunity, or if the\n        // wordSize has changed\n\n\n        if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {\n          wordSize = Encoder.WORD_SIZE[layers];\n          stuffedBits = Encoder.stuffBits(bits, wordSize);\n        }\n\n        var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n\n        if (compact && stuffedBits.getSize() > wordSize * 64) {\n          // Compact format only allows 64 data words, though C4 can hold more words than that\n          continue;\n        }\n\n        if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n          break;\n        }\n      }\n    }\n\n    var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize); // generate mode message\n\n    var messageSizeInWords = stuffedBits.getSize() / wordSize;\n    var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords); // allocate symbol\n\n    var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n\n    var alignmentMap = new Int32Array(baseMatrixSize);\n    var matrixSize;\n\n    if (compact) {\n      // no alignment marks in compact mode, alignmentMap is a no-op\n      matrixSize = baseMatrixSize;\n\n      for (var i\n      /*int*/\n      = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);\n      var origCenter = Integer.truncDivision(baseMatrixSize, 2);\n      var center = Integer.truncDivision(matrixSize, 2);\n\n      for (var i\n      /*int*/\n      = 0; i < origCenter; i++) {\n        var newOffset = i + Integer.truncDivision(i, 15);\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n\n    var matrix = new BitMatrix(matrixSize); // draw data bits\n\n    for (var i\n    /*int*/\n    = 0, rowOffset = 0; i < layers; i++) {\n      var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n\n      for (var j\n      /*int*/\n      = 0; j < rowSize; j++) {\n        var columnOffset = j * 2;\n\n        for (var k\n        /*int*/\n        = 0; k < 2; k++) {\n          if (messageBits.get(rowOffset + columnOffset + k)) {\n            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n          }\n\n          if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n          }\n\n          if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n          }\n\n          if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n          }\n        }\n      }\n\n      rowOffset += rowSize * 8;\n    } // draw mode message\n\n\n    Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage); // draw alignment marks\n\n    if (compact) {\n      Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n    } else {\n      Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n\n      for (var i\n      /*int*/\n      = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n        for (var k\n        /*int*/\n        = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n          matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n          matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n          matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n          matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n        }\n      }\n    }\n\n    var aztec = new AztecCode();\n    aztec.setCompact(compact);\n    aztec.setSize(matrixSize);\n    aztec.setLayers(layers);\n    aztec.setCodeWords(messageSizeInWords);\n    aztec.setMatrix(matrix);\n    return aztec;\n  };\n\n  Encoder.drawBullsEye = function (matrix, center, size) {\n    for (var i\n    /*int*/\n    = 0; i < size; i += 2) {\n      for (var j\n      /*int*/\n      = center - i; j <= center + i; j++) {\n        matrix.set(j, center - i);\n        matrix.set(j, center + i);\n        matrix.set(center - i, j);\n        matrix.set(center + i, j);\n      }\n    }\n\n    matrix.set(center - size, center - size);\n    matrix.set(center - size + 1, center - size);\n    matrix.set(center - size, center - size + 1);\n    matrix.set(center + size, center - size);\n    matrix.set(center + size, center - size + 1);\n    matrix.set(center + size, center + size - 1);\n  };\n\n  Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {\n    var modeMessage = new BitArray();\n\n    if (compact) {\n      modeMessage.appendBits(layers - 1, 2);\n      modeMessage.appendBits(messageSizeInWords - 1, 6);\n      modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);\n    } else {\n      modeMessage.appendBits(layers - 1, 5);\n      modeMessage.appendBits(messageSizeInWords - 1, 11);\n      modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);\n    }\n\n    return modeMessage;\n  };\n\n  Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {\n    var center = Integer.truncDivision(matrixSize, 2);\n\n    if (compact) {\n      for (var i\n      /*int*/\n      = 0; i < 7; i++) {\n        var offset = center - 3 + i;\n\n        if (modeMessage.get(i)) {\n          matrix.set(offset, center - 5);\n        }\n\n        if (modeMessage.get(i + 7)) {\n          matrix.set(center + 5, offset);\n        }\n\n        if (modeMessage.get(20 - i)) {\n          matrix.set(offset, center + 5);\n        }\n\n        if (modeMessage.get(27 - i)) {\n          matrix.set(center - 5, offset);\n        }\n      }\n    } else {\n      for (var i\n      /*int*/\n      = 0; i < 10; i++) {\n        var offset = center - 5 + i + Integer.truncDivision(i, 5);\n\n        if (modeMessage.get(i)) {\n          matrix.set(offset, center - 7);\n        }\n\n        if (modeMessage.get(i + 10)) {\n          matrix.set(center + 7, offset);\n        }\n\n        if (modeMessage.get(29 - i)) {\n          matrix.set(offset, center + 7);\n        }\n\n        if (modeMessage.get(39 - i)) {\n          matrix.set(center - 7, offset);\n        }\n      }\n    }\n  };\n\n  Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {\n    var e_1, _a; // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n\n\n    var messageSizeInWords = bitArray.getSize() / wordSize;\n    var rs = new ReedSolomonEncoder(Encoder.getGF(wordSize));\n    var totalWords = Integer.truncDivision(totalBits, wordSize);\n    var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);\n    rs.encode(messageWords, totalWords - messageSizeInWords);\n    var startPad = totalBits % wordSize;\n    var messageBits = new BitArray();\n    messageBits.appendBits(0, startPad);\n\n    try {\n      for (var _b = __values(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var messageWord = _c.value\n        /*: int*/\n        ;\n        messageBits.appendBits(messageWord, wordSize);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return messageBits;\n  };\n\n  Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {\n    var message = new Int32Array(totalWords);\n    var i;\n    var n;\n\n    for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n      var value = 0;\n\n      for (var j\n      /*int*/\n      = 0; j < wordSize; j++) {\n        value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;\n      }\n\n      message[i] = value;\n    }\n\n    return message;\n  };\n\n  Encoder.getGF = function (wordSize) {\n    switch (wordSize) {\n      case 4:\n        return GenericGF.AZTEC_PARAM;\n\n      case 6:\n        return GenericGF.AZTEC_DATA_6;\n\n      case 8:\n        return GenericGF.AZTEC_DATA_8;\n\n      case 10:\n        return GenericGF.AZTEC_DATA_10;\n\n      case 12:\n        return GenericGF.AZTEC_DATA_12;\n\n      default:\n        throw new IllegalArgumentException('Unsupported word size ' + wordSize);\n    }\n  };\n\n  Encoder.stuffBits = function (bits, wordSize) {\n    var out = new BitArray();\n    var n = bits.getSize();\n    var mask = (1 << wordSize) - 2;\n\n    for (var i\n    /*int*/\n    = 0; i < n; i += wordSize) {\n      var word = 0;\n\n      for (var j\n      /*int*/\n      = 0; j < wordSize; j++) {\n        if (i + j >= n || bits.get(i + j)) {\n          word |= 1 << wordSize - 1 - j;\n        }\n      }\n\n      if ((word & mask) === mask) {\n        out.appendBits(word & mask, wordSize);\n        i--;\n      } else if ((word & mask) === 0) {\n        out.appendBits(word | 1, wordSize);\n        i--;\n      } else {\n        out.appendBits(word, wordSize);\n      }\n    }\n\n    return out;\n  };\n\n  Encoder.totalBitsInLayer = function (layers, compact) {\n    return ((compact ? 88 : 112) + 16 * layers) * layers;\n  };\n\n  Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n\n  Encoder.DEFAULT_AZTEC_LAYERS = 0;\n  Encoder.MAX_NB_BITS = 32;\n  Encoder.MAX_NB_BITS_COMPACT = 4;\n  Encoder.WORD_SIZE = Int32Array.from([4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]);\n  return Encoder;\n}();\n\nexport default Encoder;","map":{"version":3,"sources":["../../../../../src/core/aztec/encoder/Encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport BitArray from '../../common/BitArray';\nimport IllegalArgumentException from '../../IllegalArgumentException';\nimport StringUtils from '../../common/StringUtils';\nimport BitMatrix from '../../common/BitMatrix';\nimport AztecCode from './AztecCode';\nimport ReedSolomonEncoder from '../../common/reedsolomon/ReedSolomonEncoder';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport Integer from '../../util/Integer';\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// package com.google.zxing.aztec.encoder;\n// import com.google.zxing.common.BitArray;\n// import com.google.zxing.common.BitMatrix;\n// import com.google.zxing.common.reedsolomon.GenericGF;\n// import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n/**\n * Generates Aztec 2D barcodes.\n *\n * @author Rustam Abdullaev\n */\nvar Encoder = /** @class */ (function () {\n    function Encoder() {\n    }\n    /**\n     * Encodes the given binary content as an Aztec symbol\n     *\n     * @param data input data string\n     * @return Aztec symbol matrix with metadata\n     */\n    Encoder.encodeBytes = function (data) {\n        return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);\n    };\n    /**\n     * Encodes the given binary content as an Aztec symbol\n     *\n     * @param data input data string\n     * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n     *                      a minimum of 23% + 3 words is recommended)\n     * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n     * @return Aztec symbol matrix with metadata\n     */\n    Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {\n        // High-level encode\n        var bits = new HighLevelEncoder(data).encode();\n        // stuff bits and choose symbol size\n        var eccBits = Integer.truncDivision((bits.getSize() * minECCPercent), 100) + 11;\n        var totalSizeBits = bits.getSize() + eccBits;\n        var compact;\n        var layers;\n        var totalBitsInLayer;\n        var wordSize;\n        var stuffedBits;\n        if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {\n            compact = userSpecifiedLayers < 0;\n            layers = Math.abs(userSpecifiedLayers);\n            if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {\n                throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));\n            }\n            totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n            wordSize = Encoder.WORD_SIZE[layers];\n            var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n            stuffedBits = Encoder.stuffBits(bits, wordSize);\n            if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n                throw new IllegalArgumentException('Data to large for user specified layer');\n            }\n            if (compact && stuffedBits.getSize() > wordSize * 64) {\n                // Compact format only allows 64 data words, though C4 can hold more words than that\n                throw new IllegalArgumentException('Data to large for user specified layer');\n            }\n        }\n        else {\n            wordSize = 0;\n            stuffedBits = null;\n            // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n            // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n            // is the same size, but has more data.\n            for (var i /*int*/ = 0;; i++) {\n                if (i > Encoder.MAX_NB_BITS) {\n                    throw new IllegalArgumentException('Data too large for an Aztec code');\n                }\n                compact = i <= 3;\n                layers = compact ? i + 1 : i;\n                totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n                if (totalSizeBits > totalBitsInLayer) {\n                    continue;\n                }\n                // [Re]stuff the bits if this is the first opportunity, or if the\n                // wordSize has changed\n                if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {\n                    wordSize = Encoder.WORD_SIZE[layers];\n                    stuffedBits = Encoder.stuffBits(bits, wordSize);\n                }\n                var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                if (compact && stuffedBits.getSize() > wordSize * 64) {\n                    // Compact format only allows 64 data words, though C4 can hold more words than that\n                    continue;\n                }\n                if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n                    break;\n                }\n            }\n        }\n        var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n        // generate mode message\n        var messageSizeInWords = stuffedBits.getSize() / wordSize;\n        var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords);\n        // allocate symbol\n        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n        var alignmentMap = new Int32Array(baseMatrixSize);\n        var matrixSize;\n        if (compact) {\n            // no alignment marks in compact mode, alignmentMap is a no-op\n            matrixSize = baseMatrixSize;\n            for (var i /*int*/ = 0; i < alignmentMap.length; i++) {\n                alignmentMap[i] = i;\n            }\n        }\n        else {\n            matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);\n            var origCenter = Integer.truncDivision(baseMatrixSize, 2);\n            var center = Integer.truncDivision(matrixSize, 2);\n            for (var i /*int*/ = 0; i < origCenter; i++) {\n                var newOffset = i + Integer.truncDivision(i, 15);\n                alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                alignmentMap[origCenter + i] = center + newOffset + 1;\n            }\n        }\n        var matrix = new BitMatrix(matrixSize);\n        // draw data bits\n        for (var i /*int*/ = 0, rowOffset = 0; i < layers; i++) {\n            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n            for (var j /*int*/ = 0; j < rowSize; j++) {\n                var columnOffset = j * 2;\n                for (var k /*int*/ = 0; k < 2; k++) {\n                    if (messageBits.get(rowOffset + columnOffset + k)) {\n                        matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n                        matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n                    }\n                    if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n                    }\n                }\n            }\n            rowOffset += rowSize * 8;\n        }\n        // draw mode message\n        Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n        // draw alignment marks\n        if (compact) {\n            Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n        }\n        else {\n            Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n            for (var i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n                for (var k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n                    matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n                    matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n                    matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n                    matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n                }\n            }\n        }\n        var aztec = new AztecCode();\n        aztec.setCompact(compact);\n        aztec.setSize(matrixSize);\n        aztec.setLayers(layers);\n        aztec.setCodeWords(messageSizeInWords);\n        aztec.setMatrix(matrix);\n        return aztec;\n    };\n    Encoder.drawBullsEye = function (matrix, center, size) {\n        for (var i /*int*/ = 0; i < size; i += 2) {\n            for (var j /*int*/ = center - i; j <= center + i; j++) {\n                matrix.set(j, center - i);\n                matrix.set(j, center + i);\n                matrix.set(center - i, j);\n                matrix.set(center + i, j);\n            }\n        }\n        matrix.set(center - size, center - size);\n        matrix.set(center - size + 1, center - size);\n        matrix.set(center - size, center - size + 1);\n        matrix.set(center + size, center - size);\n        matrix.set(center + size, center - size + 1);\n        matrix.set(center + size, center + size - 1);\n    };\n    Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {\n        var modeMessage = new BitArray();\n        if (compact) {\n            modeMessage.appendBits(layers - 1, 2);\n            modeMessage.appendBits(messageSizeInWords - 1, 6);\n            modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);\n        }\n        else {\n            modeMessage.appendBits(layers - 1, 5);\n            modeMessage.appendBits(messageSizeInWords - 1, 11);\n            modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);\n        }\n        return modeMessage;\n    };\n    Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {\n        var center = Integer.truncDivision(matrixSize, 2);\n        if (compact) {\n            for (var i /*int*/ = 0; i < 7; i++) {\n                var offset = center - 3 + i;\n                if (modeMessage.get(i)) {\n                    matrix.set(offset, center - 5);\n                }\n                if (modeMessage.get(i + 7)) {\n                    matrix.set(center + 5, offset);\n                }\n                if (modeMessage.get(20 - i)) {\n                    matrix.set(offset, center + 5);\n                }\n                if (modeMessage.get(27 - i)) {\n                    matrix.set(center - 5, offset);\n                }\n            }\n        }\n        else {\n            for (var i /*int*/ = 0; i < 10; i++) {\n                var offset = center - 5 + i + Integer.truncDivision(i, 5);\n                if (modeMessage.get(i)) {\n                    matrix.set(offset, center - 7);\n                }\n                if (modeMessage.get(i + 10)) {\n                    matrix.set(center + 7, offset);\n                }\n                if (modeMessage.get(29 - i)) {\n                    matrix.set(offset, center + 7);\n                }\n                if (modeMessage.get(39 - i)) {\n                    matrix.set(center - 7, offset);\n                }\n            }\n        }\n    };\n    Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {\n        var e_1, _a;\n        // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n        var messageSizeInWords = bitArray.getSize() / wordSize;\n        var rs = new ReedSolomonEncoder(Encoder.getGF(wordSize));\n        var totalWords = Integer.truncDivision(totalBits, wordSize);\n        var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);\n        rs.encode(messageWords, totalWords - messageSizeInWords);\n        var startPad = totalBits % wordSize;\n        var messageBits = new BitArray();\n        messageBits.appendBits(0, startPad);\n        try {\n            for (var _b = __values(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var messageWord = _c.value /*: int*/;\n                messageBits.appendBits(messageWord, wordSize);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return messageBits;\n    };\n    Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {\n        var message = new Int32Array(totalWords);\n        var i;\n        var n;\n        for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n            var value = 0;\n            for (var j /*int*/ = 0; j < wordSize; j++) {\n                value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;\n            }\n            message[i] = value;\n        }\n        return message;\n    };\n    Encoder.getGF = function (wordSize) {\n        switch (wordSize) {\n            case 4:\n                return GenericGF.AZTEC_PARAM;\n            case 6:\n                return GenericGF.AZTEC_DATA_6;\n            case 8:\n                return GenericGF.AZTEC_DATA_8;\n            case 10:\n                return GenericGF.AZTEC_DATA_10;\n            case 12:\n                return GenericGF.AZTEC_DATA_12;\n            default:\n                throw new IllegalArgumentException('Unsupported word size ' + wordSize);\n        }\n    };\n    Encoder.stuffBits = function (bits, wordSize) {\n        var out = new BitArray();\n        var n = bits.getSize();\n        var mask = (1 << wordSize) - 2;\n        for (var i /*int*/ = 0; i < n; i += wordSize) {\n            var word = 0;\n            for (var j /*int*/ = 0; j < wordSize; j++) {\n                if (i + j >= n || bits.get(i + j)) {\n                    word |= 1 << (wordSize - 1 - j);\n                }\n            }\n            if ((word & mask) === mask) {\n                out.appendBits(word & mask, wordSize);\n                i--;\n            }\n            else if ((word & mask) === 0) {\n                out.appendBits(word | 1, wordSize);\n                i--;\n            }\n            else {\n                out.appendBits(word, wordSize);\n            }\n        }\n        return out;\n    };\n    Encoder.totalBitsInLayer = function (layers, compact) {\n        return ((compact ? 88 : 112) + 16 * layers) * layers;\n    };\n    Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n    Encoder.DEFAULT_AZTEC_LAYERS = 0;\n    Encoder.MAX_NB_BITS = 32;\n    Encoder.MAX_NB_BITS_COMPACT = 4;\n    Encoder.WORD_SIZE = Int32Array.from([\n        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n        12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n    ]);\n    return Encoder;\n}());\nexport default Encoder;\n//# sourceMappingURL=Encoder.js.map"]},"metadata":{},"sourceType":"module"}