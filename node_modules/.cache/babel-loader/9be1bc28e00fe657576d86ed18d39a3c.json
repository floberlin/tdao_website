{"ast":null,"code":"import BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\nimport System from '../util/System';\nimport Decoder from './decoder/Decoder';\nimport Detector from './detector/Detector';\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\n\nvar DataMatrixReader = function () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder();\n  }\n  /**\n   * Locates and decodes a Data Matrix code in an image.\n   *\n   * @return a String representing the content encoded by the Data Matrix code\n   * @throws NotFoundException if a Data Matrix code cannot be found\n   * @throws FormatException if a Data Matrix code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n\n\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n\n    var decoderResult;\n    var points;\n\n    if (hints != null && hints.has(DecodeHintType.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat.DATA_MATRIX, System.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n\n    var ecLevel = decoderResult.getECLevel();\n\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n\n    return result;\n  }; // @Override\n\n\n  DataMatrixReader.prototype.reset = function () {// do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n   */\n\n\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException();\n    }\n\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    } // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n\n\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge; // Now just read off the bits\n\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n\n    return bits;\n  };\n\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n\n    if (x === width) {\n      throw new NotFoundException();\n    }\n\n    var moduleSize = x - leftTopBlack[0];\n\n    if (moduleSize === 0) {\n      throw new NotFoundException();\n    }\n\n    return moduleSize;\n  };\n\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\n\nexport default DataMatrixReader;","map":{"version":3,"sources":["../../../../src/core/datamatrix/DataMatrixReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\nimport System from '../util/System';\nimport Decoder from './decoder/Decoder';\nimport Detector from './detector/Detector';\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */ (function () {\n    function DataMatrixReader() {\n        this.decoder = new Decoder();\n    }\n    /**\n     * Locates and decodes a Data Matrix code in an image.\n     *\n     * @return a String representing the content encoded by the Data Matrix code\n     * @throws NotFoundException if a Data Matrix code cannot be found\n     * @throws FormatException if a Data Matrix code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    // @Override\n    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    //   return decode(image, null);\n    // }\n    // @Override\n    DataMatrixReader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var decoderResult;\n        var points;\n        if (hints != null && hints.has(DecodeHintType.PURE_BARCODE)) {\n            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decode(bits);\n            points = DataMatrixReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector(image.getBlackMatrix()).detect();\n            decoderResult = this.decoder.decode(detectorResult.getBits());\n            points = detectorResult.getPoints();\n        }\n        var rawBytes = decoderResult.getRawBytes();\n        var result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat.DATA_MATRIX, System.currentTimeMillis());\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n            result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n            result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        return result;\n    };\n    // @Override\n    DataMatrixReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n     */\n    DataMatrixReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack == null || rightBottomBlack == null) {\n            throw new NotFoundException();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        var matrixWidth = (right - left + 1) / moduleSize;\n        var matrixHeight = (bottom - top + 1) / moduleSize;\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = moduleSize / 2;\n        top += nudge;\n        left += nudge;\n        // Now just read off the bits\n        var bits = new BitMatrix(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + y * moduleSize;\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + x * moduleSize, iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        while (x < width && image.get(x, y)) {\n            x++;\n        }\n        if (x === width) {\n            throw new NotFoundException();\n        }\n        var moduleSize = x - leftTopBlack[0];\n        if (moduleSize === 0) {\n            throw new NotFoundException();\n        }\n        return moduleSize;\n    };\n    DataMatrixReader.NO_POINTS = [];\n    return DataMatrixReader;\n}());\nexport default DataMatrixReader;\n//# sourceMappingURL=DataMatrixReader.js.map"]},"metadata":{},"sourceType":"module"}