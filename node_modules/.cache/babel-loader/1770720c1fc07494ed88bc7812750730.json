{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t, i, s, e;\n\nconst o = globalThis.trustedTypes,\n      l = o ? o.createPolicy(\"lit-html\", {\n  createHTML: t => t\n}) : void 0,\n      n = `lit$${(Math.random() + \"\").slice(9)}$`,\n      h = \"?\" + n,\n      r = `<${h}>`,\n      u = document,\n      c = (t = \"\") => u.createComment(t),\n      d = t => null === t || \"object\" != typeof t && \"function\" != typeof t,\n      v = Array.isArray,\n      a = t => {\n  var i;\n  return v(t) || \"function\" == typeof (null === (i = t) || void 0 === i ? void 0 : i[Symbol.iterator]);\n},\n      f = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n      _ = /-->/g,\n      m = />/g,\n      p = />|[ \t\\n\f\\r](?:([^\\s\"'>=/]+)([ \t\\n\f\\r]*=[ \t\\n\f\\r]*(?:[^ \t\\n\f\\r\"'`<>=]|(\"|')|))|$)/g,\n      $ = /'/g,\n      g = /\"/g,\n      y = /^(?:script|style|textarea)$/i,\n      b = t => (i, ...s) => ({\n  _$litType$: t,\n  strings: i,\n  values: s\n}),\n      T = b(1),\n      x = b(2),\n      w = Symbol.for(\"lit-noChange\"),\n      A = Symbol.for(\"lit-nothing\"),\n      P = new WeakMap(),\n      V = (t, i, s) => {\n  var e, o;\n  const l = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;\n  let n = l._$litPart$;\n\n  if (void 0 === n) {\n    const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;\n    l._$litPart$ = n = new C(i.insertBefore(c(), t), t, void 0, s);\n  }\n\n  return n.I(t), n;\n},\n      E = u.createTreeWalker(u, 129, null, !1),\n      M = (t, i) => {\n  const s = t.length - 1,\n        e = [];\n  let o,\n      h = 2 === i ? \"<svg>\" : \"\",\n      u = f;\n\n  for (let i = 0; i < s; i++) {\n    const s = t[i];\n    let l,\n        c,\n        d = -1,\n        v = 0;\n\n    for (; v < s.length && (u.lastIndex = v, c = u.exec(s), null !== c);) v = u.lastIndex, u === f ? \"!--\" === c[1] ? u = _ : void 0 !== c[1] ? u = m : void 0 !== c[2] ? (y.test(c[2]) && (o = RegExp(\"</\" + c[2], \"g\")), u = p) : void 0 !== c[3] && (u = p) : u === p ? \">\" === c[0] ? (u = null != o ? o : f, d = -1) : void 0 === c[1] ? d = -2 : (d = u.lastIndex - c[2].length, l = c[1], u = void 0 === c[3] ? p : '\"' === c[3] ? g : $) : u === g || u === $ ? u = p : u === _ || u === m ? u = f : (u = p, o = void 0);\n\n    const a = u === p && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    h += u === f ? s + r : d >= 0 ? (e.push(l), s.slice(0, d) + \"$lit$\" + s.slice(d) + n + a) : s + n + (-2 === d ? (e.push(void 0), i) : a);\n  }\n\n  const c = h + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\");\n  return [void 0 !== l ? l.createHTML(c) : c, e];\n};\n\nclass N {\n  constructor({\n    strings: t,\n    _$litType$: i\n  }, s) {\n    let e;\n    this.parts = [];\n    let l = 0,\n        r = 0;\n    const u = t.length - 1,\n          d = this.parts,\n          [v, a] = M(t, i);\n\n    if (this.el = N.createElement(v, s), E.currentNode = this.el.content, 2 === i) {\n      const t = this.el.content,\n            i = t.firstChild;\n      i.remove(), t.append(...i.childNodes);\n    }\n\n    for (; null !== (e = E.nextNode()) && d.length < u;) {\n      if (1 === e.nodeType) {\n        if (e.hasAttributes()) {\n          const t = [];\n\n          for (const i of e.getAttributeNames()) if (i.endsWith(\"$lit$\") || i.startsWith(n)) {\n            const s = a[r++];\n\n            if (t.push(i), void 0 !== s) {\n              const t = e.getAttribute(s.toLowerCase() + \"$lit$\").split(n),\n                    i = /([.?@])?(.*)/.exec(s);\n              d.push({\n                type: 1,\n                index: l,\n                name: i[2],\n                strings: t,\n                ctor: \".\" === i[1] ? I : \"?\" === i[1] ? L : \"@\" === i[1] ? R : H\n              });\n            } else d.push({\n              type: 6,\n              index: l\n            });\n          }\n\n          for (const i of t) e.removeAttribute(i);\n        }\n\n        if (y.test(e.tagName)) {\n          const t = e.textContent.split(n),\n                i = t.length - 1;\n\n          if (i > 0) {\n            e.textContent = o ? o.emptyScript : \"\";\n\n            for (let s = 0; s < i; s++) e.append(t[s], c()), E.nextNode(), d.push({\n              type: 2,\n              index: ++l\n            });\n\n            e.append(t[i], c());\n          }\n        }\n      } else if (8 === e.nodeType) if (e.data === h) d.push({\n        type: 2,\n        index: l\n      });else {\n        let t = -1;\n\n        for (; -1 !== (t = e.data.indexOf(n, t + 1));) d.push({\n          type: 7,\n          index: l\n        }), t += n.length - 1;\n      }\n\n      l++;\n    }\n  }\n\n  static createElement(t, i) {\n    const s = u.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n\n}\n\nfunction S(t, i, s = t, e) {\n  var o, l, n, h;\n  if (i === w) return i;\n  let r = void 0 !== e ? null === (o = s.Σi) || void 0 === o ? void 0 : o[e] : s.Σo;\n  const u = d(i) ? void 0 : i._$litDirective$;\n  return (null == r ? void 0 : r.constructor) !== u && (null === (l = null == r ? void 0 : r.O) || void 0 === l || l.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r.T(t, s, e)), void 0 !== e ? (null !== (n = (h = s).Σi) && void 0 !== n ? n : h.Σi = [])[e] = r : s.Σo = r), void 0 !== r && (i = S(t, r.S(t, i.values), r, e)), i;\n}\n\nclass k {\n  constructor(t, i) {\n    this.l = [], this.N = void 0, this.D = t, this.M = i;\n  }\n\n  u(t) {\n    var i;\n    const {\n      el: {\n        content: s\n      },\n      parts: e\n    } = this.D,\n          o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : u).importNode(s, !0);\n    E.currentNode = o;\n    let l = E.nextNode(),\n        n = 0,\n        h = 0,\n        r = e[0];\n\n    for (; void 0 !== r;) {\n      if (n === r.index) {\n        let i;\n        2 === r.type ? i = new C(l, l.nextSibling, this, t) : 1 === r.type ? i = new r.ctor(l, r.name, r.strings, this, t) : 6 === r.type && (i = new z(l, this, t)), this.l.push(i), r = e[++h];\n      }\n\n      n !== (null == r ? void 0 : r.index) && (l = E.nextNode(), n++);\n    }\n\n    return o;\n  }\n\n  v(t) {\n    let i = 0;\n\n    for (const s of this.l) void 0 !== s && (void 0 !== s.strings ? (s.I(t, s, i), i += s.strings.length - 2) : s.I(t[i])), i++;\n  }\n\n}\n\nclass C {\n  constructor(t, i, s, e) {\n    this.type = 2, this.N = void 0, this.A = t, this.B = i, this.M = s, this.options = e;\n  }\n\n  setConnected(t) {\n    var i;\n    null === (i = this.P) || void 0 === i || i.call(this, t);\n  }\n\n  get parentNode() {\n    return this.A.parentNode;\n  }\n\n  get startNode() {\n    return this.A;\n  }\n\n  get endNode() {\n    return this.B;\n  }\n\n  I(t, i = this) {\n    t = S(this, t, i), d(t) ? t === A || null == t || \"\" === t ? (this.H !== A && this.R(), this.H = A) : t !== this.H && t !== w && this.m(t) : void 0 !== t._$litType$ ? this._(t) : void 0 !== t.nodeType ? this.$(t) : a(t) ? this.g(t) : this.m(t);\n  }\n\n  k(t, i = this.B) {\n    return this.A.parentNode.insertBefore(t, i);\n  }\n\n  $(t) {\n    this.H !== t && (this.R(), this.H = this.k(t));\n  }\n\n  m(t) {\n    const i = this.A.nextSibling;\n    null !== i && 3 === i.nodeType && (null === this.B ? null === i.nextSibling : i === this.B.previousSibling) ? i.data = t : this.$(u.createTextNode(t)), this.H = t;\n  }\n\n  _(t) {\n    var i;\n    const {\n      values: s,\n      _$litType$: e\n    } = t,\n          o = \"number\" == typeof e ? this.C(t) : (void 0 === e.el && (e.el = N.createElement(e.h, this.options)), e);\n    if ((null === (i = this.H) || void 0 === i ? void 0 : i.D) === o) this.H.v(s);else {\n      const t = new k(o, this),\n            i = t.u(this.options);\n      t.v(s), this.$(i), this.H = t;\n    }\n  }\n\n  C(t) {\n    let i = P.get(t.strings);\n    return void 0 === i && P.set(t.strings, i = new N(t)), i;\n  }\n\n  g(t) {\n    v(this.H) || (this.H = [], this.R());\n    const i = this.H;\n    let s,\n        e = 0;\n\n    for (const o of t) e === i.length ? i.push(s = new C(this.k(c()), this.k(c()), this, this.options)) : s = i[e], s.I(o), e++;\n\n    e < i.length && (this.R(s && s.B.nextSibling, e), i.length = e);\n  }\n\n  R(t = this.A.nextSibling, i) {\n    var s;\n\n    for (null === (s = this.P) || void 0 === s || s.call(this, !1, !0, i); t && t !== this.B;) {\n      const i = t.nextSibling;\n      t.remove(), t = i;\n    }\n  }\n\n}\n\nclass H {\n  constructor(t, i, s, e, o) {\n    this.type = 1, this.H = A, this.N = void 0, this.V = void 0, this.element = t, this.name = i, this.M = e, this.options = o, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this.H = Array(s.length - 1).fill(A), this.strings = s) : this.H = A;\n  }\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  I(t, i = this, s, e) {\n    const o = this.strings;\n    let l = !1;\n    if (void 0 === o) t = S(this, t, i, 0), l = !d(t) || t !== this.H && t !== w, l && (this.H = t);else {\n      const e = t;\n      let n, h;\n\n      for (t = o[0], n = 0; n < o.length - 1; n++) h = S(this, e[s + n], i, n), h === w && (h = this.H[n]), l || (l = !d(h) || h !== this.H[n]), h === A ? t = A : t !== A && (t += (null != h ? h : \"\") + o[n + 1]), this.H[n] = h;\n    }\n    l && !e && this.W(t);\n  }\n\n  W(t) {\n    t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : \"\");\n  }\n\n}\n\nclass I extends H {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n\n  W(t) {\n    this.element[this.name] = t === A ? void 0 : t;\n  }\n\n}\n\nclass L extends H {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n\n  W(t) {\n    t && t !== A ? this.element.setAttribute(this.name, \"\") : this.element.removeAttribute(this.name);\n  }\n\n}\n\nclass R extends H {\n  constructor() {\n    super(...arguments), this.type = 5;\n  }\n\n  I(t, i = this) {\n    var s;\n    if ((t = null !== (s = S(this, t, i, 0)) && void 0 !== s ? s : A) === w) return;\n    const e = this.H,\n          o = t === A && e !== A || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,\n          l = t !== A && (e === A || o);\n    o && this.element.removeEventListener(this.name, this, e), l && this.element.addEventListener(this.name, this, t), this.H = t;\n  }\n\n  handleEvent(t) {\n    var i, s;\n    \"function\" == typeof this.H ? this.H.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this.H.handleEvent(t);\n  }\n\n}\n\nclass z {\n  constructor(t, i, s) {\n    this.element = t, this.type = 6, this.N = void 0, this.V = void 0, this.M = i, this.options = s;\n  }\n\n  I(t) {\n    S(this, t);\n  }\n\n}\n\nconst Z = {\n  Z: \"$lit$\",\n  U: n,\n  Y: h,\n  q: 1,\n  X: M,\n  tt: k,\n  it: a,\n  st: S,\n  et: C,\n  ot: H,\n  nt: L,\n  rt: R,\n  lt: I,\n  ht: z\n};\nnull === (i = (t = globalThis).litHtmlPlatformSupport) || void 0 === i || i.call(t, N, C), (null !== (s = (e = globalThis).litHtmlVersions) && void 0 !== s ? s : e.litHtmlVersions = []).push(\"2.0.0-rc.3\");\nexport { Z as _Σ, T as html, w as noChange, A as nothing, V as render, x as svg };","map":{"version":3,"sources":["src/lit-html.ts"],"names":["trustedTypes","globalThis","policy","createPolicy","createHTML","s","undefined","marker","String","Math","random","slice","markerMatch","nodeMarker","d","document","createMarker","v","createComment","isPrimitive","value","isArray","Array","isIterable","Symbol","iterator","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","_$litType$","strings","values","html","svg","noChange","for","nothing","templateCache","WeakMap","render","container","options","partOwnerNode","renderBefore","part","_$litPart$","endNode","ChildPart","insertBefore","_$setValue","walker","createTreeWalker","getTemplateHtml","type","l","length","attrNames","rawTextEndRegex","regex","i","attrNameEndIndex","attrName","lastIndex","match","exec","test","RegExp","end","startsWith","push","htmlResult","Template","this","[object Object]","node","nodeIndex","attrNameIndex","partCount","parts","el","createElement","currentNode","content","svgElement","firstChild","remove","append","childNodes","nextNode","nodeType","hasAttributes","attrsToRemove","name","getAttributeNames","endsWith","realName","getAttribute","toLowerCase","statics","split","m","index","ctor","PropertyPart","BooleanAttributePart","EventPart","AttributePart","removeAttribute","tagName","textContent","emptyScript","data","indexOf","_options","innerHTML","resolveDirective","parent","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","_$litDirective$","constructor","_$setDirectiveConnected","_$initialize","_$resolve","TemplateInstance","template","_$template","_$parent","fragment","creationScope","importNode","partIndex","templatePart","nextSibling","ElementPart","_parts","startNode","_$startNode","_$endNode","isConnected","_$setChildPartConnected","parentNode","directiveParent","_$committedValue","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","ref","_insert","previousSibling","createTextNode","result","_$getTemplate","h","_update","instance","_clone","get","set","itemParts","itemPart","item","start","from","n","element","fill","valueIndex","noCommit","change","_commitValue","setAttribute","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","event","call","host","handleEvent","_Σ","Z","U","Y","q","X","tt","it","st","et","ot","nt","rt","lt","ht"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\nconst trustedTypes = ((globalThis as unknown) as Partial<Window>).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult<T extends ResultType = ResultType> = {\n  _$litType$: T;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  _$litType$: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  h: TrustedHTML;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = <T extends ResultType>(_$litType$: T) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult<T> => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart$;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart$ = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [TrustedHTML, Array<string | undefined>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string | undefined> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s +\n          marker +\n          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [\n    policy !== undefined\n      ? policy.createHTML(htmlResult)\n      : ((htmlResult as unknown) as TrustedHTML),\n    attrNames,\n  ];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n  /** @internal */\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this.el.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (\n              name.endsWith(boundAttributeSuffix) ||\n              name.startsWith(marker)\n            ) {\n              const realName = attrNames[attrNameIndex++];\n              attrsToRemove.push(name);\n              if (realName !== undefined) {\n                // Lowercase for case-sensitive SVG attributes like viewBox\n                const value = (node as Element).getAttribute(\n                  realName.toLowerCase() + boundAttributeSuffix\n                )!;\n                const statics = value.split(marker);\n                const m = /([.?@])?(.*)/.exec(realName)!;\n                parts.push({\n                  type: ATTRIBUTE_PART,\n                  index: nodeIndex,\n                  name: m[2],\n                  strings: statics,\n                  ctor:\n                    m[1] === '.'\n                      ? PropertyPart\n                      : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                      ? EventPart\n                      : AttributePart,\n                });\n              } else {\n                parts.push({\n                  type: ELEMENT_PART,\n                  index: nodeIndex,\n                });\n              }\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? ((trustedTypes.emptyScript as unknown) as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = (html as unknown) as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[\n        attributeIndex\n      ] = currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex\n    );\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  /** @internal */\n  readonly ctor: typeof AttributePart;\n  /** @internal */\n  readonly strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `AsyncDirectives` contained\n   * within this part and runs their `disconnected` or `reconnected`, according\n   * to the `isConnected` argument.\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    return wrap(this._$startNode).parentNode!;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = wrap(this._$startNode).nextSibling;\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? wrap(node).nextSibling === null\n        : node === wrap(this._$endNode).previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult\n  ): void {\n    const {values, _$litType$} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof _$litType$ === 'number'\n        ? this._$getTemplate(result as TemplateResult)\n        : (_$litType$.el === undefined &&\n            (_$litType$.el = Template.createElement(\n              _$litType$.h,\n              this.options\n            )),\n          _$litType$);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: TemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/lit/lit/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n}\n\nexport type {AttributePart};\nclass AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      (wrap(this.element) as Element).setAttribute(this.name, '');\n    } else {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this.element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _Σ object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _Σ = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-rc.3');\n"]},"metadata":{},"sourceType":"module"}