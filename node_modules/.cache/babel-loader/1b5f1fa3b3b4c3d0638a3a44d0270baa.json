{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport OneDReader from './OneDReader';\nimport NotFoundException from '../NotFoundException';\nimport FormatException from '../FormatException';\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\n\nvar AbstractUPCEANReader = function (_super) {\n  __extends(AbstractUPCEANReader, _super);\n\n  function AbstractUPCEANReader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.decodeRowStringBuffer = '';\n    return _this;\n  } // private final UPCEANExtensionSupport extensionReader;\n  // private final EANManufacturerOrgSupport eanManSupport;\n\n  /*\n  protected UPCEANReader() {\n      decodeRowStringBuffer = new StringBuilder(20);\n      extensionReader = new UPCEANExtensionSupport();\n      eanManSupport = new EANManufacturerOrgSupport();\n  }\n  */\n\n\n  AbstractUPCEANReader.findStartGuardPattern = function (row) {\n    var foundStart = false;\n    var startRange;\n    var nextStart = 0;\n    var counters = Int32Array.from([0, 0, 0]);\n\n    while (!foundStart) {\n      counters = Int32Array.from([0, 0, 0]);\n      startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n      var start = startRange[0];\n      nextStart = startRange[1];\n      var quietStart = start - (nextStart - start);\n\n      if (quietStart >= 0) {\n        foundStart = row.isRange(quietStart, start, false);\n      }\n    }\n\n    return startRange;\n  };\n\n  AbstractUPCEANReader.checkChecksum = function (s) {\n    return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n\n  AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n\n  AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n\n      sum += digit;\n    }\n\n    sum *= 3;\n\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n\n      sum += digit;\n    }\n\n    return (1000 - sum) % 10;\n  };\n\n  AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n    return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n  /**\n   * @throws NotFoundException\n   */\n\n\n  AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {\n    return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n  };\n  /**\n   * @param row row of black/white values to search\n   * @param rowOffset position to start search\n   * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n   * pixel counts, otherwise, it is interpreted as black/white/black/...\n   * @param pattern pattern of counts of number of black and white pixels that are being\n   * searched for as a pattern\n   * @param counters array of counters, as long as pattern, to re-use\n   * @return start/end horizontal offset of guard pattern, as an array of two ints\n   * @throws NotFoundException if pattern is not found\n   */\n\n\n  AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n    var width = row.getSize();\n    rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    var patternLength = pattern.length;\n    var isWhite = whiteFirst;\n\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n            return Int32Array.from([patternStart, x]);\n          }\n\n          patternStart += counters[0] + counters[1];\n          var slice = counters.slice(2, counters.length - 1);\n\n          for (var i = 0; i < counterPosition - 1; i++) {\n            counters[i] = slice[i];\n          }\n\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException();\n  };\n\n  AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n    this.recordPattern(row, rowOffset, counters);\n    var bestVariance = this.MAX_AVG_VARIANCE;\n    var bestMatch = -1;\n    var max = patterns.length;\n\n    for (var i = 0; i < max; i++) {\n      var pattern = patterns[i];\n      var variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      }\n    }\n\n    if (bestMatch >= 0) {\n      return bestMatch;\n    } else {\n      throw new NotFoundException();\n    }\n  }; // These two values are critical for determining how permissive the decoding will be.\n  // We've arrived at these values through a lot of trial and error. Setting them any higher\n  // lets false positives creep in quickly.\n\n\n  AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n  AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n  /**\n   * Start/end guard pattern.\n   */\n\n  AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n  /**\n   * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n   */\n\n  AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n  /**\n   * end guard pattern.\n   */\n\n  AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n  /**\n   * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n   */\n\n  AbstractUPCEANReader.L_PATTERNS = [Int32Array.from([3, 2, 1, 1]), Int32Array.from([2, 2, 2, 1]), Int32Array.from([2, 1, 2, 2]), Int32Array.from([1, 4, 1, 1]), Int32Array.from([1, 1, 3, 2]), Int32Array.from([1, 2, 3, 1]), Int32Array.from([1, 1, 1, 4]), Int32Array.from([1, 3, 1, 2]), Int32Array.from([1, 2, 1, 3]), Int32Array.from([3, 1, 1, 2])];\n  return AbstractUPCEANReader;\n}(OneDReader);\n\nexport default AbstractUPCEANReader;","map":{"version":3,"sources":["../../../../src/core/oned/AbstractUPCEANReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport OneDReader from './OneDReader';\nimport NotFoundException from '../NotFoundException';\nimport FormatException from '../FormatException';\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar AbstractUPCEANReader = /** @class */ (function (_super) {\n    __extends(AbstractUPCEANReader, _super);\n    function AbstractUPCEANReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.decodeRowStringBuffer = '';\n        return _this;\n    }\n    // private final UPCEANExtensionSupport extensionReader;\n    // private final EANManufacturerOrgSupport eanManSupport;\n    /*\n    protected UPCEANReader() {\n        decodeRowStringBuffer = new StringBuilder(20);\n        extensionReader = new UPCEANExtensionSupport();\n        eanManSupport = new EANManufacturerOrgSupport();\n    }\n    */\n    AbstractUPCEANReader.findStartGuardPattern = function (row) {\n        var foundStart = false;\n        var startRange;\n        var nextStart = 0;\n        var counters = Int32Array.from([0, 0, 0]);\n        while (!foundStart) {\n            counters = Int32Array.from([0, 0, 0]);\n            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n            var start = startRange[0];\n            nextStart = startRange[1];\n            var quietStart = start - (nextStart - start);\n            if (quietStart >= 0) {\n                foundStart = row.isRange(quietStart, start, false);\n            }\n        }\n        return startRange;\n    };\n    AbstractUPCEANReader.checkChecksum = function (s) {\n        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    /**\n     * @throws NotFoundException\n     */\n    AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {\n        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n    };\n    /**\n     * @param row row of black/white values to search\n     * @param rowOffset position to start search\n     * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n     * pixel counts, otherwise, it is interpreted as black/white/black/...\n     * @param pattern pattern of counts of number of black and white pixels that are being\n     * searched for as a pattern\n     * @param counters array of counters, as long as pattern, to re-use\n     * @return start/end horizontal offset of guard pattern, as an array of two ints\n     * @throws NotFoundException if pattern is not found\n     */\n    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n        var width = row.getSize();\n        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var patternLength = pattern.length;\n        var isWhite = whiteFirst;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                        return Int32Array.from([patternStart, x]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    var slice = counters.slice(2, counters.length - 1);\n                    for (var i = 0; i < counterPosition - 1; i++) {\n                        counters[i] = slice[i];\n                    }\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException();\n    };\n    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n        this.recordPattern(row, rowOffset, counters);\n        var bestVariance = this.MAX_AVG_VARIANCE;\n        var bestMatch = -1;\n        var max = patterns.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = patterns[i];\n            var variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException();\n        }\n    };\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([3, 2, 1, 1]),\n        Int32Array.from([2, 2, 2, 1]),\n        Int32Array.from([2, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 1]),\n        Int32Array.from([1, 1, 3, 2]),\n        Int32Array.from([1, 2, 3, 1]),\n        Int32Array.from([1, 1, 1, 4]),\n        Int32Array.from([1, 3, 1, 2]),\n        Int32Array.from([1, 2, 1, 3]),\n        Int32Array.from([3, 1, 1, 2]),\n    ];\n    return AbstractUPCEANReader;\n}(OneDReader));\nexport default AbstractUPCEANReader;\n//# sourceMappingURL=AbstractUPCEANReader.js.map"]},"metadata":{},"sourceType":"module"}