{"ast":null,"code":"import _inherits from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/flo/Desktop/mdao.fioriapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t, i, s, e;\n\nvar o = globalThis.trustedTypes,\n    l = o ? o.createPolicy(\"lit-html\", {\n  createHTML: function createHTML(t) {\n    return t;\n  }\n}) : void 0,\n    n = \"lit$\".concat((Math.random() + \"\").slice(9), \"$\"),\n    h = \"?\" + n,\n    r = \"<\".concat(h, \">\"),\n    _u = document,\n    c = function c() {\n  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return _u.createComment(t);\n},\n    d = function d(t) {\n  return null === t || \"object\" != typeof t && \"function\" != typeof t;\n},\n    v = Array.isArray,\n    a = function a(t) {\n  var i;\n  return v(t) || \"function\" == typeof (null === (i = t) || void 0 === i ? void 0 : i[Symbol.iterator]);\n},\n    f = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n    _ = /-->/g,\n    m = />/g,\n    p = />|[ \t\\n\f\\r](?:([^\\s\"'>=/]+)([ \t\\n\f\\r]*=[ \t\\n\f\\r]*(?:[^ \t\\n\f\\r\"'`<>=]|(\"|')|))|$)/g,\n    $ = /'/g,\n    g = /\"/g,\n    y = /^(?:script|style|textarea)$/i,\n    b = function b(t) {\n  return function (i) {\n    for (var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      s[_key - 1] = arguments[_key];\n    }\n\n    return {\n      _$litType$: t,\n      strings: i,\n      values: s\n    };\n  };\n},\n    T = b(1),\n    x = b(2),\n    w = Symbol.for(\"lit-noChange\"),\n    A = Symbol.for(\"lit-nothing\"),\n    P = new WeakMap(),\n    V = function V(t, i, s) {\n  var e, o;\n  var l = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;\n  var n = l._$litPart$;\n\n  if (void 0 === n) {\n    var _t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;\n\n    l._$litPart$ = n = new C(i.insertBefore(c(), _t), _t, void 0, s);\n  }\n\n  return n.I(t), n;\n},\n    E = _u.createTreeWalker(_u, 129, null, !1),\n    M = function M(t, i) {\n  var s = t.length - 1,\n      e = [];\n  var o,\n      h = 2 === i ? \"<svg>\" : \"\",\n      u = f;\n\n  for (var _i = 0; _i < s; _i++) {\n    var _s = t[_i];\n\n    var _l = void 0,\n        _c = void 0,\n        _d = -1,\n        _v = 0;\n\n    for (; _v < _s.length && (u.lastIndex = _v, _c = u.exec(_s), null !== _c);) {\n      _v = u.lastIndex, u === f ? \"!--\" === _c[1] ? u = _ : void 0 !== _c[1] ? u = m : void 0 !== _c[2] ? (y.test(_c[2]) && (o = RegExp(\"</\" + _c[2], \"g\")), u = p) : void 0 !== _c[3] && (u = p) : u === p ? \">\" === _c[0] ? (u = null != o ? o : f, _d = -1) : void 0 === _c[1] ? _d = -2 : (_d = u.lastIndex - _c[2].length, _l = _c[1], u = void 0 === _c[3] ? p : '\"' === _c[3] ? g : $) : u === g || u === $ ? u = p : u === _ || u === m ? u = f : (u = p, o = void 0);\n    }\n\n    var _a = u === p && t[_i + 1].startsWith(\"/>\") ? \" \" : \"\";\n\n    h += u === f ? _s + r : _d >= 0 ? (e.push(_l), _s.slice(0, _d) + \"$lit$\" + _s.slice(_d) + n + _a) : _s + n + (-2 === _d ? (e.push(void 0), _i) : _a);\n  }\n\n  var c = h + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\");\n  return [void 0 !== l ? l.createHTML(c) : c, e];\n};\n\nvar N = /*#__PURE__*/function () {\n  function N(_ref, s) {\n    var t = _ref.strings,\n        i = _ref._$litType$;\n\n    _classCallCheck(this, N);\n\n    var e;\n    this.parts = [];\n    var l = 0,\n        r = 0;\n\n    var u = t.length - 1,\n        d = this.parts,\n        _M = M(t, i),\n        _M2 = _slicedToArray(_M, 2),\n        v = _M2[0],\n        a = _M2[1];\n\n    if (this.el = N.createElement(v, s), E.currentNode = this.el.content, 2 === i) {\n      var _t2 = this.el.content,\n          _i2 = _t2.firstChild;\n      _i2.remove(), _t2.append.apply(_t2, _toConsumableArray(_i2.childNodes));\n    }\n\n    for (; null !== (e = E.nextNode()) && d.length < u;) {\n      if (1 === e.nodeType) {\n        if (e.hasAttributes()) {\n          var _t3 = [];\n\n          var _iterator = _createForOfIteratorHelper(e.getAttributeNames()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _i5 = _step.value;\n\n              if (_i5.endsWith(\"$lit$\") || _i5.startsWith(n)) {\n                var _s2 = a[r++];\n\n                if (_t3.push(_i5), void 0 !== _s2) {\n                  var _t5 = e.getAttribute(_s2.toLowerCase() + \"$lit$\").split(n),\n                      _i6 = /([.?@])?(.*)/.exec(_s2);\n\n                  d.push({\n                    type: 1,\n                    index: l,\n                    name: _i6[2],\n                    strings: _t5,\n                    ctor: \".\" === _i6[1] ? I : \"?\" === _i6[1] ? L : \"@\" === _i6[1] ? R : H\n                  });\n                } else d.push({\n                  type: 6,\n                  index: l\n                });\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          for (var _i3 = 0, _t4 = _t3; _i3 < _t4.length; _i3++) {\n            var _i4 = _t4[_i3];\n            e.removeAttribute(_i4);\n          }\n        }\n\n        if (y.test(e.tagName)) {\n          var _t6 = e.textContent.split(n),\n              _i7 = _t6.length - 1;\n\n          if (_i7 > 0) {\n            e.textContent = o ? o.emptyScript : \"\";\n\n            for (var _s3 = 0; _s3 < _i7; _s3++) {\n              e.append(_t6[_s3], c()), E.nextNode(), d.push({\n                type: 2,\n                index: ++l\n              });\n            }\n\n            e.append(_t6[_i7], c());\n          }\n        }\n      } else if (8 === e.nodeType) if (e.data === h) d.push({\n        type: 2,\n        index: l\n      });else {\n        var _t7 = -1;\n\n        for (; -1 !== (_t7 = e.data.indexOf(n, _t7 + 1));) {\n          d.push({\n            type: 7,\n            index: l\n          }), _t7 += n.length - 1;\n        }\n      }\n\n      l++;\n    }\n  }\n\n  _createClass(N, null, [{\n    key: \"createElement\",\n    value: function createElement(t, i) {\n      var s = _u.createElement(\"template\");\n\n      return s.innerHTML = t, s;\n    }\n  }]);\n\n  return N;\n}();\n\nfunction S(t, i) {\n  var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;\n  var e = arguments.length > 3 ? arguments[3] : undefined;\n  var o, l, n, h;\n  if (i === w) return i;\n  var r = void 0 !== e ? null === (o = s.Σi) || void 0 === o ? void 0 : o[e] : s.Σo;\n  var u = d(i) ? void 0 : i._$litDirective$;\n  return (null == r ? void 0 : r.constructor) !== u && (null === (l = null == r ? void 0 : r.O) || void 0 === l || l.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r.T(t, s, e)), void 0 !== e ? (null !== (n = (h = s).Σi) && void 0 !== n ? n : h.Σi = [])[e] = r : s.Σo = r), void 0 !== r && (i = S(t, r.S(t, i.values), r, e)), i;\n}\n\nvar k = /*#__PURE__*/function () {\n  function k(t, i) {\n    _classCallCheck(this, k);\n\n    this.l = [], this.N = void 0, this.D = t, this.M = i;\n  }\n\n  _createClass(k, [{\n    key: \"u\",\n    value: function u(t) {\n      var i;\n      var _this$D = this.D,\n          s = _this$D.el.content,\n          e = _this$D.parts,\n          o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : _u).importNode(s, !0);\n      E.currentNode = o;\n      var l = E.nextNode(),\n          n = 0,\n          h = 0,\n          r = e[0];\n\n      for (; void 0 !== r;) {\n        if (n === r.index) {\n          var _i8 = void 0;\n\n          2 === r.type ? _i8 = new C(l, l.nextSibling, this, t) : 1 === r.type ? _i8 = new r.ctor(l, r.name, r.strings, this, t) : 6 === r.type && (_i8 = new z(l, this, t)), this.l.push(_i8), r = e[++h];\n        }\n\n        n !== (null == r ? void 0 : r.index) && (l = E.nextNode(), n++);\n      }\n\n      return o;\n    }\n  }, {\n    key: \"v\",\n    value: function v(t) {\n      var i = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this.l),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _s4 = _step2.value;\n          void 0 !== _s4 && (void 0 !== _s4.strings ? (_s4.I(t, _s4, i), i += _s4.strings.length - 2) : _s4.I(t[i])), i++;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return k;\n}();\n\nvar C = /*#__PURE__*/function () {\n  function C(t, i, s, e) {\n    _classCallCheck(this, C);\n\n    this.type = 2, this.N = void 0, this.A = t, this.B = i, this.M = s, this.options = e;\n  }\n\n  _createClass(C, [{\n    key: \"setConnected\",\n    value: function setConnected(t) {\n      var i;\n      null === (i = this.P) || void 0 === i || i.call(this, t);\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.A.parentNode;\n    }\n  }, {\n    key: \"startNode\",\n    get: function get() {\n      return this.A;\n    }\n  }, {\n    key: \"endNode\",\n    get: function get() {\n      return this.B;\n    }\n  }, {\n    key: \"I\",\n    value: function I(t) {\n      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n      t = S(this, t, i), d(t) ? t === A || null == t || \"\" === t ? (this.H !== A && this.R(), this.H = A) : t !== this.H && t !== w && this.m(t) : void 0 !== t._$litType$ ? this._(t) : void 0 !== t.nodeType ? this.$(t) : a(t) ? this.g(t) : this.m(t);\n    }\n  }, {\n    key: \"k\",\n    value: function k(t) {\n      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.B;\n      return this.A.parentNode.insertBefore(t, i);\n    }\n  }, {\n    key: \"$\",\n    value: function $(t) {\n      this.H !== t && (this.R(), this.H = this.k(t));\n    }\n  }, {\n    key: \"m\",\n    value: function m(t) {\n      var i = this.A.nextSibling;\n      null !== i && 3 === i.nodeType && (null === this.B ? null === i.nextSibling : i === this.B.previousSibling) ? i.data = t : this.$(_u.createTextNode(t)), this.H = t;\n    }\n  }, {\n    key: \"_\",\n    value: function _(t) {\n      var i;\n      var s = t.values,\n          e = t._$litType$,\n          o = \"number\" == typeof e ? this.C(t) : (void 0 === e.el && (e.el = N.createElement(e.h, this.options)), e);\n      if ((null === (i = this.H) || void 0 === i ? void 0 : i.D) === o) this.H.v(s);else {\n        var _t8 = new k(o, this),\n            _i9 = _t8.u(this.options);\n\n        _t8.v(s), this.$(_i9), this.H = _t8;\n      }\n    }\n  }, {\n    key: \"C\",\n    value: function C(t) {\n      var i = P.get(t.strings);\n      return void 0 === i && P.set(t.strings, i = new N(t)), i;\n    }\n  }, {\n    key: \"g\",\n    value: function g(t) {\n      v(this.H) || (this.H = [], this.R());\n      var i = this.H;\n      var s,\n          e = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(t),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _o = _step3.value;\n          e === i.length ? i.push(s = new C(this.k(c()), this.k(c()), this, this.options)) : s = i[e], s.I(_o), e++;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      e < i.length && (this.R(s && s.B.nextSibling, e), i.length = e);\n    }\n  }, {\n    key: \"R\",\n    value: function R() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.A.nextSibling;\n      var i = arguments.length > 1 ? arguments[1] : undefined;\n      var s;\n\n      for (null === (s = this.P) || void 0 === s || s.call(this, !1, !0, i); t && t !== this.B;) {\n        var _i10 = t.nextSibling;\n        t.remove(), t = _i10;\n      }\n    }\n  }]);\n\n  return C;\n}();\n\nvar H = /*#__PURE__*/function () {\n  function H(t, i, s, e, o) {\n    _classCallCheck(this, H);\n\n    this.type = 1, this.H = A, this.N = void 0, this.V = void 0, this.element = t, this.name = i, this.M = e, this.options = o, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this.H = Array(s.length - 1).fill(A), this.strings = s) : this.H = A;\n  }\n\n  _createClass(H, [{\n    key: \"tagName\",\n    get: function get() {\n      return this.element.tagName;\n    }\n  }, {\n    key: \"I\",\n    value: function I(t) {\n      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n      var s = arguments.length > 2 ? arguments[2] : undefined;\n      var e = arguments.length > 3 ? arguments[3] : undefined;\n      var o = this.strings;\n      var l = !1;\n      if (void 0 === o) t = S(this, t, i, 0), l = !d(t) || t !== this.H && t !== w, l && (this.H = t);else {\n        var _e = t;\n\n        var _n, _h;\n\n        for (t = o[0], _n = 0; _n < o.length - 1; _n++) {\n          _h = S(this, _e[s + _n], i, _n), _h === w && (_h = this.H[_n]), l || (l = !d(_h) || _h !== this.H[_n]), _h === A ? t = A : t !== A && (t += (null != _h ? _h : \"\") + o[_n + 1]), this.H[_n] = _h;\n        }\n      }\n      l && !e && this.W(t);\n    }\n  }, {\n    key: \"W\",\n    value: function W(t) {\n      t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : \"\");\n    }\n  }]);\n\n  return H;\n}();\n\nvar I = /*#__PURE__*/function (_H) {\n  _inherits(I, _H);\n\n  var _super = _createSuper(I);\n\n  function I() {\n    var _this;\n\n    _classCallCheck(this, I);\n\n    _this = _super.apply(this, arguments), _this.type = 3;\n    return _this;\n  }\n\n  _createClass(I, [{\n    key: \"W\",\n    value: function W(t) {\n      this.element[this.name] = t === A ? void 0 : t;\n    }\n  }]);\n\n  return I;\n}(H);\n\nvar L = /*#__PURE__*/function (_H2) {\n  _inherits(L, _H2);\n\n  var _super2 = _createSuper(L);\n\n  function L() {\n    var _this2;\n\n    _classCallCheck(this, L);\n\n    _this2 = _super2.apply(this, arguments), _this2.type = 4;\n    return _this2;\n  }\n\n  _createClass(L, [{\n    key: \"W\",\n    value: function W(t) {\n      t && t !== A ? this.element.setAttribute(this.name, \"\") : this.element.removeAttribute(this.name);\n    }\n  }]);\n\n  return L;\n}(H);\n\nvar R = /*#__PURE__*/function (_H3) {\n  _inherits(R, _H3);\n\n  var _super3 = _createSuper(R);\n\n  function R() {\n    var _this3;\n\n    _classCallCheck(this, R);\n\n    _this3 = _super3.apply(this, arguments), _this3.type = 5;\n    return _this3;\n  }\n\n  _createClass(R, [{\n    key: \"I\",\n    value: function I(t) {\n      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n      var s;\n      if ((t = null !== (s = S(this, t, i, 0)) && void 0 !== s ? s : A) === w) return;\n      var e = this.H,\n          o = t === A && e !== A || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,\n          l = t !== A && (e === A || o);\n      o && this.element.removeEventListener(this.name, this, e), l && this.element.addEventListener(this.name, this, t), this.H = t;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t) {\n      var i, s;\n      \"function\" == typeof this.H ? this.H.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this.H.handleEvent(t);\n    }\n  }]);\n\n  return R;\n}(H);\n\nvar z = /*#__PURE__*/function () {\n  function z(t, i, s) {\n    _classCallCheck(this, z);\n\n    this.element = t, this.type = 6, this.N = void 0, this.V = void 0, this.M = i, this.options = s;\n  }\n\n  _createClass(z, [{\n    key: \"I\",\n    value: function I(t) {\n      S(this, t);\n    }\n  }]);\n\n  return z;\n}();\n\nvar Z = {\n  Z: \"$lit$\",\n  U: n,\n  Y: h,\n  q: 1,\n  X: M,\n  tt: k,\n  it: a,\n  st: S,\n  et: C,\n  ot: H,\n  nt: L,\n  rt: R,\n  lt: I,\n  ht: z\n};\nnull === (i = (t = globalThis).litHtmlPlatformSupport) || void 0 === i || i.call(t, N, C), (null !== (s = (e = globalThis).litHtmlVersions) && void 0 !== s ? s : e.litHtmlVersions = []).push(\"2.0.0-rc.3\");\nexport { Z as _Σ, T as html, w as noChange, A as nothing, V as render, x as svg };","map":{"version":3,"sources":["src/lit-html.ts"],"names":["trustedTypes","globalThis","policy","createPolicy","createHTML","s","undefined","marker","String","Math","random","slice","markerMatch","nodeMarker","d","document","createMarker","v","createComment","isPrimitive","value","isArray","Array","isIterable","Symbol","iterator","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","_$litType$","strings","values","html","svg","noChange","for","nothing","templateCache","WeakMap","render","container","options","partOwnerNode","renderBefore","part","_$litPart$","endNode","ChildPart","insertBefore","_$setValue","walker","createTreeWalker","getTemplateHtml","type","l","length","attrNames","rawTextEndRegex","regex","i","attrNameEndIndex","attrName","lastIndex","match","exec","test","RegExp","end","startsWith","push","htmlResult","Template","this","[object Object]","node","nodeIndex","attrNameIndex","partCount","parts","el","createElement","currentNode","content","svgElement","firstChild","remove","append","childNodes","nextNode","nodeType","hasAttributes","attrsToRemove","name","getAttributeNames","endsWith","realName","getAttribute","toLowerCase","statics","split","m","index","ctor","PropertyPart","BooleanAttributePart","EventPart","AttributePart","removeAttribute","tagName","textContent","emptyScript","data","indexOf","_options","innerHTML","resolveDirective","parent","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","_$litDirective$","constructor","_$setDirectiveConnected","_$initialize","_$resolve","TemplateInstance","template","_$template","_$parent","fragment","creationScope","importNode","partIndex","templatePart","nextSibling","ElementPart","_parts","startNode","_$startNode","_$endNode","isConnected","_$setChildPartConnected","parentNode","directiveParent","_$committedValue","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","ref","_insert","previousSibling","createTextNode","result","_$getTemplate","h","_update","instance","_clone","get","set","itemParts","itemPart","item","start","from","n","element","fill","valueIndex","noCommit","change","_commitValue","setAttribute","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","event","call","host","handleEvent","_Σ","Z","U","Y","q","X","tt","it","st","et","ot","nt","rt","lt","ht"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\nconst trustedTypes = ((globalThis as unknown) as Partial<Window>).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult<T extends ResultType = ResultType> = {\n  _$litType$: T;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  _$litType$: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  h: TrustedHTML;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = <T extends ResultType>(_$litType$: T) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult<T> => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart$;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart$ = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [TrustedHTML, Array<string | undefined>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string | undefined> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s +\n          marker +\n          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [\n    policy !== undefined\n      ? policy.createHTML(htmlResult)\n      : ((htmlResult as unknown) as TrustedHTML),\n    attrNames,\n  ];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n  /** @internal */\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this.el.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (\n              name.endsWith(boundAttributeSuffix) ||\n              name.startsWith(marker)\n            ) {\n              const realName = attrNames[attrNameIndex++];\n              attrsToRemove.push(name);\n              if (realName !== undefined) {\n                // Lowercase for case-sensitive SVG attributes like viewBox\n                const value = (node as Element).getAttribute(\n                  realName.toLowerCase() + boundAttributeSuffix\n                )!;\n                const statics = value.split(marker);\n                const m = /([.?@])?(.*)/.exec(realName)!;\n                parts.push({\n                  type: ATTRIBUTE_PART,\n                  index: nodeIndex,\n                  name: m[2],\n                  strings: statics,\n                  ctor:\n                    m[1] === '.'\n                      ? PropertyPart\n                      : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                      ? EventPart\n                      : AttributePart,\n                });\n              } else {\n                parts.push({\n                  type: ELEMENT_PART,\n                  index: nodeIndex,\n                });\n              }\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? ((trustedTypes.emptyScript as unknown) as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = (html as unknown) as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[\n        attributeIndex\n      ] = currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex\n    );\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  /** @internal */\n  readonly ctor: typeof AttributePart;\n  /** @internal */\n  readonly strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `AsyncDirectives` contained\n   * within this part and runs their `disconnected` or `reconnected`, according\n   * to the `isConnected` argument.\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    return wrap(this._$startNode).parentNode!;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = wrap(this._$startNode).nextSibling;\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? wrap(node).nextSibling === null\n        : node === wrap(this._$endNode).previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult\n  ): void {\n    const {values, _$litType$} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof _$litType$ === 'number'\n        ? this._$getTemplate(result as TemplateResult)\n        : (_$litType$.el === undefined &&\n            (_$litType$.el = Template.createElement(\n              _$litType$.h,\n              this.options\n            )),\n          _$litType$);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: TemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/lit/lit/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n}\n\nexport type {AttributePart};\nclass AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      (wrap(this.element) as Element).setAttribute(this.name, '');\n    } else {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this.element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _Σ object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _Σ = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-rc.3');\n"]},"metadata":{},"sourceType":"module"}