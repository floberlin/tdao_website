{"ast":null,"code":"import AnimationQueue from \"./AnimationQueue.js\";\nimport animationConfig from \"./config.js\";\nexport default (({\n  beforeStart = animationConfig.identity,\n  duration = animationConfig.defaultDuration,\n  element = animationConfig.element,\n  progress: progressCallback = animationConfig.identity\n}) => {\n  let start = null;\n  let stopped = false;\n  let animationFrame;\n  let stop;\n  let animate;\n  const promise = new Promise((resolve, reject) => {\n    animate = timestamp => {\n      start = start || timestamp;\n      const timeElapsed = timestamp - start;\n      const remaining = duration - timeElapsed;\n\n      if (timeElapsed <= duration) {\n        const progress = 1 - remaining / duration; // easing formula (currently linear)\n\n        progressCallback(progress);\n        animationFrame = !stopped && requestAnimationFrame(animate);\n      } else {\n        progressCallback(1);\n        resolve();\n      }\n    };\n\n    stop = () => {\n      stopped = true;\n      cancelAnimationFrame(animationFrame);\n      reject(new Error(\"animation stopped\"));\n    };\n  }).catch(oReason => oReason);\n  AnimationQueue.push(element, () => {\n    beforeStart();\n    requestAnimationFrame(animate);\n    return new Promise(resolve => {\n      promise.then(() => resolve());\n    });\n  });\n  return {\n    promise: () => promise,\n    stop: () => stop\n  };\n});","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/animations/animate.js"],"names":["AnimationQueue","animationConfig","beforeStart","identity","duration","defaultDuration","element","progress","progressCallback","start","stopped","animationFrame","stop","animate","promise","Promise","resolve","reject","timestamp","timeElapsed","remaining","requestAnimationFrame","cancelAnimationFrame","Error","catch","oReason","push","then"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,qBAA3B;AACA,OAAOC,eAAP,MAA4B,aAA5B;AAEA,gBAAe,CAAC;AACfC,EAAAA,WAAW,GAAGD,eAAe,CAACE,QADf;AAEfC,EAAAA,QAAQ,GAAGH,eAAe,CAACI,eAFZ;AAGfC,EAAAA,OAAO,GAAGL,eAAe,CAACK,OAHX;AAIfC,EAAAA,QAAQ,EAAEC,gBAAgB,GAAGP,eAAe,CAACE;AAJ9B,CAAD,KAKT;AACL,MAAIM,KAAK,GAAG,IAAZ;AACA,MAAIC,OAAO,GAAG,KAAd;AACA,MAAIC,cAAJ;AACA,MAAIC,IAAJ;AACA,MAAIC,OAAJ;AAEA,QAAMC,OAAO,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAChDJ,IAAAA,OAAO,GAAGK,SAAS,IAAI;AACtBT,MAAAA,KAAK,GAAGA,KAAK,IAAIS,SAAjB;AAEA,YAAMC,WAAW,GAAGD,SAAS,GAAGT,KAAhC;AACA,YAAMW,SAAS,GAAGhB,QAAQ,GAAGe,WAA7B;;AAEA,UAAIA,WAAW,IAAIf,QAAnB,EAA6B;AAC5B,cAAMG,QAAQ,GAAG,IAAIa,SAAS,GAAGhB,QAAjC,CAD4B,CACe;;AAC3CI,QAAAA,gBAAgB,CAACD,QAAD,CAAhB;AACAI,QAAAA,cAAc,GAAG,CAACD,OAAD,IAAYW,qBAAqB,CAACR,OAAD,CAAlD;AACA,OAJD,MAIO;AACNL,QAAAA,gBAAgB,CAAC,CAAD,CAAhB;AACAQ,QAAAA,OAAO;AACP;AACD,KAdD;;AAgBAJ,IAAAA,IAAI,GAAG,MAAM;AACZF,MAAAA,OAAO,GAAG,IAAV;AACAY,MAAAA,oBAAoB,CAACX,cAAD,CAApB;AACAM,MAAAA,MAAM,CAAC,IAAIM,KAAJ,CAAU,mBAAV,CAAD,CAAN;AACA,KAJD;AAKA,GAtBe,EAsBbC,KAtBa,CAsBPC,OAAO,IAAIA,OAtBJ,CAAhB;AAwBAzB,EAAAA,cAAc,CAAC0B,IAAf,CAAoBpB,OAApB,EAA6B,MAAM;AAClCJ,IAAAA,WAAW;AACXmB,IAAAA,qBAAqB,CAACR,OAAD,CAArB;AAEA,WAAO,IAAIE,OAAJ,CAAYC,OAAO,IAAI;AAC7BF,MAAAA,OAAO,CAACa,IAAR,CAAa,MAAMX,OAAO,EAA1B;AACA,KAFM,CAAP;AAGA,GAPD;AASA,SAAO;AACNF,IAAAA,OAAO,EAAE,MAAMA,OADT;AAENF,IAAAA,IAAI,EAAE,MAAMA;AAFN,GAAP;AAIA,CAjDD","sourcesContent":["import AnimationQueue from \"./AnimationQueue.js\";\nimport animationConfig from \"./config.js\";\n\nexport default ({\n\tbeforeStart = animationConfig.identity,\n\tduration = animationConfig.defaultDuration,\n\telement = animationConfig.element,\n\tprogress: progressCallback = animationConfig.identity,\n}) => {\n\tlet start = null;\n\tlet stopped = false;\n\tlet animationFrame;\n\tlet stop;\n\tlet animate;\n\n\tconst promise = new Promise((resolve, reject) => {\n\t\tanimate = timestamp => {\n\t\t\tstart = start || timestamp;\n\n\t\t\tconst timeElapsed = timestamp - start;\n\t\t\tconst remaining = duration - timeElapsed;\n\n\t\t\tif (timeElapsed <= duration) {\n\t\t\t\tconst progress = 1 - remaining / duration; // easing formula (currently linear)\n\t\t\t\tprogressCallback(progress);\n\t\t\t\tanimationFrame = !stopped && requestAnimationFrame(animate);\n\t\t\t} else {\n\t\t\t\tprogressCallback(1);\n\t\t\t\tresolve();\n\t\t\t}\n\t\t};\n\n\t\tstop = () => {\n\t\t\tstopped = true;\n\t\t\tcancelAnimationFrame(animationFrame);\n\t\t\treject(new Error(\"animation stopped\"));\n\t\t};\n\t}).catch(oReason => oReason);\n\n\tAnimationQueue.push(element, () => {\n\t\tbeforeStart();\n\t\trequestAnimationFrame(animate);\n\n\t\treturn new Promise(resolve => {\n\t\t\tpromise.then(() => resolve());\n\t\t});\n\t});\n\n\treturn {\n\t\tpromise: () => promise,\n\t\tstop: () => stop,\n\t};\n};\n"]},"metadata":{},"sourceType":"module"}