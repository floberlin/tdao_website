{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport EncodeHintType from '../EncodeHintType';\nimport BitMatrix from '../common/BitMatrix';\nimport ErrorCorrectionLevel from './decoder/ErrorCorrectionLevel';\nimport Encoder from './encoder/Encoder';\nimport IllegalArgumentException from '../IllegalArgumentException';\nimport IllegalStateException from '../IllegalStateException';\n/*import java.util.Map;*/\n\n/**\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\n\nvar QRCodeWriter = function () {\n  function QRCodeWriter() {}\n  /*@Override*/\n  // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n  //     /*throws WriterException */ {\n  //   return encode(contents, format, width, height, null)\n  // }\n\n  /*@Override*/\n\n\n  QRCodeWriter.prototype.encode = function (contents, format, width\n  /*int*/\n  , height\n  /*int*/\n  , hints) {\n    if (contents.length === 0) {\n      throw new IllegalArgumentException('Found empty contents');\n    }\n\n    if (format !== BarcodeFormat.QR_CODE) {\n      throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);\n    }\n\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + \"x\" + height);\n    }\n\n    var errorCorrectionLevel = ErrorCorrectionLevel.L;\n    var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n\n    if (hints !== null) {\n      if (undefined !== hints.get(EncodeHintType.ERROR_CORRECTION)) {\n        errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType.ERROR_CORRECTION).toString());\n      }\n\n      if (undefined !== hints.get(EncodeHintType.MARGIN)) {\n        quietZone = Number.parseInt(hints.get(EncodeHintType.MARGIN).toString(), 10);\n      }\n    }\n\n    var code = Encoder.encode(contents, errorCorrectionLevel, hints);\n    return QRCodeWriter.renderResult(code, width, height, quietZone);\n  }; // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n  // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n\n\n  QRCodeWriter.renderResult = function (code, width\n  /*int*/\n  , height\n  /*int*/\n  , quietZone\n  /*int*/\n  ) {\n    var input = code.getMatrix();\n\n    if (input === null) {\n      throw new IllegalStateException();\n    }\n\n    var inputWidth = input.getWidth();\n    var inputHeight = input.getHeight();\n    var qrWidth = inputWidth + quietZone * 2;\n    var qrHeight = inputHeight + quietZone * 2;\n    var outputWidth = Math.max(width, qrWidth);\n    var outputHeight = Math.max(height, qrHeight);\n    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight)); // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n    // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n    // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n    // handle all the padding from 100x100 (the actual QR) up to 200x160.\n\n    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n    var output = new BitMatrix(outputWidth, outputHeight);\n\n    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n      // Write the contents of this row of the barcode\n      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n        if (input.get(inputX, inputY) === 1) {\n          output.setRegion(outputX, outputY, multiple, multiple);\n        }\n      }\n    }\n\n    return output;\n  };\n\n  QRCodeWriter.QUIET_ZONE_SIZE = 4;\n  return QRCodeWriter;\n}();\n\nexport default QRCodeWriter;","map":{"version":3,"sources":["../../../../src/core/qrcode/QRCodeWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport EncodeHintType from '../EncodeHintType';\nimport BitMatrix from '../common/BitMatrix';\nimport ErrorCorrectionLevel from './decoder/ErrorCorrectionLevel';\nimport Encoder from './encoder/Encoder';\nimport IllegalArgumentException from '../IllegalArgumentException';\nimport IllegalStateException from '../IllegalStateException';\n/*import java.util.Map;*/\n/**\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar QRCodeWriter = /** @class */ (function () {\n    function QRCodeWriter() {\n    }\n    /*@Override*/\n    // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n    //     /*throws WriterException */ {\n    //   return encode(contents, format, width, height, null)\n    // }\n    /*@Override*/\n    QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n        if (contents.length === 0) {\n            throw new IllegalArgumentException('Found empty contents');\n        }\n        if (format !== BarcodeFormat.QR_CODE) {\n            throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + \"x\" + height);\n        }\n        var errorCorrectionLevel = ErrorCorrectionLevel.L;\n        var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n        if (hints !== null) {\n            if (undefined !== hints.get(EncodeHintType.ERROR_CORRECTION)) {\n                errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType.ERROR_CORRECTION).toString());\n            }\n            if (undefined !== hints.get(EncodeHintType.MARGIN)) {\n                quietZone = Number.parseInt(hints.get(EncodeHintType.MARGIN).toString(), 10);\n            }\n        }\n        var code = Encoder.encode(contents, errorCorrectionLevel, hints);\n        return QRCodeWriter.renderResult(code, width, height, quietZone);\n    };\n    // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n    // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n    QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n        var input = code.getMatrix();\n        if (input === null) {\n            throw new IllegalStateException();\n        }\n        var inputWidth = input.getWidth();\n        var inputHeight = input.getHeight();\n        var qrWidth = inputWidth + (quietZone * 2);\n        var qrHeight = inputHeight + (quietZone * 2);\n        var outputWidth = Math.max(width, qrWidth);\n        var outputHeight = Math.max(height, qrHeight);\n        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n        // handle all the padding from 100x100 (the actual QR) up to 200x160.\n        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n        var output = new BitMatrix(outputWidth, outputHeight);\n        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the barcode\n            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                if (input.get(inputX, inputY) === 1) {\n                    output.setRegion(outputX, outputY, multiple, multiple);\n                }\n            }\n        }\n        return output;\n    };\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n    return QRCodeWriter;\n}());\nexport default QRCodeWriter;\n//# sourceMappingURL=QRCodeWriter.js.map"]},"metadata":{},"sourceType":"module"}