{"ast":null,"code":"class EventProvider {\n  constructor() {\n    this._eventRegistry = new Map();\n  }\n\n  attachEvent(eventName, fnFunction) {\n    const eventRegistry = this._eventRegistry;\n    const eventListeners = eventRegistry.get(eventName);\n\n    if (!Array.isArray(eventListeners)) {\n      eventRegistry.set(eventName, [fnFunction]);\n      return;\n    }\n\n    if (!eventListeners.includes(fnFunction)) {\n      eventListeners.push(fnFunction);\n    }\n  }\n\n  detachEvent(eventName, fnFunction) {\n    const eventRegistry = this._eventRegistry;\n    const eventListeners = eventRegistry.get(eventName);\n\n    if (!eventListeners) {\n      return;\n    }\n\n    const indexOfFnToDetach = eventListeners.indexOf(fnFunction);\n\n    if (indexOfFnToDetach !== -1) {\n      eventListeners.splice(indexOfFnToDetach, 1);\n    }\n\n    if (eventListeners.length === 0) {\n      eventRegistry.delete(eventName);\n    }\n  }\n  /**\n   * Fires an event and returns the results of all event listeners as an array.\n   *\n   * @param eventName the event to fire\n   * @param data optional data to pass to each event listener\n   * @returns {Array} an array with the results of all event listeners\n   */\n\n\n  fireEvent(eventName, data) {\n    const eventRegistry = this._eventRegistry;\n    const eventListeners = eventRegistry.get(eventName);\n\n    if (!eventListeners) {\n      return [];\n    }\n\n    return eventListeners.map(fn => {\n      return fn.call(this, data); // eslint-disable-line\n    });\n  }\n  /**\n   * Fires an event and returns a promise that will resolve once all listeners have resolved.\n   *\n   * @param eventName the event to fire\n   * @param data optional data to pass to each event listener\n   * @returns {Promise} a promise that will resolve when all listeners have resolved\n   */\n\n\n  fireEventAsync(eventName, data) {\n    return Promise.all(this.fireEvent(eventName, data));\n  }\n\n  isHandlerAttached(eventName, fnFunction) {\n    const eventRegistry = this._eventRegistry;\n    const eventListeners = eventRegistry.get(eventName);\n\n    if (!eventListeners) {\n      return false;\n    }\n\n    return eventListeners.includes(fnFunction);\n  }\n\n  hasListeners(eventName) {\n    return !!this._eventRegistry.get(eventName);\n  }\n\n}\n\nexport default EventProvider;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/EventProvider.js"],"names":["EventProvider","constructor","_eventRegistry","Map","attachEvent","eventName","fnFunction","eventRegistry","eventListeners","get","Array","isArray","set","includes","push","detachEvent","indexOfFnToDetach","indexOf","splice","length","delete","fireEvent","data","map","fn","call","fireEventAsync","Promise","all","isHandlerAttached","hasListeners"],"mappings":"AAAA,MAAMA,aAAN,CAAoB;AACnBC,EAAAA,WAAW,GAAG;AACb,SAAKC,cAAL,GAAsB,IAAIC,GAAJ,EAAtB;AACA;;AAEDC,EAAAA,WAAW,CAACC,SAAD,EAAYC,UAAZ,EAAwB;AAClC,UAAMC,aAAa,GAAG,KAAKL,cAA3B;AACA,UAAMM,cAAc,GAAGD,aAAa,CAACE,GAAd,CAAkBJ,SAAlB,CAAvB;;AAEA,QAAI,CAACK,KAAK,CAACC,OAAN,CAAcH,cAAd,CAAL,EAAoC;AACnCD,MAAAA,aAAa,CAACK,GAAd,CAAkBP,SAAlB,EAA6B,CAACC,UAAD,CAA7B;AACA;AACA;;AAED,QAAI,CAACE,cAAc,CAACK,QAAf,CAAwBP,UAAxB,CAAL,EAA0C;AACzCE,MAAAA,cAAc,CAACM,IAAf,CAAoBR,UAApB;AACA;AACD;;AAEDS,EAAAA,WAAW,CAACV,SAAD,EAAYC,UAAZ,EAAwB;AAClC,UAAMC,aAAa,GAAG,KAAKL,cAA3B;AACA,UAAMM,cAAc,GAAGD,aAAa,CAACE,GAAd,CAAkBJ,SAAlB,CAAvB;;AAEA,QAAI,CAACG,cAAL,EAAqB;AACpB;AACA;;AACD,UAAMQ,iBAAiB,GAAGR,cAAc,CAACS,OAAf,CAAuBX,UAAvB,CAA1B;;AAEA,QAAIU,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC7BR,MAAAA,cAAc,CAACU,MAAf,CAAsBF,iBAAtB,EAAyC,CAAzC;AACA;;AAED,QAAIR,cAAc,CAACW,MAAf,KAA0B,CAA9B,EAAiC;AAChCZ,MAAAA,aAAa,CAACa,MAAd,CAAqBf,SAArB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCgB,EAAAA,SAAS,CAAChB,SAAD,EAAYiB,IAAZ,EAAkB;AAC1B,UAAMf,aAAa,GAAG,KAAKL,cAA3B;AACA,UAAMM,cAAc,GAAGD,aAAa,CAACE,GAAd,CAAkBJ,SAAlB,CAAvB;;AAEA,QAAI,CAACG,cAAL,EAAqB;AACpB,aAAO,EAAP;AACA;;AAED,WAAOA,cAAc,CAACe,GAAf,CAAmBC,EAAE,IAAI;AAC/B,aAAOA,EAAE,CAACC,IAAH,CAAQ,IAAR,EAAcH,IAAd,CAAP,CAD+B,CACH;AAC5B,KAFM,CAAP;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,cAAc,CAACrB,SAAD,EAAYiB,IAAZ,EAAkB;AAC/B,WAAOK,OAAO,CAACC,GAAR,CAAY,KAAKP,SAAL,CAAehB,SAAf,EAA0BiB,IAA1B,CAAZ,CAAP;AACA;;AAEDO,EAAAA,iBAAiB,CAACxB,SAAD,EAAYC,UAAZ,EAAwB;AACxC,UAAMC,aAAa,GAAG,KAAKL,cAA3B;AACA,UAAMM,cAAc,GAAGD,aAAa,CAACE,GAAd,CAAkBJ,SAAlB,CAAvB;;AAEA,QAAI,CAACG,cAAL,EAAqB;AACpB,aAAO,KAAP;AACA;;AAED,WAAOA,cAAc,CAACK,QAAf,CAAwBP,UAAxB,CAAP;AACA;;AAEDwB,EAAAA,YAAY,CAACzB,SAAD,EAAY;AACvB,WAAO,CAAC,CAAC,KAAKH,cAAL,CAAoBO,GAApB,CAAwBJ,SAAxB,CAAT;AACA;;AAjFkB;;AAoFpB,eAAeL,aAAf","sourcesContent":["class EventProvider {\n\tconstructor() {\n\t\tthis._eventRegistry = new Map();\n\t}\n\n\tattachEvent(eventName, fnFunction) {\n\t\tconst eventRegistry = this._eventRegistry;\n\t\tconst eventListeners = eventRegistry.get(eventName);\n\n\t\tif (!Array.isArray(eventListeners)) {\n\t\t\teventRegistry.set(eventName, [fnFunction]);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!eventListeners.includes(fnFunction)) {\n\t\t\teventListeners.push(fnFunction);\n\t\t}\n\t}\n\n\tdetachEvent(eventName, fnFunction) {\n\t\tconst eventRegistry = this._eventRegistry;\n\t\tconst eventListeners = eventRegistry.get(eventName);\n\n\t\tif (!eventListeners) {\n\t\t\treturn;\n\t\t}\n\t\tconst indexOfFnToDetach = eventListeners.indexOf(fnFunction);\n\n\t\tif (indexOfFnToDetach !== -1) {\n\t\t\teventListeners.splice(indexOfFnToDetach, 1);\n\t\t}\n\n\t\tif (eventListeners.length === 0) {\n\t\t\teventRegistry.delete(eventName);\n\t\t}\n\t}\n\n\t/**\n\t * Fires an event and returns the results of all event listeners as an array.\n\t *\n\t * @param eventName the event to fire\n\t * @param data optional data to pass to each event listener\n\t * @returns {Array} an array with the results of all event listeners\n\t */\n\tfireEvent(eventName, data) {\n\t\tconst eventRegistry = this._eventRegistry;\n\t\tconst eventListeners = eventRegistry.get(eventName);\n\n\t\tif (!eventListeners) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn eventListeners.map(fn => {\n\t\t\treturn fn.call(this, data); // eslint-disable-line\n\t\t});\n\t}\n\n\t/**\n\t * Fires an event and returns a promise that will resolve once all listeners have resolved.\n\t *\n\t * @param eventName the event to fire\n\t * @param data optional data to pass to each event listener\n\t * @returns {Promise} a promise that will resolve when all listeners have resolved\n\t */\n\tfireEventAsync(eventName, data) {\n\t\treturn Promise.all(this.fireEvent(eventName, data));\n\t}\n\n\tisHandlerAttached(eventName, fnFunction) {\n\t\tconst eventRegistry = this._eventRegistry;\n\t\tconst eventListeners = eventRegistry.get(eventName);\n\n\t\tif (!eventListeners) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn eventListeners.includes(fnFunction);\n\t}\n\n\thasListeners(eventName) {\n\t\treturn !!this._eventRegistry.get(eventName);\n\t}\n}\n\nexport default EventProvider;\n"]},"metadata":{},"sourceType":"module"}