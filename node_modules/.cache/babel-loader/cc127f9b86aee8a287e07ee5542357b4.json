{"ast":null,"code":"/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}; // package com.google.zxing.aztec.encoder;\n// import java.util.Deque;\n// import java.util.LinkedList;\n// import com.google.zxing.common.BitArray;\n\n\nimport BitArray from '../../common/BitArray';\nimport * as TokenHelpers from './TokenHelpers';\nimport * as C from './EncoderConstants';\nimport * as LatchTable from './LatchTable';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * State represents all information about a sequence necessary to generate the current output.\n * Note that a state is immutable.\n */\n\nvar State = function () {\n  function State(token, mode, binaryBytes, bitCount) {\n    this.token = token;\n    this.mode = mode;\n    this.binaryShiftByteCount = binaryBytes;\n    this.bitCount = bitCount; // Make sure we match the token\n    // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n    //    (binaryShiftByteCount === 0 ? 0 :\n    //     binaryShiftByteCount <= 31 ? 10 :\n    //     binaryShiftByteCount <= 62 ? 20 : 21);\n    // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n  }\n\n  State.prototype.getMode = function () {\n    return this.mode;\n  };\n\n  State.prototype.getToken = function () {\n    return this.token;\n  };\n\n  State.prototype.getBinaryShiftByteCount = function () {\n    return this.binaryShiftByteCount;\n  };\n\n  State.prototype.getBitCount = function () {\n    return this.bitCount;\n  }; // Create a new state representing this state with a latch to a (not\n  // necessary different) mode, and then a code.\n\n\n  State.prototype.latchAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0;\n    var bitCount = this.bitCount;\n    var token = this.token;\n\n    if (mode !== this.mode) {\n      var latch = LatchTable.LATCH_TABLE[this.mode][mode];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n    }\n\n    var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;\n    token = TokenHelpers.add(token, value, latchModeBitCount);\n    return new State(token, mode, 0, bitCount + latchModeBitCount);\n  }; // Create a new state representing this state, with a temporary shift\n  // to a different mode to output a single value.\n\n\n  State.prototype.shiftAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0 && this.mode !== mode;\n    var token = this.token;\n    var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5; // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n\n    token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n    token = TokenHelpers.add(token, value, 5);\n    return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n  }; // Create a new state representing this state, but an additional character\n  // output in Binary Shift mode.\n\n\n  State.prototype.addBinaryShiftChar = function (index) {\n    var token = this.token;\n    var mode = this.mode;\n    var bitCount = this.bitCount;\n\n    if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {\n      // assert binaryShiftByteCount === 0;\n      var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n      mode = C.MODE_UPPER;\n    }\n\n    var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;\n    var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n\n    if (result.binaryShiftByteCount === 2047 + 31) {\n      // The string is as long as it's allowed to be.  We should end it.\n      result = result.endBinaryShift(index + 1);\n    }\n\n    return result;\n  }; // Create the state identical to this one, but we are no longer in\n  // Binary Shift mode.\n\n\n  State.prototype.endBinaryShift = function (index) {\n    if (this.binaryShiftByteCount === 0) {\n      return this;\n    }\n\n    var token = this.token;\n    token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount); // assert token.getTotalBitCount() === this.bitCount;\n\n    return new State(token, this.mode, 0, this.bitCount);\n  }; // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n  // state under all possible circumstances.\n\n\n  State.prototype.isBetterThanOrEqualTo = function (other) {\n    var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);\n\n    if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n      // add additional B/S encoding cost of other, if any\n      newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);\n    } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {\n      // maximum possible additional cost (it: h)\n      newModeBitCount += 10;\n    }\n\n    return newModeBitCount <= other.bitCount;\n  };\n\n  State.prototype.toBitArray = function (text) {\n    var e_1, _a; // Reverse the tokens, so that they are in the order that they should\n    // be output\n\n\n    var symbols = [];\n\n    for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n      symbols.unshift(token);\n    }\n\n    var bitArray = new BitArray();\n\n    try {\n      // Add each token to the result.\n      for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n        var symbol = symbols_1_1.value;\n        symbol.appendTo(bitArray, text);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // assert bitArray.getSize() === this.bitCount;\n\n\n    return bitArray;\n  };\n  /**\n   * @Override\n   */\n\n\n  State.prototype.toString = function () {\n    return StringUtils.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n  };\n\n  State.calculateBinaryShiftCost = function (state) {\n    if (state.binaryShiftByteCount > 62) {\n      return 21; // B/S with extended length\n    }\n\n    if (state.binaryShiftByteCount > 31) {\n      return 20; // two B/S\n    }\n\n    if (state.binaryShiftByteCount > 0) {\n      return 10; // one B/S\n    }\n\n    return 0;\n  };\n\n  State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);\n  return State;\n}();\n\nexport default State;","map":{"version":3,"sources":["../../../../../src/core/aztec/encoder/State.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// package com.google.zxing.aztec.encoder;\n// import java.util.Deque;\n// import java.util.LinkedList;\n// import com.google.zxing.common.BitArray;\nimport BitArray from '../../common/BitArray';\nimport * as TokenHelpers from './TokenHelpers';\nimport * as C from './EncoderConstants';\nimport * as LatchTable from './LatchTable';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * State represents all information about a sequence necessary to generate the current output.\n * Note that a state is immutable.\n */\nvar State = /** @class */ (function () {\n    function State(token, mode, binaryBytes, bitCount) {\n        this.token = token;\n        this.mode = mode;\n        this.binaryShiftByteCount = binaryBytes;\n        this.bitCount = bitCount;\n        // Make sure we match the token\n        // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n        //    (binaryShiftByteCount === 0 ? 0 :\n        //     binaryShiftByteCount <= 31 ? 10 :\n        //     binaryShiftByteCount <= 62 ? 20 : 21);\n        // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n    }\n    State.prototype.getMode = function () {\n        return this.mode;\n    };\n    State.prototype.getToken = function () {\n        return this.token;\n    };\n    State.prototype.getBinaryShiftByteCount = function () {\n        return this.binaryShiftByteCount;\n    };\n    State.prototype.getBitCount = function () {\n        return this.bitCount;\n    };\n    // Create a new state representing this state with a latch to a (not\n    // necessary different) mode, and then a code.\n    State.prototype.latchAndAppend = function (mode, value) {\n        // assert binaryShiftByteCount === 0;\n        var bitCount = this.bitCount;\n        var token = this.token;\n        if (mode !== this.mode) {\n            var latch = LatchTable.LATCH_TABLE[this.mode][mode];\n            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n            bitCount += latch >> 16;\n        }\n        var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;\n        token = TokenHelpers.add(token, value, latchModeBitCount);\n        return new State(token, mode, 0, bitCount + latchModeBitCount);\n    };\n    // Create a new state representing this state, with a temporary shift\n    // to a different mode to output a single value.\n    State.prototype.shiftAndAppend = function (mode, value) {\n        // assert binaryShiftByteCount === 0 && this.mode !== mode;\n        var token = this.token;\n        var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5;\n        // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n        token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n        token = TokenHelpers.add(token, value, 5);\n        return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n    };\n    // Create a new state representing this state, but an additional character\n    // output in Binary Shift mode.\n    State.prototype.addBinaryShiftChar = function (index) {\n        var token = this.token;\n        var mode = this.mode;\n        var bitCount = this.bitCount;\n        if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {\n            // assert binaryShiftByteCount === 0;\n            var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];\n            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n            bitCount += latch >> 16;\n            mode = C.MODE_UPPER;\n        }\n        var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31\n            ? 18\n            : this.binaryShiftByteCount === 62\n                ? 9\n                : 8;\n        var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n        if (result.binaryShiftByteCount === 2047 + 31) {\n            // The string is as long as it's allowed to be.  We should end it.\n            result = result.endBinaryShift(index + 1);\n        }\n        return result;\n    };\n    // Create the state identical to this one, but we are no longer in\n    // Binary Shift mode.\n    State.prototype.endBinaryShift = function (index) {\n        if (this.binaryShiftByteCount === 0) {\n            return this;\n        }\n        var token = this.token;\n        token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n        // assert token.getTotalBitCount() === this.bitCount;\n        return new State(token, this.mode, 0, this.bitCount);\n    };\n    // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n    // state under all possible circumstances.\n    State.prototype.isBetterThanOrEqualTo = function (other) {\n        var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);\n        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n            // add additional B/S encoding cost of other, if any\n            newModeBitCount +=\n                State.calculateBinaryShiftCost(other) -\n                    State.calculateBinaryShiftCost(this);\n        }\n        else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&\n            other.binaryShiftByteCount > 0) {\n            // maximum possible additional cost (it: h)\n            newModeBitCount += 10;\n        }\n        return newModeBitCount <= other.bitCount;\n    };\n    State.prototype.toBitArray = function (text) {\n        var e_1, _a;\n        // Reverse the tokens, so that they are in the order that they should\n        // be output\n        var symbols = [];\n        for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n            symbols.unshift(token);\n        }\n        var bitArray = new BitArray();\n        try {\n            // Add each token to the result.\n            for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n                var symbol = symbols_1_1.value;\n                symbol.appendTo(bitArray, text);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // assert bitArray.getSize() === this.bitCount;\n        return bitArray;\n    };\n    /**\n     * @Override\n     */\n    State.prototype.toString = function () {\n        return StringUtils.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n    };\n    State.calculateBinaryShiftCost = function (state) {\n        if (state.binaryShiftByteCount > 62) {\n            return 21; // B/S with extended length\n        }\n        if (state.binaryShiftByteCount > 31) {\n            return 20; // two B/S\n        }\n        if (state.binaryShiftByteCount > 0) {\n            return 10; // one B/S\n        }\n        return 0;\n    };\n    State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);\n    return State;\n}());\nexport default State;\n//# sourceMappingURL=State.js.map"]},"metadata":{},"sourceType":"module"}