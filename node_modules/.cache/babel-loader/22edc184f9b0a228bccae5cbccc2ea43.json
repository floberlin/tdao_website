{"ast":null,"code":"import merge from \"./thirdparty/merge.js\";\nimport { boot } from \"./Boot.js\";\nimport UI5ElementMetadata from \"./UI5ElementMetadata.js\";\nimport EventProvider from \"./EventProvider.js\";\nimport getSingletonElementInstance from \"./util/getSingletonElementInstance.js\";\nimport StaticAreaItem from \"./StaticAreaItem.js\";\nimport updateShadowRoot from \"./updateShadowRoot.js\";\nimport { renderDeferred, renderImmediately, cancelRender } from \"./Render.js\";\nimport { registerTag, isTagRegistered, recordTagRegistrationFailure } from \"./CustomElementsRegistry.js\";\nimport { observeDOMNode, unobserveDOMNode } from \"./DOMObserver.js\";\nimport { skipOriginalEvent } from \"./config/NoConflict.js\";\nimport getEffectiveDir from \"./locale/getEffectiveDir.js\";\nimport DataType from \"./types/DataType.js\";\nimport { kebabToCamelCase, camelToKebabCase } from \"./util/StringHelper.js\";\nimport isValidPropertyName from \"./util/isValidPropertyName.js\";\nimport isDescendantOf from \"./util/isDescendantOf.js\";\nimport { isSlot, getSlotName, getSlottedElementsList } from \"./util/SlotsHelper.js\";\nimport arraysAreEqual from \"./util/arraysAreEqual.js\";\nimport getClassCopy from \"./util/getClassCopy.js\";\nimport { markAsRtlAware } from \"./locale/RTLAwareRegistry.js\";\nimport preloadLinks from \"./theming/preloadLinks.js\";\nlet autoId = 0;\nconst elementTimeouts = new Map();\nconst uniqueDependenciesCache = new Map();\n/**\n * Triggers re-rendering of a UI5Element instance due to state change.\n *\n * @param  changeInfo An object with information about the change that caused invalidation.\n * @private\n */\n\nfunction _invalidate(changeInfo) {\n  // Invalidation should be suppressed: 1) before the component is rendered for the first time 2) and during the execution of onBeforeRendering\n  // This is necessary not only as an optimization, but also to avoid infinite loops on invalidation between children and parents (when invalidateOnChildChange is used)\n  if (this._suppressInvalidation) {\n    return;\n  } // Call the onInvalidation hook\n\n\n  this.onInvalidation(changeInfo);\n\n  this._changedState.push(changeInfo);\n\n  renderDeferred(this);\n\n  this._eventProvider.fireEvent(\"invalidate\", { ...changeInfo,\n    target: this\n  });\n}\n/**\n * Base class for all UI5 Web Components\n *\n * @class\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.base.UI5Element\n * @extends HTMLElement\n * @public\n */\n\n\nclass UI5Element extends HTMLElement {\n  constructor() {\n    super();\n    this._changedState = []; // Filled on each invalidation, cleared on re-render (used for debugging)\n\n    this._suppressInvalidation = true; // A flag telling whether all invalidations should be ignored. Initialized with \"true\" because a UI5Element can not be invalidated until it is rendered for the first time\n\n    this._inDOM = false; // A flag telling whether the UI5Element is currently in the DOM tree of the document or not\n\n    this._fullyConnected = false; // A flag telling whether the UI5Element's onEnterDOM hook was called (since it's possible to have the element removed from DOM before that)\n\n    this._childChangeListeners = new Map(); // used to store lazy listeners per slot for the child change event of every child inside that slot\n\n    this._slotChangeListeners = new Map(); // used to store lazy listeners per slot for the slotchange event of all slot children inside that slot\n\n    this._eventProvider = new EventProvider(); // used by parent components for listening to changes to child components\n\n    let deferredResolve;\n    this._domRefReadyPromise = new Promise(resolve => {\n      deferredResolve = resolve;\n    });\n    this._domRefReadyPromise._deferredResolve = deferredResolve;\n\n    this._initializeState();\n\n    this._upgradeAllProperties();\n\n    if (this.constructor._needsShadowDOM()) {\n      this.attachShadow({\n        mode: \"open\"\n      });\n    }\n  }\n  /**\n   * Returns a unique ID for this UI5 Element\n   *\n   * @deprecated - This property is not guaranteed in future releases\n   * @protected\n   */\n\n\n  get _id() {\n    if (!this.__id) {\n      this.__id = `ui5wc_${++autoId}`;\n    }\n\n    return this.__id;\n  }\n  /**\n   * Do not call this method from derivatives of UI5Element, use \"onEnterDOM\" only\n   * @private\n   */\n\n\n  async connectedCallback() {\n    this.setAttribute(this.constructor.getMetadata().getPureTag(), \"\");\n    const slotsAreManaged = this.constructor.getMetadata().slotsAreManaged();\n    this._inDOM = true;\n\n    if (slotsAreManaged) {\n      // always register the observer before yielding control to the main thread (await)\n      this._startObservingDOMChildren();\n\n      await this._processChildren();\n    }\n\n    if (!this._inDOM) {\n      // Component removed from DOM while _processChildren was running\n      return;\n    }\n\n    renderImmediately(this);\n\n    this._domRefReadyPromise._deferredResolve();\n\n    this._fullyConnected = true;\n\n    if (typeof this.onEnterDOM === \"function\") {\n      this.onEnterDOM();\n    }\n  }\n  /**\n   * Do not call this method from derivatives of UI5Element, use \"onExitDOM\" only\n   * @private\n   */\n\n\n  disconnectedCallback() {\n    const slotsAreManaged = this.constructor.getMetadata().slotsAreManaged();\n    this._inDOM = false;\n\n    if (slotsAreManaged) {\n      this._stopObservingDOMChildren();\n    }\n\n    if (this._fullyConnected) {\n      if (typeof this.onExitDOM === \"function\") {\n        this.onExitDOM();\n      }\n\n      this._fullyConnected = false;\n    }\n\n    if (this.staticAreaItem && this.staticAreaItem.parentElement) {\n      this.staticAreaItem.parentElement.removeChild(this.staticAreaItem);\n    }\n\n    cancelRender(this);\n  }\n  /**\n   * @private\n   */\n\n\n  _startObservingDOMChildren() {\n    const shouldObserveChildren = this.constructor.getMetadata().hasSlots();\n\n    if (!shouldObserveChildren) {\n      return;\n    }\n\n    const canSlotText = this.constructor.getMetadata().canSlotText();\n    const mutationObserverOptions = {\n      childList: true,\n      subtree: canSlotText,\n      characterData: canSlotText\n    };\n    observeDOMNode(this, this._processChildren.bind(this), mutationObserverOptions);\n  }\n  /**\n   * @private\n   */\n\n\n  _stopObservingDOMChildren() {\n    unobserveDOMNode(this);\n  }\n  /**\n   * Note: this method is also manually called by \"compatibility/patchNodeValue.js\"\n   * @private\n   */\n\n\n  async _processChildren() {\n    const hasSlots = this.constructor.getMetadata().hasSlots();\n\n    if (hasSlots) {\n      await this._updateSlots();\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async _updateSlots() {\n    const slotsMap = this.constructor.getMetadata().getSlots();\n    const canSlotText = this.constructor.getMetadata().canSlotText();\n    const domChildren = Array.from(canSlotText ? this.childNodes : this.children);\n    const slotsCachedContentMap = new Map(); // Store here the content of each slot before the mutation occurred\n\n    const propertyNameToSlotMap = new Map(); // Used for reverse lookup to determine to which slot the property name corresponds\n    // Init the _state object based on the supported slots and store the previous values\n\n    for (const [slotName, slotData] of Object.entries(slotsMap)) {\n      // eslint-disable-line\n      const propertyName = slotData.propertyName || slotName;\n      propertyNameToSlotMap.set(propertyName, slotName);\n      slotsCachedContentMap.set(propertyName, [...this._state[propertyName]]);\n\n      this._clearSlot(slotName, slotData);\n    }\n\n    const autoIncrementMap = new Map();\n    const slottedChildrenMap = new Map();\n    const allChildrenUpgraded = domChildren.map(async (child, idx) => {\n      // Determine the type of the child (mainly by the slot attribute)\n      const slotName = getSlotName(child);\n      const slotData = slotsMap[slotName]; // Check if the slotName is supported\n\n      if (slotData === undefined) {\n        const validValues = Object.keys(slotsMap).join(\", \");\n        console.warn(`Unknown slotName: ${slotName}, ignoring`, child, `Valid values are: ${validValues}`); // eslint-disable-line\n\n        return;\n      } // For children that need individual slots, calculate them\n\n\n      if (slotData.individualSlots) {\n        const nextIndex = (autoIncrementMap.get(slotName) || 0) + 1;\n        autoIncrementMap.set(slotName, nextIndex);\n        child._individualSlot = `${slotName}-${nextIndex}`;\n      } // Await for not-yet-defined custom elements\n\n\n      if (child instanceof HTMLElement) {\n        const localName = child.localName;\n        const isCustomElement = localName.includes(\"-\");\n\n        if (isCustomElement) {\n          const isDefined = window.customElements.get(localName);\n\n          if (!isDefined) {\n            const whenDefinedPromise = window.customElements.whenDefined(localName); // Class registered, but instances not upgraded yet\n\n            let timeoutPromise = elementTimeouts.get(localName);\n\n            if (!timeoutPromise) {\n              timeoutPromise = new Promise(resolve => setTimeout(resolve, 1000));\n              elementTimeouts.set(localName, timeoutPromise);\n            }\n\n            await Promise.race([whenDefinedPromise, timeoutPromise]);\n          }\n\n          window.customElements.upgrade(child);\n        }\n      }\n\n      child = this.constructor.getMetadata().constructor.validateSlotValue(child, slotData); // Listen for any invalidation on the child if invalidateOnChildChange is true or an object (ignore when false or not set)\n\n      if (child.isUI5Element && slotData.invalidateOnChildChange) {\n        child.attachInvalidate(this._getChildChangeListener(slotName));\n      } // Listen for the slotchange event if the child is a slot itself\n\n\n      if (isSlot(child)) {\n        this._attachSlotChange(child, slotName);\n      }\n\n      const propertyName = slotData.propertyName || slotName;\n\n      if (slottedChildrenMap.has(propertyName)) {\n        slottedChildrenMap.get(propertyName).push({\n          child,\n          idx\n        });\n      } else {\n        slottedChildrenMap.set(propertyName, [{\n          child,\n          idx\n        }]);\n      }\n    });\n    await Promise.all(allChildrenUpgraded); // Distribute the child in the _state object, keeping the Light DOM order,\n    // not the order elements are defined.\n\n    slottedChildrenMap.forEach((children, propertyName) => {\n      this._state[propertyName] = children.sort((a, b) => a.idx - b.idx).map(_ => _.child);\n    }); // Compare the content of each slot with the cached values and invalidate for the ones that changed\n\n    let invalidated = false;\n\n    for (const [slotName, slotData] of Object.entries(slotsMap)) {\n      // eslint-disable-line\n      const propertyName = slotData.propertyName || slotName;\n\n      if (!arraysAreEqual(slotsCachedContentMap.get(propertyName), this._state[propertyName])) {\n        _invalidate.call(this, {\n          type: \"slot\",\n          name: propertyNameToSlotMap.get(propertyName),\n          reason: \"children\"\n        });\n\n        invalidated = true;\n      }\n    } // If none of the slots had an invalidation due to changes to immediate children,\n    // the change is considered to be text content of the default slot\n\n\n    if (!invalidated) {\n      _invalidate.call(this, {\n        type: \"slot\",\n        name: \"default\",\n        reason: \"textcontent\"\n      });\n    }\n  }\n  /**\n   * Removes all children from the slot and detaches listeners, if any\n   * @private\n   */\n\n\n  _clearSlot(slotName, slotData) {\n    const propertyName = slotData.propertyName || slotName;\n    const children = this._state[propertyName];\n    children.forEach(child => {\n      if (child && child.isUI5Element) {\n        child.detachInvalidate(this._getChildChangeListener(slotName));\n      }\n\n      if (isSlot(child)) {\n        this._detachSlotChange(child, slotName);\n      }\n    });\n    this._state[propertyName] = [];\n  }\n  /**\n   * Attach a callback that will be executed whenever the component is invalidated\n   *\n   * @param callback\n   * @public\n   */\n\n\n  attachInvalidate(callback) {\n    this._eventProvider.attachEvent(\"invalidate\", callback);\n  }\n  /**\n   * Detach the callback that is executed whenever the component is invalidated\n   *\n   * @param callback\n   * @public\n   */\n\n\n  detachInvalidate(callback) {\n    this._eventProvider.detachEvent(\"invalidate\", callback);\n  }\n  /**\n   * Callback that is executed whenever a monitored child changes its state\n   *\n   * @param slotName the slot in which a child was invalidated\n   * @param childChangeInfo the changeInfo object for the child in the given slot\n   * @private\n   */\n\n\n  _onChildChange(slotName, childChangeInfo) {\n    if (!this.constructor.getMetadata().shouldInvalidateOnChildChange(slotName, childChangeInfo.type, childChangeInfo.name)) {\n      return;\n    } // The component should be invalidated as this type of change on the child is listened for\n    // However, no matter what changed on the child (property/slot), the invalidation is registered as \"type=slot\" for the component itself\n\n\n    _invalidate.call(this, {\n      type: \"slot\",\n      name: slotName,\n      reason: \"childchange\",\n      child: childChangeInfo.target\n    });\n  }\n  /**\n   * Do not override this method in derivatives of UI5Element\n   * @private\n   */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    const properties = this.constructor.getMetadata().getProperties();\n    const realName = name.replace(/^ui5-/, \"\");\n    const nameInCamelCase = kebabToCamelCase(realName);\n\n    if (properties.hasOwnProperty(nameInCamelCase)) {\n      // eslint-disable-line\n      const propertyTypeClass = properties[nameInCamelCase].type;\n\n      if (propertyTypeClass === Boolean) {\n        newValue = newValue !== null;\n      } else if (isDescendantOf(propertyTypeClass, DataType)) {\n        newValue = propertyTypeClass.attributeToProperty(newValue);\n      }\n\n      this[nameInCamelCase] = newValue;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _updateAttribute(name, newValue) {\n    if (!this.constructor.getMetadata().hasAttribute(name)) {\n      return;\n    }\n\n    const properties = this.constructor.getMetadata().getProperties();\n    const propertyTypeClass = properties[name].type;\n    const attrName = camelToKebabCase(name);\n    const attrValue = this.getAttribute(attrName);\n\n    if (propertyTypeClass === Boolean) {\n      if (newValue === true && attrValue === null) {\n        this.setAttribute(attrName, \"\");\n      } else if (newValue === false && attrValue !== null) {\n        this.removeAttribute(attrName);\n      }\n    } else if (isDescendantOf(propertyTypeClass, DataType)) {\n      this.setAttribute(attrName, propertyTypeClass.propertyToAttribute(newValue));\n    } else if (typeof newValue !== \"object\") {\n      if (attrValue !== newValue) {\n        this.setAttribute(attrName, newValue);\n      }\n    } // else { return; } // old object handling\n\n  }\n  /**\n   * @private\n   */\n\n\n  _upgradeProperty(prop) {\n    if (this.hasOwnProperty(prop)) {\n      // eslint-disable-line\n      const value = this[prop];\n      delete this[prop];\n      this[prop] = value;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _upgradeAllProperties() {\n    const allProps = this.constructor.getMetadata().getPropertiesList();\n    allProps.forEach(this._upgradeProperty, this);\n  }\n  /**\n   * @private\n   */\n\n\n  _initializeState() {\n    this._state = { ...this.constructor.getMetadata().getInitialState()\n    };\n  }\n  /**\n   * Returns a singleton event listener for the \"change\" event of a child in a given slot\n   *\n   * @param slotName the name of the slot, where the child is\n   * @returns {any}\n   * @private\n   */\n\n\n  _getChildChangeListener(slotName) {\n    if (!this._childChangeListeners.has(slotName)) {\n      this._childChangeListeners.set(slotName, this._onChildChange.bind(this, slotName));\n    }\n\n    return this._childChangeListeners.get(slotName);\n  }\n  /**\n   * Returns a singleton slotchange event listener that invalidates the component due to changes in the given slot\n   *\n   * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n   * @returns {any}\n   * @private\n   */\n\n\n  _getSlotChangeListener(slotName) {\n    if (!this._slotChangeListeners.has(slotName)) {\n      this._slotChangeListeners.set(slotName, this._onSlotChange.bind(this, slotName));\n    }\n\n    return this._slotChangeListeners.get(slotName);\n  }\n  /**\n   * @private\n   */\n\n\n  _attachSlotChange(child, slotName) {\n    child.addEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n  }\n  /**\n   * @private\n   */\n\n\n  _detachSlotChange(child, slotName) {\n    child.removeEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n  }\n  /**\n   * Whenever a slot element is slotted inside a UI5 Web Component, its slotchange event invalidates the component\n   *\n   * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n   * @private\n   */\n\n\n  _onSlotChange(slotName) {\n    _invalidate.call(this, {\n      type: \"slot\",\n      name: slotName,\n      reason: \"slotchange\"\n    });\n  }\n  /**\n   * A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)\n   *\n   * @param  changeInfo An object with information about the change that caused invalidation.\n   * The object can have the following properties:\n   *  - type: (property|slot) tells what caused the invalidation\n   *   1) property: a property value was changed either directly or as a result of changing the corresponding attribute\n   *   2) slot: a slotted node(nodes) changed in one of several ways (see \"reason\")\n   *\n   *  - name: the name of the property or slot that caused the invalidation\n   *\n   *  - reason: (children|textcontent|childchange|slotchange) relevant only for type=\"slot\" only and tells exactly what changed in the slot\n   *   1) children: immediate children (HTML elements or text nodes) were added, removed or reordered in the slot\n   *   2) textcontent: text nodes in the slot changed value (or nested text nodes were added or changed value). Can only trigger for slots of \"type: Node\"\n   *   3) slotchange: a slot element, slotted inside that slot had its \"slotchange\" event listener called. This practically means that transitively slotted children changed.\n   *      Can only trigger if the child of a slot is a slot element itself.\n   *   4) childchange: indicates that a UI5Element child in that slot was invalidated and in turn invalidated the component.\n   *      Can only trigger for slots with \"invalidateOnChildChange\" metadata descriptor\n   *\n   *  - newValue: the new value of the property (for type=\"property\" only)\n   *\n   *  - oldValue: the old value of the property (for type=\"property\" only)\n   *\n   *  - child the child that was changed (for type=\"slot\" and reason=\"childchange\" only)\n   *\n   * @public\n   */\n\n\n  onInvalidation(changeInfo) {}\n  /**\n   * Do not call this method directly, only intended to be called by js\n   * @protected\n   */\n\n\n  _render() {\n    const hasIndividualSlots = this.constructor.getMetadata().hasIndividualSlots(); // suppress invalidation to prevent state changes scheduling another rendering\n\n    this._suppressInvalidation = true;\n\n    if (typeof this.onBeforeRendering === \"function\") {\n      this.onBeforeRendering();\n    } // Intended for framework usage only. Currently ItemNavigation updates tab indexes after the component has updated its state but before the template is rendered\n\n\n    if (this._onComponentStateFinalized) {\n      this._onComponentStateFinalized();\n    } // resume normal invalidation handling\n\n\n    this._suppressInvalidation = false; // Update the shadow root with the render result\n\n    /*\n    if (this._changedState.length) {\n    \tlet element = this.localName;\n    \tif (this.id) {\n    \t\telement = `${element}#${this.id}`;\n    \t}\n    \tconsole.log(\"Re-rendering:\", element, this._changedState.map(x => { // eslint-disable-line\n    \t\tlet res = `${x.type}`;\n    \t\tif (x.reason) {\n    \t\t\tres = `${res}(${x.reason})`;\n    \t\t}\n    \t\tres = `${res}: ${x.name}`;\n    \t\tif (x.type === \"property\") {\n    \t\t\tres = `${res} ${x.oldValue} => ${x.newValue}`;\n    \t\t}\n    \t\t\treturn res;\n    \t}));\n    }\n    */\n\n    this._changedState = []; // Update shadow root and static area item\n\n    if (this.constructor._needsShadowDOM()) {\n      updateShadowRoot(this);\n    }\n\n    if (this.staticAreaItem) {\n      this.staticAreaItem.update();\n    } // Safari requires that children get the slot attribute only after the slot tags have been rendered in the shadow DOM\n\n\n    if (hasIndividualSlots) {\n      this._assignIndividualSlotsToChildren();\n    } // Call the onAfterRendering hook\n\n\n    if (typeof this.onAfterRendering === \"function\") {\n      this.onAfterRendering();\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _assignIndividualSlotsToChildren() {\n    const domChildren = Array.from(this.children);\n    domChildren.forEach(child => {\n      if (child._individualSlot) {\n        child.setAttribute(\"slot\", child._individualSlot);\n      }\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _waitForDomRef() {\n    return this._domRefReadyPromise;\n  }\n  /**\n   * Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template\n   * *Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option\n   * Use this method instead of \"this.shadowRoot\" to read the Shadow DOM, if ever necessary\n   *\n   * @public\n   */\n\n\n  getDomRef() {\n    // If a component set _getRealDomRef to its children, use the return value of this function\n    if (typeof this._getRealDomRef === \"function\") {\n      return this._getRealDomRef();\n    }\n\n    if (!this.shadowRoot || this.shadowRoot.children.length === 0) {\n      return;\n    }\n\n    const children = [...this.shadowRoot.children].filter(child => ![\"link\", \"style\"].includes(child.localName));\n\n    if (children.length !== 1) {\n      console.warn(`The shadow DOM for ${this.constructor.getMetadata().getTag()} does not have a top level element, the getDomRef() method might not work as expected`); // eslint-disable-line\n    }\n\n    return children[0];\n  }\n  /**\n   * Returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n   * This is the element that will receive the focus by default.\n   * @public\n   */\n\n\n  getFocusDomRef() {\n    const domRef = this.getDomRef();\n\n    if (domRef) {\n      const focusRef = domRef.querySelector(\"[data-sap-focus-ref]\");\n      return focusRef || domRef;\n    }\n  }\n  /**\n   * Waits for dom ref and then returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n   * This is the element that will receive the focus by default.\n   * @public\n   */\n\n\n  async getFocusDomRefAsync() {\n    await this._waitForDomRef();\n    return this.getFocusDomRef();\n  }\n  /**\n   * Set the focus to the element, returned by \"getFocusDomRef()\" (marked by \"data-sap-focus-ref\")\n   * @public\n   */\n\n\n  async focus() {\n    await this._waitForDomRef();\n    const focusDomRef = this.getFocusDomRef();\n\n    if (focusDomRef && typeof focusDomRef.focus === \"function\") {\n      focusDomRef.focus();\n    }\n  }\n  /**\n   *\n   * @public\n   * @param name - name of the event\n   * @param data - additional data for the event\n   * @param cancelable - true, if the user can call preventDefault on the event object\n   * @param bubbles - true, if the event bubbles\n   * @returns {boolean} false, if the event was cancelled (preventDefault called), true otherwise\n   */\n\n\n  fireEvent(name, data, cancelable = false, bubbles = true) {\n    const eventResult = this._fireEvent(name, data, cancelable, bubbles);\n\n    const camelCaseEventName = kebabToCamelCase(name);\n\n    if (camelCaseEventName !== name) {\n      return eventResult && this._fireEvent(camelCaseEventName, data, cancelable);\n    }\n\n    return eventResult;\n  }\n\n  _fireEvent(name, data, cancelable = false, bubbles = true) {\n    const noConflictEvent = new CustomEvent(`ui5-${name}`, {\n      detail: data,\n      composed: false,\n      bubbles,\n      cancelable\n    }); // This will be false if the no-conflict event is prevented\n\n    const noConflictEventResult = this.dispatchEvent(noConflictEvent);\n\n    if (skipOriginalEvent(name)) {\n      return noConflictEventResult;\n    }\n\n    const normalEvent = new CustomEvent(name, {\n      detail: data,\n      composed: false,\n      bubbles,\n      cancelable\n    }); // This will be false if the normal event is prevented\n\n    const normalEventResult = this.dispatchEvent(normalEvent); // Return false if any of the two events was prevented (its result was false).\n\n    return normalEventResult && noConflictEventResult;\n  }\n  /**\n   * Returns the actual children, associated with a slot.\n   * Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.\n   * @public\n   */\n\n\n  getSlottedNodes(slotName) {\n    return getSlottedElementsList(this[slotName]);\n  }\n  /**\n   * Determines whether the component should be rendered in RTL mode or not.\n   * Returns: \"rtl\", \"ltr\" or undefined\n   *\n   * @public\n   * @returns {String|undefined}\n   */\n\n\n  get effectiveDir() {\n    markAsRtlAware(this.constructor); // if a UI5 Element calls this method, it's considered to be rtl-aware\n\n    return getEffectiveDir(this);\n  }\n  /**\n   * Used to duck-type UI5 elements without using instanceof\n   * @returns {boolean}\n   * @public\n   */\n\n\n  get isUI5Element() {\n    return true;\n  }\n  /**\n   * Do not override this method in derivatives of UI5Element, use metadata properties instead\n   * @private\n   */\n\n\n  static get observedAttributes() {\n    return this.getMetadata().getAttributesList();\n  }\n  /**\n   * @private\n   */\n\n\n  static _needsShadowDOM() {\n    return !!this.template;\n  }\n  /**\n   * @private\n   */\n\n\n  static _needsStaticArea() {\n    return !!this.staticAreaTemplate;\n  }\n  /**\n   * @public\n   */\n\n\n  getStaticAreaItemDomRef() {\n    if (!this.constructor._needsStaticArea()) {\n      throw new Error(\"This component does not use the static area\");\n    }\n\n    if (!this.staticAreaItem) {\n      this.staticAreaItem = StaticAreaItem.createInstance();\n      this.staticAreaItem.setOwnerElement(this);\n    }\n\n    if (!this.staticAreaItem.parentElement) {\n      getSingletonElementInstance(\"ui5-static-area\").appendChild(this.staticAreaItem);\n    }\n\n    return this.staticAreaItem.getDomRef();\n  }\n  /**\n   * @private\n   */\n\n\n  static _generateAccessors() {\n    const proto = this.prototype;\n    const slotsAreManaged = this.getMetadata().slotsAreManaged(); // Properties\n\n    const properties = this.getMetadata().getProperties();\n\n    for (const [prop, propData] of Object.entries(properties)) {\n      // eslint-disable-line\n      if (!isValidPropertyName(prop)) {\n        console.warn(`\"${prop}\" is not a valid property name. Use a name that does not collide with DOM APIs`);\n        /* eslint-disable-line */\n      }\n\n      if (propData.type === Boolean && propData.defaultValue) {\n        throw new Error(`Cannot set a default value for property \"${prop}\". All booleans are false by default.`);\n      }\n\n      if (propData.type === Array) {\n        throw new Error(`Wrong type for property \"${prop}\". Properties cannot be of type Array - use \"multiple: true\" and set \"type\" to the single value type, such as \"String\", \"Object\", etc...`);\n      }\n\n      if (propData.type === Object && propData.defaultValue) {\n        throw new Error(`Cannot set a default value for property \"${prop}\". All properties of type \"Object\" are empty objects by default.`);\n      }\n\n      if (propData.multiple && propData.defaultValue) {\n        throw new Error(`Cannot set a default value for property \"${prop}\". All multiple properties are empty arrays by default.`);\n      }\n\n      Object.defineProperty(proto, prop, {\n        get() {\n          if (this._state[prop] !== undefined) {\n            return this._state[prop];\n          }\n\n          const propDefaultValue = propData.defaultValue;\n\n          if (propData.type === Boolean) {\n            return false;\n          } else if (propData.type === String) {\n            // eslint-disable-line\n            return propDefaultValue;\n          } else if (propData.multiple) {\n            // eslint-disable-line\n            return [];\n          } else {\n            return propDefaultValue;\n          }\n        },\n\n        set(value) {\n          let isDifferent;\n          value = this.constructor.getMetadata().constructor.validatePropertyValue(value, propData);\n          const oldState = this._state[prop];\n\n          if (propData.multiple && propData.compareValues) {\n            isDifferent = !arraysAreEqual(oldState, value);\n          } else if (isDescendantOf(propData.type, DataType)) {\n            isDifferent = !propData.type.valuesAreEqual(oldState, value);\n          } else {\n            isDifferent = oldState !== value;\n          }\n\n          if (isDifferent) {\n            this._state[prop] = value;\n\n            _invalidate.call(this, {\n              type: \"property\",\n              name: prop,\n              newValue: value,\n              oldValue: oldState\n            });\n\n            this._updateAttribute(prop, value);\n          }\n        }\n\n      });\n    } // Slots\n\n\n    if (slotsAreManaged) {\n      const slots = this.getMetadata().getSlots();\n\n      for (const [slotName, slotData] of Object.entries(slots)) {\n        // eslint-disable-line\n        if (!isValidPropertyName(slotName)) {\n          console.warn(`\"${slotName}\" is not a valid property name. Use a name that does not collide with DOM APIs`);\n          /* eslint-disable-line */\n        }\n\n        const propertyName = slotData.propertyName || slotName;\n        Object.defineProperty(proto, propertyName, {\n          get() {\n            if (this._state[propertyName] !== undefined) {\n              return this._state[propertyName];\n            }\n\n            return [];\n          },\n\n          set() {\n            throw new Error(\"Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)\");\n          }\n\n        });\n      }\n    }\n  }\n  /**\n   * Returns the metadata object for this UI5 Web Component Class\n   * @protected\n   */\n\n\n  static get metadata() {\n    return {};\n  }\n  /**\n   * Returns the CSS for this UI5 Web Component Class\n   * @protected\n   */\n\n\n  static get styles() {\n    return \"\";\n  }\n  /**\n   * Returns the Static Area CSS for this UI5 Web Component Class\n   * @protected\n   */\n\n\n  static get staticAreaStyles() {\n    return \"\";\n  }\n  /**\n   * Returns an array with the dependencies for this UI5 Web Component, which could be:\n   *  - composed components (used in its shadow root or static area item)\n   *  - slotted components that the component may need to communicate with\n   *\n   * @protected\n   */\n\n\n  static get dependencies() {\n    return [];\n  }\n  /**\n   * Returns a list of the unique dependencies for this UI5 Web Component\n   *\n   * @public\n   */\n\n\n  static getUniqueDependencies() {\n    if (!uniqueDependenciesCache.has(this)) {\n      const filtered = this.dependencies.filter((dep, index, deps) => deps.indexOf(dep) === index);\n      uniqueDependenciesCache.set(this, filtered);\n    }\n\n    return uniqueDependenciesCache.get(this);\n  }\n  /**\n   * Returns a promise that resolves whenever all dependencies for this UI5 Web Component have resolved\n   *\n   * @returns {Promise<any[]>}\n   */\n\n\n  static whenDependenciesDefined() {\n    return Promise.all(this.getUniqueDependencies().map(dep => dep.define()));\n  }\n  /**\n   * Hook that will be called upon custom element definition\n   *\n   * @protected\n   * @returns {Promise<void>}\n   */\n\n\n  static async onDefine() {\n    return Promise.resolve();\n  }\n  /**\n   * Registers a UI5 Web Component in the browser window object\n   * @public\n   * @returns {Promise<UI5Element>}\n   */\n\n\n  static async define() {\n    await boot();\n    await Promise.all([this.whenDependenciesDefined(), this.onDefine()]);\n    const tag = this.getMetadata().getTag();\n    const altTag = this.getMetadata().getAltTag();\n    const definedLocally = isTagRegistered(tag);\n    const definedGlobally = customElements.get(tag);\n\n    if (definedGlobally && !definedLocally) {\n      recordTagRegistrationFailure(tag);\n    } else if (!definedGlobally) {\n      this._generateAccessors();\n\n      registerTag(tag);\n      window.customElements.define(tag, this);\n      preloadLinks(this);\n\n      if (altTag && !customElements.get(altTag)) {\n        registerTag(altTag);\n        window.customElements.define(altTag, getClassCopy(this, () => {\n          console.log(`The ${altTag} tag is deprecated and will be removed in the next release, please use ${tag} instead.`); // eslint-disable-line\n        }));\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns an instance of UI5ElementMetadata.js representing this UI5 Web Component's full metadata (its and its parents')\n   * Note: not to be confused with the \"get metadata()\" method, which returns an object for this class's metadata only\n   * @public\n   * @returns {UI5ElementMetadata}\n   */\n\n\n  static getMetadata() {\n    if (this.hasOwnProperty(\"_metadata\")) {\n      // eslint-disable-line\n      return this._metadata;\n    }\n\n    const metadataObjects = [this.metadata];\n    let klass = this; // eslint-disable-line\n\n    while (klass !== UI5Element) {\n      klass = Object.getPrototypeOf(klass);\n      metadataObjects.unshift(klass.metadata);\n    }\n\n    const mergedMetadata = merge({}, ...metadataObjects);\n    this._metadata = new UI5ElementMetadata(mergedMetadata);\n    return this._metadata;\n  }\n\n}\n\nexport default UI5Element;","map":{"version":3,"sources":["/Users/flo/Desktop/mdao.fioriapp/node_modules/@ui5/webcomponents-base/dist/UI5Element.js"],"names":["merge","boot","UI5ElementMetadata","EventProvider","getSingletonElementInstance","StaticAreaItem","updateShadowRoot","renderDeferred","renderImmediately","cancelRender","registerTag","isTagRegistered","recordTagRegistrationFailure","observeDOMNode","unobserveDOMNode","skipOriginalEvent","getEffectiveDir","DataType","kebabToCamelCase","camelToKebabCase","isValidPropertyName","isDescendantOf","isSlot","getSlotName","getSlottedElementsList","arraysAreEqual","getClassCopy","markAsRtlAware","preloadLinks","autoId","elementTimeouts","Map","uniqueDependenciesCache","_invalidate","changeInfo","_suppressInvalidation","onInvalidation","_changedState","push","_eventProvider","fireEvent","target","UI5Element","HTMLElement","constructor","_inDOM","_fullyConnected","_childChangeListeners","_slotChangeListeners","deferredResolve","_domRefReadyPromise","Promise","resolve","_deferredResolve","_initializeState","_upgradeAllProperties","_needsShadowDOM","attachShadow","mode","_id","__id","connectedCallback","setAttribute","getMetadata","getPureTag","slotsAreManaged","_startObservingDOMChildren","_processChildren","onEnterDOM","disconnectedCallback","_stopObservingDOMChildren","onExitDOM","staticAreaItem","parentElement","removeChild","shouldObserveChildren","hasSlots","canSlotText","mutationObserverOptions","childList","subtree","characterData","bind","_updateSlots","slotsMap","getSlots","domChildren","Array","from","childNodes","children","slotsCachedContentMap","propertyNameToSlotMap","slotName","slotData","Object","entries","propertyName","set","_state","_clearSlot","autoIncrementMap","slottedChildrenMap","allChildrenUpgraded","map","child","idx","undefined","validValues","keys","join","console","warn","individualSlots","nextIndex","get","_individualSlot","localName","isCustomElement","includes","isDefined","window","customElements","whenDefinedPromise","whenDefined","timeoutPromise","setTimeout","race","upgrade","validateSlotValue","isUI5Element","invalidateOnChildChange","attachInvalidate","_getChildChangeListener","_attachSlotChange","has","all","forEach","sort","a","b","_","invalidated","call","type","name","reason","detachInvalidate","_detachSlotChange","callback","attachEvent","detachEvent","_onChildChange","childChangeInfo","shouldInvalidateOnChildChange","attributeChangedCallback","oldValue","newValue","properties","getProperties","realName","replace","nameInCamelCase","hasOwnProperty","propertyTypeClass","Boolean","attributeToProperty","_updateAttribute","hasAttribute","attrName","attrValue","getAttribute","removeAttribute","propertyToAttribute","_upgradeProperty","prop","value","allProps","getPropertiesList","getInitialState","_getSlotChangeListener","_onSlotChange","addEventListener","removeEventListener","_render","hasIndividualSlots","onBeforeRendering","_onComponentStateFinalized","update","_assignIndividualSlotsToChildren","onAfterRendering","_waitForDomRef","getDomRef","_getRealDomRef","shadowRoot","length","filter","getTag","getFocusDomRef","domRef","focusRef","querySelector","getFocusDomRefAsync","focus","focusDomRef","data","cancelable","bubbles","eventResult","_fireEvent","camelCaseEventName","noConflictEvent","CustomEvent","detail","composed","noConflictEventResult","dispatchEvent","normalEvent","normalEventResult","getSlottedNodes","effectiveDir","observedAttributes","getAttributesList","template","_needsStaticArea","staticAreaTemplate","getStaticAreaItemDomRef","Error","createInstance","setOwnerElement","appendChild","_generateAccessors","proto","prototype","propData","defaultValue","multiple","defineProperty","propDefaultValue","String","isDifferent","validatePropertyValue","oldState","compareValues","valuesAreEqual","slots","metadata","styles","staticAreaStyles","dependencies","getUniqueDependencies","filtered","dep","index","deps","indexOf","whenDependenciesDefined","define","onDefine","tag","altTag","getAltTag","definedLocally","definedGlobally","log","_metadata","metadataObjects","klass","getPrototypeOf","unshift","mergedMetadata"],"mappings":"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","sourcesContent":["import merge from \"./thirdparty/merge.js\";\nimport { boot } from \"./Boot.js\";\nimport UI5ElementMetadata from \"./UI5ElementMetadata.js\";\nimport EventProvider from \"./EventProvider.js\";\nimport getSingletonElementInstance from \"./util/getSingletonElementInstance.js\";\nimport StaticAreaItem from \"./StaticAreaItem.js\";\nimport updateShadowRoot from \"./updateShadowRoot.js\";\nimport { renderDeferred, renderImmediately, cancelRender } from \"./Render.js\";\nimport { registerTag, isTagRegistered, recordTagRegistrationFailure } from \"./CustomElementsRegistry.js\";\nimport { observeDOMNode, unobserveDOMNode } from \"./DOMObserver.js\";\nimport { skipOriginalEvent } from \"./config/NoConflict.js\";\nimport getEffectiveDir from \"./locale/getEffectiveDir.js\";\nimport DataType from \"./types/DataType.js\";\nimport { kebabToCamelCase, camelToKebabCase } from \"./util/StringHelper.js\";\nimport isValidPropertyName from \"./util/isValidPropertyName.js\";\nimport isDescendantOf from \"./util/isDescendantOf.js\";\nimport { isSlot, getSlotName, getSlottedElementsList } from \"./util/SlotsHelper.js\";\nimport arraysAreEqual from \"./util/arraysAreEqual.js\";\nimport getClassCopy from \"./util/getClassCopy.js\";\nimport { markAsRtlAware } from \"./locale/RTLAwareRegistry.js\";\nimport preloadLinks from \"./theming/preloadLinks.js\";\n\nlet autoId = 0;\n\nconst elementTimeouts = new Map();\nconst uniqueDependenciesCache = new Map();\n\n/**\n * Triggers re-rendering of a UI5Element instance due to state change.\n *\n * @param  changeInfo An object with information about the change that caused invalidation.\n * @private\n */\nfunction _invalidate(changeInfo) {\n\t// Invalidation should be suppressed: 1) before the component is rendered for the first time 2) and during the execution of onBeforeRendering\n\t// This is necessary not only as an optimization, but also to avoid infinite loops on invalidation between children and parents (when invalidateOnChildChange is used)\n\tif (this._suppressInvalidation) {\n\t\treturn;\n\t}\n\n\t// Call the onInvalidation hook\n\tthis.onInvalidation(changeInfo);\n\n\tthis._changedState.push(changeInfo);\n\trenderDeferred(this);\n\tthis._eventProvider.fireEvent(\"invalidate\", { ...changeInfo, target: this });\n}\n\n/**\n * Base class for all UI5 Web Components\n *\n * @class\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.base.UI5Element\n * @extends HTMLElement\n * @public\n */\nclass UI5Element extends HTMLElement {\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._changedState = []; // Filled on each invalidation, cleared on re-render (used for debugging)\n\t\tthis._suppressInvalidation = true; // A flag telling whether all invalidations should be ignored. Initialized with \"true\" because a UI5Element can not be invalidated until it is rendered for the first time\n\t\tthis._inDOM = false; // A flag telling whether the UI5Element is currently in the DOM tree of the document or not\n\t\tthis._fullyConnected = false; // A flag telling whether the UI5Element's onEnterDOM hook was called (since it's possible to have the element removed from DOM before that)\n\t\tthis._childChangeListeners = new Map(); // used to store lazy listeners per slot for the child change event of every child inside that slot\n\t\tthis._slotChangeListeners = new Map(); // used to store lazy listeners per slot for the slotchange event of all slot children inside that slot\n\t\tthis._eventProvider = new EventProvider(); // used by parent components for listening to changes to child components\n\t\tlet deferredResolve;\n\t\tthis._domRefReadyPromise = new Promise(resolve => {\n\t\t\tdeferredResolve = resolve;\n\t\t});\n\t\tthis._domRefReadyPromise._deferredResolve = deferredResolve;\n\n\t\tthis._initializeState();\n\t\tthis._upgradeAllProperties();\n\n\t\tif (this.constructor._needsShadowDOM()) {\n\t\t\tthis.attachShadow({ mode: \"open\" });\n\t\t}\n\t}\n\n\t/**\n\t * Returns a unique ID for this UI5 Element\n\t *\n\t * @deprecated - This property is not guaranteed in future releases\n\t * @protected\n\t */\n\tget _id() {\n\t\tif (!this.__id) {\n\t\t\tthis.__id = `ui5wc_${++autoId}`;\n\t\t}\n\n\t\treturn this.__id;\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onEnterDOM\" only\n\t * @private\n\t */\n\tasync connectedCallback() {\n\t\tthis.setAttribute(this.constructor.getMetadata().getPureTag(), \"\");\n\n\t\tconst slotsAreManaged = this.constructor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = true;\n\n\t\tif (slotsAreManaged) {\n\t\t\t// always register the observer before yielding control to the main thread (await)\n\t\t\tthis._startObservingDOMChildren();\n\t\t\tawait this._processChildren();\n\t\t}\n\n\t\tif (!this._inDOM) { // Component removed from DOM while _processChildren was running\n\t\t\treturn;\n\t\t}\n\n\t\trenderImmediately(this);\n\t\tthis._domRefReadyPromise._deferredResolve();\n\t\tthis._fullyConnected = true;\n\t\tif (typeof this.onEnterDOM === \"function\") {\n\t\t\tthis.onEnterDOM();\n\t\t}\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onExitDOM\" only\n\t * @private\n\t */\n\tdisconnectedCallback() {\n\t\tconst slotsAreManaged = this.constructor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = false;\n\n\t\tif (slotsAreManaged) {\n\t\t\tthis._stopObservingDOMChildren();\n\t\t}\n\n\t\tif (this._fullyConnected) {\n\t\t\tif (typeof this.onExitDOM === \"function\") {\n\t\t\t\tthis.onExitDOM();\n\t\t\t}\n\t\t\tthis._fullyConnected = false;\n\t\t}\n\n\t\tif (this.staticAreaItem && this.staticAreaItem.parentElement) {\n\t\t\tthis.staticAreaItem.parentElement.removeChild(this.staticAreaItem);\n\t\t}\n\n\t\tcancelRender(this);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_startObservingDOMChildren() {\n\t\tconst shouldObserveChildren = this.constructor.getMetadata().hasSlots();\n\t\tif (!shouldObserveChildren) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst canSlotText = this.constructor.getMetadata().canSlotText();\n\t\tconst mutationObserverOptions = {\n\t\t\tchildList: true,\n\t\t\tsubtree: canSlotText,\n\t\t\tcharacterData: canSlotText,\n\t\t};\n\t\tobserveDOMNode(this, this._processChildren.bind(this), mutationObserverOptions);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_stopObservingDOMChildren() {\n\t\tunobserveDOMNode(this);\n\t}\n\n\t/**\n\t * Note: this method is also manually called by \"compatibility/patchNodeValue.js\"\n\t * @private\n\t */\n\tasync _processChildren() {\n\t\tconst hasSlots = this.constructor.getMetadata().hasSlots();\n\t\tif (hasSlots) {\n\t\t\tawait this._updateSlots();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tasync _updateSlots() {\n\t\tconst slotsMap = this.constructor.getMetadata().getSlots();\n\t\tconst canSlotText = this.constructor.getMetadata().canSlotText();\n\t\tconst domChildren = Array.from(canSlotText ? this.childNodes : this.children);\n\n\t\tconst slotsCachedContentMap = new Map(); // Store here the content of each slot before the mutation occurred\n\t\tconst propertyNameToSlotMap = new Map(); // Used for reverse lookup to determine to which slot the property name corresponds\n\n\t\t// Init the _state object based on the supported slots and store the previous values\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tpropertyNameToSlotMap.set(propertyName, slotName);\n\t\t\tslotsCachedContentMap.set(propertyName, [...this._state[propertyName]]);\n\t\t\tthis._clearSlot(slotName, slotData);\n\t\t}\n\n\t\tconst autoIncrementMap = new Map();\n\t\tconst slottedChildrenMap = new Map();\n\n\t\tconst allChildrenUpgraded = domChildren.map(async (child, idx) => {\n\t\t\t// Determine the type of the child (mainly by the slot attribute)\n\t\t\tconst slotName = getSlotName(child);\n\t\t\tconst slotData = slotsMap[slotName];\n\n\t\t\t// Check if the slotName is supported\n\t\t\tif (slotData === undefined) {\n\t\t\t\tconst validValues = Object.keys(slotsMap).join(\", \");\n\t\t\t\tconsole.warn(`Unknown slotName: ${slotName}, ignoring`, child, `Valid values are: ${validValues}`); // eslint-disable-line\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For children that need individual slots, calculate them\n\t\t\tif (slotData.individualSlots) {\n\t\t\t\tconst nextIndex = (autoIncrementMap.get(slotName) || 0) + 1;\n\t\t\t\tautoIncrementMap.set(slotName, nextIndex);\n\t\t\t\tchild._individualSlot = `${slotName}-${nextIndex}`;\n\t\t\t}\n\n\t\t\t// Await for not-yet-defined custom elements\n\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\tconst localName = child.localName;\n\t\t\t\tconst isCustomElement = localName.includes(\"-\");\n\t\t\t\tif (isCustomElement) {\n\t\t\t\t\tconst isDefined = window.customElements.get(localName);\n\t\t\t\t\tif (!isDefined) {\n\t\t\t\t\t\tconst whenDefinedPromise = window.customElements.whenDefined(localName); // Class registered, but instances not upgraded yet\n\t\t\t\t\t\tlet timeoutPromise = elementTimeouts.get(localName);\n\t\t\t\t\t\tif (!timeoutPromise) {\n\t\t\t\t\t\t\ttimeoutPromise = new Promise(resolve => setTimeout(resolve, 1000));\n\t\t\t\t\t\t\telementTimeouts.set(localName, timeoutPromise);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait Promise.race([whenDefinedPromise, timeoutPromise]);\n\t\t\t\t\t}\n\t\t\t\t\twindow.customElements.upgrade(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild = this.constructor.getMetadata().constructor.validateSlotValue(child, slotData);\n\n\t\t\t// Listen for any invalidation on the child if invalidateOnChildChange is true or an object (ignore when false or not set)\n\t\t\tif (child.isUI5Element && slotData.invalidateOnChildChange) {\n\t\t\t\tchild.attachInvalidate(this._getChildChangeListener(slotName));\n\t\t\t}\n\n\t\t\t// Listen for the slotchange event if the child is a slot itself\n\t\t\tif (isSlot(child)) {\n\t\t\t\tthis._attachSlotChange(child, slotName);\n\t\t\t}\n\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\n\t\t\tif (slottedChildrenMap.has(propertyName)) {\n\t\t\t\tslottedChildrenMap.get(propertyName).push({ child, idx });\n\t\t\t} else {\n\t\t\t\tslottedChildrenMap.set(propertyName, [{ child, idx }]);\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all(allChildrenUpgraded);\n\n\t\t// Distribute the child in the _state object, keeping the Light DOM order,\n\t\t// not the order elements are defined.\n\t\tslottedChildrenMap.forEach((children, propertyName) => {\n\t\t\tthis._state[propertyName] = children.sort((a, b) => a.idx - b.idx).map(_ => _.child);\n\t\t});\n\n\t\t// Compare the content of each slot with the cached values and invalidate for the ones that changed\n\t\tlet invalidated = false;\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tif (!arraysAreEqual(slotsCachedContentMap.get(propertyName), this._state[propertyName])) {\n\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\ttype: \"slot\",\n\t\t\t\t\tname: propertyNameToSlotMap.get(propertyName),\n\t\t\t\t\treason: \"children\",\n\t\t\t\t});\n\t\t\t\tinvalidated = true;\n\t\t\t}\n\t\t}\n\n\t\t// If none of the slots had an invalidation due to changes to immediate children,\n\t\t// the change is considered to be text content of the default slot\n\t\tif (!invalidated) {\n\t\t\t_invalidate.call(this, {\n\t\t\t\ttype: \"slot\",\n\t\t\t\tname: \"default\",\n\t\t\t\treason: \"textcontent\",\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Removes all children from the slot and detaches listeners, if any\n\t * @private\n\t */\n\t_clearSlot(slotName, slotData) {\n\t\tconst propertyName = slotData.propertyName || slotName;\n\t\tconst children = this._state[propertyName];\n\n\t\tchildren.forEach(child => {\n\t\t\tif (child && child.isUI5Element) {\n\t\t\t\tchild.detachInvalidate(this._getChildChangeListener(slotName));\n\t\t\t}\n\n\t\t\tif (isSlot(child)) {\n\t\t\t\tthis._detachSlotChange(child, slotName);\n\t\t\t}\n\t\t});\n\n\t\tthis._state[propertyName] = [];\n\t}\n\n\t/**\n\t * Attach a callback that will be executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tattachInvalidate(callback) {\n\t\tthis._eventProvider.attachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Detach the callback that is executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tdetachInvalidate(callback) {\n\t\tthis._eventProvider.detachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Callback that is executed whenever a monitored child changes its state\n\t *\n\t * @param slotName the slot in which a child was invalidated\n\t * @param childChangeInfo the changeInfo object for the child in the given slot\n\t * @private\n\t */\n\t_onChildChange(slotName, childChangeInfo) {\n\t\tif (!this.constructor.getMetadata().shouldInvalidateOnChildChange(slotName, childChangeInfo.type, childChangeInfo.name)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The component should be invalidated as this type of change on the child is listened for\n\t\t// However, no matter what changed on the child (property/slot), the invalidation is registered as \"type=slot\" for the component itself\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"childchange\",\n\t\t\tchild: childChangeInfo.target,\n\t\t});\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element\n\t * @private\n\t */\n\tattributeChangedCallback(name, oldValue, newValue) {\n\t\tconst properties = this.constructor.getMetadata().getProperties();\n\t\tconst realName = name.replace(/^ui5-/, \"\");\n\t\tconst nameInCamelCase = kebabToCamelCase(realName);\n\t\tif (properties.hasOwnProperty(nameInCamelCase)) { // eslint-disable-line\n\t\t\tconst propertyTypeClass = properties[nameInCamelCase].type;\n\t\t\tif (propertyTypeClass === Boolean) {\n\t\t\t\tnewValue = newValue !== null;\n\t\t\t} else if (isDescendantOf(propertyTypeClass, DataType)) {\n\t\t\t\tnewValue = propertyTypeClass.attributeToProperty(newValue);\n\t\t\t}\n\t\t\tthis[nameInCamelCase] = newValue;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_updateAttribute(name, newValue) {\n\t\tif (!this.constructor.getMetadata().hasAttribute(name)) {\n\t\t\treturn;\n\t\t}\n\t\tconst properties = this.constructor.getMetadata().getProperties();\n\t\tconst propertyTypeClass = properties[name].type;\n\t\tconst attrName = camelToKebabCase(name);\n\t\tconst attrValue = this.getAttribute(attrName);\n\n\t\tif (propertyTypeClass === Boolean) {\n\t\t\tif (newValue === true && attrValue === null) {\n\t\t\t\tthis.setAttribute(attrName, \"\");\n\t\t\t} else if (newValue === false && attrValue !== null) {\n\t\t\t\tthis.removeAttribute(attrName);\n\t\t\t}\n\t\t} else if (isDescendantOf(propertyTypeClass, DataType)) {\n\t\t\tthis.setAttribute(attrName, propertyTypeClass.propertyToAttribute(newValue));\n\t\t} else if (typeof newValue !== \"object\") {\n\t\t\tif (attrValue !== newValue) {\n\t\t\t\tthis.setAttribute(attrName, newValue);\n\t\t\t}\n\t\t} // else { return; } // old object handling\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_upgradeProperty(prop) {\n\t\tif (this.hasOwnProperty(prop)) { // eslint-disable-line\n\t\t\tconst value = this[prop];\n\t\t\tdelete this[prop];\n\t\t\tthis[prop] = value;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_upgradeAllProperties() {\n\t\tconst allProps = this.constructor.getMetadata().getPropertiesList();\n\t\tallProps.forEach(this._upgradeProperty, this);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_initializeState() {\n\t\tthis._state = { ...this.constructor.getMetadata().getInitialState() };\n\t}\n\n\t/**\n\t * Returns a singleton event listener for the \"change\" event of a child in a given slot\n\t *\n\t * @param slotName the name of the slot, where the child is\n\t * @returns {any}\n\t * @private\n\t */\n\t_getChildChangeListener(slotName) {\n\t\tif (!this._childChangeListeners.has(slotName)) {\n\t\t\tthis._childChangeListeners.set(slotName, this._onChildChange.bind(this, slotName));\n\t\t}\n\t\treturn this._childChangeListeners.get(slotName);\n\t}\n\n\t/**\n\t * Returns a singleton slotchange event listener that invalidates the component due to changes in the given slot\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @returns {any}\n\t * @private\n\t */\n\t_getSlotChangeListener(slotName) {\n\t\tif (!this._slotChangeListeners.has(slotName)) {\n\t\t\tthis._slotChangeListeners.set(slotName, this._onSlotChange.bind(this, slotName));\n\t\t}\n\t\treturn this._slotChangeListeners.get(slotName);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_attachSlotChange(child, slotName) {\n\t\tchild.addEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_detachSlotChange(child, slotName) {\n\t\tchild.removeEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n\t}\n\n\t/**\n\t * Whenever a slot element is slotted inside a UI5 Web Component, its slotchange event invalidates the component\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @private\n\t */\n\t_onSlotChange(slotName) {\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"slotchange\",\n\t\t});\n\t}\n\n\t/**\n\t * A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)\n\t *\n\t * @param  changeInfo An object with information about the change that caused invalidation.\n\t * The object can have the following properties:\n\t *  - type: (property|slot) tells what caused the invalidation\n\t *   1) property: a property value was changed either directly or as a result of changing the corresponding attribute\n\t *   2) slot: a slotted node(nodes) changed in one of several ways (see \"reason\")\n\t *\n\t *  - name: the name of the property or slot that caused the invalidation\n\t *\n\t *  - reason: (children|textcontent|childchange|slotchange) relevant only for type=\"slot\" only and tells exactly what changed in the slot\n\t *   1) children: immediate children (HTML elements or text nodes) were added, removed or reordered in the slot\n\t *   2) textcontent: text nodes in the slot changed value (or nested text nodes were added or changed value). Can only trigger for slots of \"type: Node\"\n\t *   3) slotchange: a slot element, slotted inside that slot had its \"slotchange\" event listener called. This practically means that transitively slotted children changed.\n\t *      Can only trigger if the child of a slot is a slot element itself.\n\t *   4) childchange: indicates that a UI5Element child in that slot was invalidated and in turn invalidated the component.\n\t *      Can only trigger for slots with \"invalidateOnChildChange\" metadata descriptor\n\t *\n\t *  - newValue: the new value of the property (for type=\"property\" only)\n\t *\n\t *  - oldValue: the old value of the property (for type=\"property\" only)\n\t *\n\t *  - child the child that was changed (for type=\"slot\" and reason=\"childchange\" only)\n\t *\n\t * @public\n\t */\n\tonInvalidation(changeInfo) {}\n\n\t/**\n\t * Do not call this method directly, only intended to be called by js\n\t * @protected\n\t */\n\t_render() {\n\t\tconst hasIndividualSlots = this.constructor.getMetadata().hasIndividualSlots();\n\n\t\t// suppress invalidation to prevent state changes scheduling another rendering\n\t\tthis._suppressInvalidation = true;\n\n\t\tif (typeof this.onBeforeRendering === \"function\") {\n\t\t\tthis.onBeforeRendering();\n\t\t}\n\n\t\t// Intended for framework usage only. Currently ItemNavigation updates tab indexes after the component has updated its state but before the template is rendered\n\t\tif (this._onComponentStateFinalized) {\n\t\t\tthis._onComponentStateFinalized();\n\t\t}\n\n\t\t// resume normal invalidation handling\n\t\tthis._suppressInvalidation = false;\n\n\t\t// Update the shadow root with the render result\n\t\t/*\n\t\tif (this._changedState.length) {\n\t\t\tlet element = this.localName;\n\t\t\tif (this.id) {\n\t\t\t\telement = `${element}#${this.id}`;\n\t\t\t}\n\t\t\tconsole.log(\"Re-rendering:\", element, this._changedState.map(x => { // eslint-disable-line\n\t\t\t\tlet res = `${x.type}`;\n\t\t\t\tif (x.reason) {\n\t\t\t\t\tres = `${res}(${x.reason})`;\n\t\t\t\t}\n\t\t\t\tres = `${res}: ${x.name}`;\n\t\t\t\tif (x.type === \"property\") {\n\t\t\t\t\tres = `${res} ${x.oldValue} => ${x.newValue}`;\n\t\t\t\t}\n\n\t\t\t\treturn res;\n\t\t\t}));\n\t\t}\n\t\t*/\n\t\tthis._changedState = [];\n\n\t\t// Update shadow root and static area item\n\t\tif (this.constructor._needsShadowDOM()) {\n\t\t\tupdateShadowRoot(this);\n\t\t}\n\t\tif (this.staticAreaItem) {\n\t\t\tthis.staticAreaItem.update();\n\t\t}\n\n\t\t// Safari requires that children get the slot attribute only after the slot tags have been rendered in the shadow DOM\n\t\tif (hasIndividualSlots) {\n\t\t\tthis._assignIndividualSlotsToChildren();\n\t\t}\n\n\t\t// Call the onAfterRendering hook\n\t\tif (typeof this.onAfterRendering === \"function\") {\n\t\t\tthis.onAfterRendering();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_assignIndividualSlotsToChildren() {\n\t\tconst domChildren = Array.from(this.children);\n\n\t\tdomChildren.forEach(child => {\n\t\t\tif (child._individualSlot) {\n\t\t\t\tchild.setAttribute(\"slot\", child._individualSlot);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_waitForDomRef() {\n\t\treturn this._domRefReadyPromise;\n\t}\n\n\t/**\n\t * Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template\n\t * *Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option\n\t * Use this method instead of \"this.shadowRoot\" to read the Shadow DOM, if ever necessary\n\t *\n\t * @public\n\t */\n\tgetDomRef() {\n\t\t// If a component set _getRealDomRef to its children, use the return value of this function\n\t\tif (typeof this._getRealDomRef === \"function\") {\n\t\t\treturn this._getRealDomRef();\n\t\t}\n\n\t\tif (!this.shadowRoot || this.shadowRoot.children.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst children = [...this.shadowRoot.children].filter(child => ![\"link\", \"style\"].includes(child.localName));\n\t\tif (children.length !== 1) {\n\t\t\tconsole.warn(`The shadow DOM for ${this.constructor.getMetadata().getTag()} does not have a top level element, the getDomRef() method might not work as expected`); // eslint-disable-line\n\t\t}\n\n\t\treturn children[0];\n\t}\n\n\t/**\n\t * Returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tgetFocusDomRef() {\n\t\tconst domRef = this.getDomRef();\n\t\tif (domRef) {\n\t\t\tconst focusRef = domRef.querySelector(\"[data-sap-focus-ref]\");\n\t\t\treturn focusRef || domRef;\n\t\t}\n\t}\n\n\t/**\n\t * Waits for dom ref and then returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tasync getFocusDomRefAsync() {\n\t\tawait this._waitForDomRef();\n\t\treturn this.getFocusDomRef();\n\t}\n\n\t/**\n\t * Set the focus to the element, returned by \"getFocusDomRef()\" (marked by \"data-sap-focus-ref\")\n\t * @public\n\t */\n\tasync focus() {\n\t\tawait this._waitForDomRef();\n\n\t\tconst focusDomRef = this.getFocusDomRef();\n\n\t\tif (focusDomRef && typeof focusDomRef.focus === \"function\") {\n\t\t\tfocusDomRef.focus();\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @public\n\t * @param name - name of the event\n\t * @param data - additional data for the event\n\t * @param cancelable - true, if the user can call preventDefault on the event object\n\t * @param bubbles - true, if the event bubbles\n\t * @returns {boolean} false, if the event was cancelled (preventDefault called), true otherwise\n\t */\n\tfireEvent(name, data, cancelable = false, bubbles = true) {\n\t\tconst eventResult = this._fireEvent(name, data, cancelable, bubbles);\n\t\tconst camelCaseEventName = kebabToCamelCase(name);\n\n\t\tif (camelCaseEventName !== name) {\n\t\t\treturn eventResult && this._fireEvent(camelCaseEventName, data, cancelable);\n\t\t}\n\n\t\treturn eventResult;\n\t}\n\n\t_fireEvent(name, data, cancelable = false, bubbles = true) {\n\t\tconst noConflictEvent = new CustomEvent(`ui5-${name}`, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the no-conflict event is prevented\n\t\tconst noConflictEventResult = this.dispatchEvent(noConflictEvent);\n\n\t\tif (skipOriginalEvent(name)) {\n\t\t\treturn noConflictEventResult;\n\t\t}\n\n\t\tconst normalEvent = new CustomEvent(name, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the normal event is prevented\n\t\tconst normalEventResult = this.dispatchEvent(normalEvent);\n\n\t\t// Return false if any of the two events was prevented (its result was false).\n\t\treturn normalEventResult && noConflictEventResult;\n\t}\n\n\t/**\n\t * Returns the actual children, associated with a slot.\n\t * Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.\n\t * @public\n\t */\n\tgetSlottedNodes(slotName) {\n\t\treturn getSlottedElementsList(this[slotName]);\n\t}\n\n\t/**\n\t * Determines whether the component should be rendered in RTL mode or not.\n\t * Returns: \"rtl\", \"ltr\" or undefined\n\t *\n\t * @public\n\t * @returns {String|undefined}\n\t */\n\tget effectiveDir() {\n\t\tmarkAsRtlAware(this.constructor); // if a UI5 Element calls this method, it's considered to be rtl-aware\n\t\treturn getEffectiveDir(this);\n\t}\n\n\t/**\n\t * Used to duck-type UI5 elements without using instanceof\n\t * @returns {boolean}\n\t * @public\n\t */\n\tget isUI5Element() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element, use metadata properties instead\n\t * @private\n\t */\n\tstatic get observedAttributes() {\n\t\treturn this.getMetadata().getAttributesList();\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _needsShadowDOM() {\n\t\treturn !!this.template;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _needsStaticArea() {\n\t\treturn !!this.staticAreaTemplate;\n\t}\n\n\t/**\n\t * @public\n\t */\n\tgetStaticAreaItemDomRef() {\n\t\tif (!this.constructor._needsStaticArea()) {\n\t\t\tthrow new Error(\"This component does not use the static area\");\n\t\t}\n\n\t\tif (!this.staticAreaItem) {\n\t\t\tthis.staticAreaItem = StaticAreaItem.createInstance();\n\t\t\tthis.staticAreaItem.setOwnerElement(this);\n\t\t}\n\t\tif (!this.staticAreaItem.parentElement) {\n\t\t\tgetSingletonElementInstance(\"ui5-static-area\").appendChild(this.staticAreaItem);\n\t\t}\n\n\t\treturn this.staticAreaItem.getDomRef();\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _generateAccessors() {\n\t\tconst proto = this.prototype;\n\t\tconst slotsAreManaged = this.getMetadata().slotsAreManaged();\n\n\t\t// Properties\n\t\tconst properties = this.getMetadata().getProperties();\n\t\tfor (const [prop, propData] of Object.entries(properties)) { // eslint-disable-line\n\t\t\tif (!isValidPropertyName(prop)) {\n\t\t\t\tconsole.warn(`\"${prop}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t}\n\n\t\t\tif (propData.type === Boolean && propData.defaultValue) {\n\t\t\t\tthrow new Error(`Cannot set a default value for property \"${prop}\". All booleans are false by default.`);\n\t\t\t}\n\n\t\t\tif (propData.type === Array) {\n\t\t\t\tthrow new Error(`Wrong type for property \"${prop}\". Properties cannot be of type Array - use \"multiple: true\" and set \"type\" to the single value type, such as \"String\", \"Object\", etc...`);\n\t\t\t}\n\n\t\t\tif (propData.type === Object && propData.defaultValue) {\n\t\t\t\tthrow new Error(`Cannot set a default value for property \"${prop}\". All properties of type \"Object\" are empty objects by default.`);\n\t\t\t}\n\n\t\t\tif (propData.multiple && propData.defaultValue) {\n\t\t\t\tthrow new Error(`Cannot set a default value for property \"${prop}\". All multiple properties are empty arrays by default.`);\n\t\t\t}\n\n\t\t\tObject.defineProperty(proto, prop, {\n\t\t\t\tget() {\n\t\t\t\t\tif (this._state[prop] !== undefined) {\n\t\t\t\t\t\treturn this._state[prop];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst propDefaultValue = propData.defaultValue;\n\n\t\t\t\t\tif (propData.type === Boolean) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (propData.type === String) {  // eslint-disable-line\n\t\t\t\t\t\treturn propDefaultValue;\n\t\t\t\t\t} else if (propData.multiple) { // eslint-disable-line\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn propDefaultValue;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tlet isDifferent;\n\t\t\t\t\tvalue = this.constructor.getMetadata().constructor.validatePropertyValue(value, propData);\n\n\t\t\t\t\tconst oldState = this._state[prop];\n\t\t\t\t\tif (propData.multiple && propData.compareValues) {\n\t\t\t\t\t\tisDifferent = !arraysAreEqual(oldState, value);\n\t\t\t\t\t} else if (isDescendantOf(propData.type, DataType)) {\n\t\t\t\t\t\tisDifferent = !propData.type.valuesAreEqual(oldState, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisDifferent = oldState !== value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDifferent) {\n\t\t\t\t\t\tthis._state[prop] = value;\n\t\t\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tname: prop,\n\t\t\t\t\t\t\tnewValue: value,\n\t\t\t\t\t\t\toldValue: oldState,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._updateAttribute(prop, value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Slots\n\t\tif (slotsAreManaged) {\n\t\t\tconst slots = this.getMetadata().getSlots();\n\t\t\tfor (const [slotName, slotData] of Object.entries(slots)) { // eslint-disable-line\n\t\t\t\tif (!isValidPropertyName(slotName)) {\n\t\t\t\t\tconsole.warn(`\"${slotName}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t\t}\n\n\t\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\t\tObject.defineProperty(proto, propertyName, {\n\t\t\t\t\tget() {\n\t\t\t\t\t\tif (this._state[propertyName] !== undefined) {\n\t\t\t\t\t\t\treturn this._state[propertyName];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t},\n\t\t\t\t\tset() {\n\t\t\t\t\t\tthrow new Error(\"Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)\");\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the metadata object for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic get metadata() {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Returns the CSS for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic get styles() {\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns the Static Area CSS for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic get staticAreaStyles() {\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns an array with the dependencies for this UI5 Web Component, which could be:\n\t *  - composed components (used in its shadow root or static area item)\n\t *  - slotted components that the component may need to communicate with\n\t *\n\t * @protected\n\t */\n\tstatic get dependencies() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns a list of the unique dependencies for this UI5 Web Component\n\t *\n\t * @public\n\t */\n\tstatic getUniqueDependencies() {\n\t\tif (!uniqueDependenciesCache.has(this)) {\n\t\t\tconst filtered = this.dependencies.filter((dep, index, deps) => deps.indexOf(dep) === index);\n\t\t\tuniqueDependenciesCache.set(this, filtered);\n\t\t}\n\n\t\treturn uniqueDependenciesCache.get(this);\n\t}\n\n\t/**\n\t * Returns a promise that resolves whenever all dependencies for this UI5 Web Component have resolved\n\t *\n\t * @returns {Promise<any[]>}\n\t */\n\tstatic whenDependenciesDefined() {\n\t\treturn Promise.all(this.getUniqueDependencies().map(dep => dep.define()));\n\t}\n\n\t/**\n\t * Hook that will be called upon custom element definition\n\t *\n\t * @protected\n\t * @returns {Promise<void>}\n\t */\n\tstatic async onDefine() {\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Registers a UI5 Web Component in the browser window object\n\t * @public\n\t * @returns {Promise<UI5Element>}\n\t */\n\tstatic async define() {\n\t\tawait boot();\n\n\t\tawait Promise.all([\n\t\t\tthis.whenDependenciesDefined(),\n\t\t\tthis.onDefine(),\n\t\t]);\n\n\t\tconst tag = this.getMetadata().getTag();\n\t\tconst altTag = this.getMetadata().getAltTag();\n\n\t\tconst definedLocally = isTagRegistered(tag);\n\t\tconst definedGlobally = customElements.get(tag);\n\n\t\tif (definedGlobally && !definedLocally) {\n\t\t\trecordTagRegistrationFailure(tag);\n\t\t} else if (!definedGlobally) {\n\t\t\tthis._generateAccessors();\n\t\t\tregisterTag(tag);\n\t\t\twindow.customElements.define(tag, this);\n\t\t\tpreloadLinks(this);\n\n\t\t\tif (altTag && !customElements.get(altTag)) {\n\t\t\t\tregisterTag(altTag);\n\t\t\t\twindow.customElements.define(altTag, getClassCopy(this, () => {\n\t\t\t\t\tconsole.log(`The ${altTag} tag is deprecated and will be removed in the next release, please use ${tag} instead.`); // eslint-disable-line\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an instance of UI5ElementMetadata.js representing this UI5 Web Component's full metadata (its and its parents')\n\t * Note: not to be confused with the \"get metadata()\" method, which returns an object for this class's metadata only\n\t * @public\n\t * @returns {UI5ElementMetadata}\n\t */\n\tstatic getMetadata() {\n\t\tif (this.hasOwnProperty(\"_metadata\")) { // eslint-disable-line\n\t\t\treturn this._metadata;\n\t\t}\n\n\t\tconst metadataObjects = [this.metadata];\n\t\tlet klass = this; // eslint-disable-line\n\t\twhile (klass !== UI5Element) {\n\t\t\tklass = Object.getPrototypeOf(klass);\n\t\t\tmetadataObjects.unshift(klass.metadata);\n\t\t}\n\t\tconst mergedMetadata = merge({}, ...metadataObjects);\n\n\t\tthis._metadata = new UI5ElementMetadata(mergedMetadata);\n\t\treturn this._metadata;\n\t}\n}\n\nexport default UI5Element;\n"]},"metadata":{},"sourceType":"module"}