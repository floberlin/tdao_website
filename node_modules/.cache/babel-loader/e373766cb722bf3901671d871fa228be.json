{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.oned {*/\n\n\nimport BarcodeFormat from '../BarcodeFormat';\nimport DecodeHintType from '../DecodeHintType';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultPoint from '../ResultPoint';\nimport StringBuilder from '../util/StringBuilder';\nimport System from '../util/System';\nimport OneDReader from './OneDReader';\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\n\nvar ITFReader = function (_super) {\n  __extends(ITFReader, _super);\n\n  function ITFReader() {\n    // private static W = 3; // Pixel width of a 3x wide line\n    // private static w = 2; // Pixel width of a 2x wide line\n    // private static N = 1; // Pixed width of a narrow line\n    var _this = _super !== null && _super.apply(this, arguments) || this; // Stores the actual narrow line width of the image being decoded.\n\n\n    _this.narrowLineWidth = -1;\n    return _this;\n  } // See ITFWriter.PATTERNS\n\n  /*\n     /!**\n   * Patterns of Wide / Narrow lines to indicate each digit\n   *!/\n  */\n\n\n  ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a; // Find out where the Middle section (payload) starts & ends\n\n\n    var startRange = this.decodeStart(row);\n    var endRange = this.decodeEnd(row);\n    var result = new StringBuilder();\n    ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n    var resultString = result.toString();\n    var allowedLengths = null;\n\n    if (hints != null) {\n      allowedLengths = hints.get(DecodeHintType.ALLOWED_LENGTHS);\n    }\n\n    if (allowedLengths == null) {\n      allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n    } // To avoid false positives with 2D barcodes (and other patterns), make\n    // an assumption that the decoded string must be a 'standard' length if it's short\n\n\n    var length = resultString.length;\n    var lengthOK = false;\n    var maxAllowedLength = 0;\n\n    try {\n      for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n        var value = allowedLengths_1_1.value;\n\n        if (length === value) {\n          lengthOK = true;\n          break;\n        }\n\n        if (value > maxAllowedLength) {\n          maxAllowedLength = value;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (!lengthOK && length > maxAllowedLength) {\n      lengthOK = true;\n    }\n\n    if (!lengthOK) {\n      throw new FormatException();\n    }\n\n    var points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];\n    var resultReturn = new Result(resultString, null, // no natural byte representation for these barcodes\n    0, points, BarcodeFormat.ITF, new Date().getTime());\n    return resultReturn;\n  };\n  /*\n  /!**\n   * @param row          row of black/white values to search\n   * @param payloadStart offset of start pattern\n   * @param resultString {@link StringBuilder} to append decoded chars to\n   * @throws NotFoundException if decoding could not complete successfully\n   *!/*/\n\n\n  ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n    // Digits are interleaved in pairs - 5 black lines for one digit, and the\n    // 5\n    // interleaved white lines for the second digit.\n    // Therefore, need to scan 10 lines and then\n    // split these into two arrays\n    var counterDigitPair = new Int32Array(10); // 10\n\n    var counterBlack = new Int32Array(5); // 5\n\n    var counterWhite = new Int32Array(5); // 5\n\n    counterDigitPair.fill(0);\n    counterBlack.fill(0);\n    counterWhite.fill(0);\n\n    while (payloadStart < payloadEnd) {\n      // Get 10 runs of black/white.\n      OneDReader.recordPattern(row, payloadStart, counterDigitPair); // Split them into each array\n\n      for (var k = 0; k < 5; k++) {\n        var twoK = 2 * k;\n        counterBlack[k] = counterDigitPair[twoK];\n        counterWhite[k] = counterDigitPair[twoK + 1];\n      }\n\n      var bestMatch = ITFReader.decodeDigit(counterBlack);\n      resultString.append(bestMatch.toString());\n      bestMatch = this.decodeDigit(counterWhite);\n      resultString.append(bestMatch.toString());\n      counterDigitPair.forEach(function (counterDigit) {\n        payloadStart += counterDigit;\n      });\n    }\n  };\n  /*/!**\n   * Identify where the start of the middle / payload section starts.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'start block' and end of\n   *         'start block'\n   *!/*/\n\n\n  ITFReader.prototype.decodeStart = function (row) {\n    var endStart = ITFReader.skipWhiteSpace(row);\n    var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN); // Determine the width of a narrow line in pixels. We can do this by\n    // getting the width of the start pattern and dividing by 4 because its\n    // made up of 4 narrow lines.\n\n    this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n    this.validateQuietZone(row, startPattern[0]);\n    return startPattern;\n  };\n  /*/!**\n   * The start & end patterns must be pre/post fixed by a quiet zone. This\n   * zone must be at least 10 times the width of a narrow line.  Scan back until\n   * we either get to the start of the barcode or match the necessary number of\n   * quiet zone pixels.\n   *\n   * Note: Its assumed the row is reversed when using this method to find\n   * quiet zone after the end pattern.\n   *\n   * ref: http://www.barcode-1.net/i25code.html\n   *\n   * @param row bit array representing the scanned barcode.\n   * @param startPattern index into row of the start or end pattern.\n   * @throws NotFoundException if the quiet zone cannot be found\n   *!/*/\n\n\n  ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n    var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n    // if there are not so many pixel at all let's try as many as possible\n\n    quietCount = quietCount < startPattern ? quietCount : startPattern;\n\n    for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n      if (row.get(i)) {\n        break;\n      }\n\n      quietCount--;\n    }\n\n    if (quietCount !== 0) {\n      // Unable to find the necessary number of quiet zone pixels.\n      throw new NotFoundException();\n    }\n  };\n  /*\n  /!**\n   * Skip all whitespace until we get to the first black line.\n   *\n   * @param row row of black/white values to search\n   * @return index of the first black line.\n   * @throws NotFoundException Throws exception if no black lines are found in the row\n   *!/*/\n\n\n  ITFReader.skipWhiteSpace = function (row) {\n    var width = row.getSize();\n    var endStart = row.getNextSet(0);\n\n    if (endStart === width) {\n      throw new NotFoundException();\n    }\n\n    return endStart;\n  };\n  /*/!**\n   * Identify where the end of the middle / payload section ends.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'end block' and end of 'end\n   *         block'\n   *!/*/\n\n\n  ITFReader.prototype.decodeEnd = function (row) {\n    // For convenience, reverse the row and then\n    // search from 'the start' for the end block\n    row.reverse();\n\n    try {\n      var endStart = ITFReader.skipWhiteSpace(row);\n      var endPattern = void 0;\n\n      try {\n        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n        }\n      } // The start & end patterns must be pre/post fixed by a quiet zone. This\n      // zone must be at least 10 times the width of a narrow line.\n      // ref: http://www.barcode-1.net/i25code.html\n\n\n      this.validateQuietZone(row, endPattern[0]); // Now recalculate the indices of where the 'endblock' starts & stops to\n      // accommodate\n      // the reversed nature of the search\n\n      var temp = endPattern[0];\n      endPattern[0] = row.getSize() - endPattern[1];\n      endPattern[1] = row.getSize() - temp;\n      return endPattern;\n    } finally {\n      // Put the row back the right way.\n      row.reverse();\n    }\n  };\n  /*\n  /!**\n   * @param row       row of black/white values to search\n   * @param rowOffset position to start search\n   * @param pattern   pattern of counts of number of black and white pixels that are\n   *                  being searched for as a pattern\n   * @return start/end horizontal offset of guard pattern, as an array of two\n   *         ints\n   * @throws NotFoundException if pattern is not found\n   *!/*/\n\n\n  ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n    var patternLength = pattern.length;\n    var counters = new Int32Array(patternLength);\n    var width = row.getSize();\n    var isWhite = false;\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    counters.fill(0);\n\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n            return [patternStart, x];\n          }\n\n          patternStart += counters[0] + counters[1];\n          System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException();\n  };\n  /*/!**\n   * Attempts to decode a sequence of ITF black/white lines into single\n   * digit.\n   *\n   * @param counters the counts of runs of observed black/white/black/... values\n   * @return The decoded digit\n   * @throws NotFoundException if digit cannot be decoded\n   *!/*/\n\n\n  ITFReader.decodeDigit = function (counters) {\n    var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n\n    var bestMatch = -1;\n    var max = ITFReader.PATTERNS.length;\n\n    for (var i = 0; i < max; i++) {\n      var pattern = ITFReader.PATTERNS[i];\n      var variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      } else if (variance === bestVariance) {\n        // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n        bestMatch = -1;\n      }\n    }\n\n    if (bestMatch >= 0) {\n      return bestMatch % 10;\n    } else {\n      throw new NotFoundException();\n    }\n  };\n\n  ITFReader.PATTERNS = [Int32Array.from([1, 1, 2, 2, 1]), Int32Array.from([2, 1, 1, 1, 2]), Int32Array.from([1, 2, 1, 1, 2]), Int32Array.from([2, 2, 1, 1, 1]), Int32Array.from([1, 1, 2, 1, 2]), Int32Array.from([2, 1, 2, 1, 1]), Int32Array.from([1, 2, 2, 1, 1]), Int32Array.from([1, 1, 1, 2, 2]), Int32Array.from([2, 1, 1, 2, 1]), Int32Array.from([1, 2, 1, 2, 1]), Int32Array.from([1, 1, 3, 3, 1]), Int32Array.from([3, 1, 1, 1, 3]), Int32Array.from([1, 3, 1, 1, 3]), Int32Array.from([3, 3, 1, 1, 1]), Int32Array.from([1, 1, 3, 1, 3]), Int32Array.from([3, 1, 3, 1, 1]), Int32Array.from([1, 3, 3, 1, 1]), Int32Array.from([1, 1, 1, 3, 3]), Int32Array.from([3, 1, 1, 3, 1]), Int32Array.from([1, 3, 1, 3, 1]) // 9\n  ];\n  ITFReader.MAX_AVG_VARIANCE = 0.38;\n  ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n  /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n\n  ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n  /*/!**\n   * Start/end guard pattern.\n   *\n   * Note: The end pattern is reversed because the row is reversed before\n   * searching for the END_PATTERN\n   *!/*/\n\n  ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n  ITFReader.END_PATTERN_REVERSED = [Int32Array.from([1, 1, 2]), Int32Array.from([1, 1, 3]) // 3x\n  ];\n  return ITFReader;\n}(OneDReader);\n\nexport default ITFReader;","map":{"version":3,"sources":["../../../../src/core/oned/ITFReader.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH;;;AAEA,OAAO,aAAP,MAA0B,kBAA1B;AAEA,OAAO,cAAP,MAA2B,mBAA3B;AACA,OAAO,eAAP,MAA4B,oBAA5B;AACA,OAAO,iBAAP,MAA8B,sBAA9B;AACA,OAAO,MAAP,MAAmB,WAAnB;AACA,OAAO,WAAP,MAAwB,gBAAxB;AACA,OAAO,aAAP,MAA0B,uBAA1B;AACA,OAAO,MAAP,MAAmB,gBAAnB;AACA,OAAO,UAAP,MAAuB,cAAvB;AAGA;;;;AAIG;;AACH,IAAA,SAAA,GAAA,UAAA,MAAA,EAAA;AAAuC,EAAA,SAAA,CAAA,SAAA,EAAA,MAAA,CAAA;;AAAvC,WAAA,SAAA,GAAA;AAEE;AACA;AACA;AAJF,QAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA,CAAA,CAqCE;;;AACQ,IAAA,KAAA,CAAA,eAAA,GAAkB,CAAC,CAAnB;;AA4UT,GAlXD,CAoDE;;AACA;;;;;;;AAOO,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,SAAjB,EAAoC,GAApC,EAAmD,KAAnD,EAAmF;gBAAA,CAEjF;;;AACA,QAAI,UAAU,GAAa,KAAK,WAAL,CAAiB,GAAjB,CAA3B;AACA,QAAI,QAAQ,GAAa,KAAK,SAAL,CAAe,GAAf,CAAzB;AAEA,QAAI,MAAM,GAAkB,IAAI,aAAJ,EAA5B;AACA,IAAA,SAAS,CAAC,YAAV,CAAuB,GAAvB,EAA4B,UAAU,CAAC,CAAD,CAAtC,EAA2C,QAAQ,CAAC,CAAD,CAAnD,EAAwD,MAAxD;AACA,QAAI,YAAY,GAAW,MAAM,CAAC,QAAP,EAA3B;AAEA,QAAI,cAAc,GAAa,IAA/B;;AACA,QAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,MAAA,cAAc,GAAG,KAAK,CAAC,GAAN,CAAU,cAAc,CAAC,eAAzB,CAAjB;AAED;;AACD,QAAI,cAAc,IAAI,IAAtB,EAA4B;AAC1B,MAAA,cAAc,GAAG,SAAS,CAAC,uBAA3B;AACD,KAjBgF,CAmBjF;AACA;;;AACA,QAAI,MAAM,GAAW,YAAY,CAAC,MAAlC;AACA,QAAI,QAAQ,GAAY,KAAxB;AACA,QAAI,gBAAgB,GAAW,CAA/B;;;AAEA,WAAkB,IAAA,gBAAA,GAAA,QAAA,CAAA,cAAA,CAAA,EAAc,kBAAA,GAAA,gBAAA,CAAA,IAAA,EAAhC,EAAgC,CAAA,kBAAA,CAAA,IAAhC,EAAgC,kBAAA,GAAA,gBAAA,CAAA,IAAA,EAAhC,EAAkC;AAA7B,YAAI,KAAK,GAAA,kBAAA,CAAA,KAAT;;AACH,YAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,UAAA,QAAQ,GAAG,IAAX;AACA;AACD;;AACD,YAAI,KAAK,GAAG,gBAAZ,EAA8B;AAC5B,UAAA,gBAAgB,GAAG,KAAnB;AACD;AACF;;;;;;;;;;;;;AAED,QAAI,CAAC,QAAD,IAAa,MAAM,GAAG,gBAA1B,EAA4C;AAC1C,MAAA,QAAQ,GAAG,IAAX;AACD;;AAED,QAAI,CAAC,QAAL,EAAe;AACb,YAAM,IAAI,eAAJ,EAAN;AACD;;AAED,QAAM,MAAM,GAAkB,CAAC,IAAI,WAAJ,CAAgB,UAAU,CAAC,CAAD,CAA1B,EAA+B,SAA/B,CAAD,EAA4C,IAAI,WAAJ,CAAgB,QAAQ,CAAC,CAAD,CAAxB,EAA6B,SAA7B,CAA5C,CAA9B;AAEA,QAAI,YAAY,GAAW,IAAI,MAAJ,CACzB,YADyB,EAEzB,IAFyB,EAEnB;AACN,KAHyB,EAIzB,MAJyB,EAKzB,aAAa,CAAC,GALW,EAMzB,IAAI,IAAJ,GAAW,OAAX,EANyB,CAA3B;AASA,WAAO,YAAP;AACD,GAvDM;AAwDP;;;;;;AAMM;;;AACS,EAAA,SAAA,CAAA,YAAA,GAAf,UACE,GADF,EAEE,YAFF,EAGE,UAHF,EAIE,YAJF,EAI6B;AAG3B;AACA;AACA;AACA;AACA;AAEI,QAAI,gBAAgB,GAAe,IAAI,UAAJ,CAAe,EAAf,CAAnC,CATuB,CASgC;;AACvD,QAAI,YAAY,GAAe,IAAI,UAAJ,CAAe,CAAf,CAA/B,CAVuB,CAU2B;;AAClD,QAAI,YAAY,GAAe,IAAI,UAAJ,CAAe,CAAf,CAA/B,CAXuB,CAW2B;;AAEtD,IAAA,gBAAgB,CAAC,IAAjB,CAAsB,CAAtB;AACA,IAAA,YAAY,CAAC,IAAb,CAAkB,CAAlB;AACA,IAAA,YAAY,CAAC,IAAb,CAAkB,CAAlB;;AAEA,WAAO,YAAY,GAAG,UAAtB,EAAkC;AAEhC;AACA,MAAA,UAAU,CAAC,aAAX,CAAyB,GAAzB,EAA8B,YAA9B,EAA4C,gBAA5C,EAHgC,CAIhC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,YAAI,IAAI,GAAW,IAAI,CAAvB;AACA,QAAA,YAAY,CAAC,CAAD,CAAZ,GAAkB,gBAAgB,CAAC,IAAD,CAAlC;AACA,QAAA,YAAY,CAAC,CAAD,CAAZ,GAAkB,gBAAgB,CAAC,IAAI,GAAG,CAAR,CAAlC;AACD;;AAED,UAAI,SAAS,GAAW,SAAS,CAAC,WAAV,CAAsB,YAAtB,CAAxB;AACA,MAAA,YAAY,CAAC,MAAb,CAAoB,SAAS,CAAC,QAAV,EAApB;AACA,MAAA,SAAS,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAAZ;AACA,MAAA,YAAY,CAAC,MAAb,CAAoB,SAAS,CAAC,QAAV,EAApB;AAEA,MAAA,gBAAgB,CAAC,OAAjB,CAAyB,UAAU,YAAV,EAAsB;AAC7C,QAAA,YAAY,IAAI,YAAhB;AACD,OAFD;AAGD;AACF,GAzCc;AA2Cf;;;;;;AAMM;;;AACE,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,GAApB,EAAiC;AAE/B,QAAI,QAAQ,GAAG,SAAS,CAAC,cAAV,CAAyB,GAAzB,CAAf;AACA,QAAI,YAAY,GAAa,SAAS,CAAC,gBAAV,CAA2B,GAA3B,EAAgC,QAAhC,EAA0C,SAAS,CAAC,aAApD,CAA7B,CAH+B,CAK/B;AACA;AACA;;AACA,SAAK,eAAL,GAAuB,CAAC,YAAY,CAAC,CAAD,CAAZ,GAAkB,YAAY,CAAC,CAAD,CAA/B,IAAsC,CAA7D;AAEA,SAAK,iBAAL,CAAuB,GAAvB,EAA4B,YAAY,CAAC,CAAD,CAAxC;AAEA,WAAO,YAAP;AACD,GAbO;AAeR;;;;;;;;;;;;;;AAcM;;;AACE,EAAA,SAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,GAA1B,EAAyC,YAAzC,EAA6D;AAE3D,QAAI,UAAU,GAAW,KAAK,eAAL,GAAuB,EAAhD,CAF2D,CAEN;AAErD;;AACA,IAAA,UAAU,GAAG,UAAU,GAAG,YAAb,GAA4B,UAA5B,GAAyC,YAAtD;;AAEA,SAAK,IAAI,CAAC,GAAG,YAAY,GAAG,CAA5B,EAA+B,UAAU,GAAG,CAAb,IAAkB,CAAC,IAAI,CAAtD,EAAyD,CAAC,EAA1D,EAA8D;AAC5D,UAAI,GAAG,CAAC,GAAJ,CAAQ,CAAR,CAAJ,EAAgB;AACd;AACD;;AACD,MAAA,UAAU;AACX;;AACD,QAAI,UAAU,KAAK,CAAnB,EAAsB;AACpB;AACA,YAAM,IAAI,iBAAJ,EAAN;AACD;AACF,GAjBO;AAkBR;;;;;;;AAOM;;;AACS,EAAA,SAAA,CAAA,cAAA,GAAf,UAA8B,GAA9B,EAA2C;AAEzC,QAAM,KAAK,GAAG,GAAG,CAAC,OAAJ,EAAd;AACA,QAAM,QAAQ,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAf,CAAjB;;AAEA,QAAI,QAAQ,KAAK,KAAjB,EAAwB;AACtB,YAAM,IAAI,iBAAJ,EAAN;AACD;;AAED,WAAO,QAAP;AACD,GAVc;AAYf;;;;;;AAMM;;;AACE,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,GAAlB,EAA+B;AAE7B;AACA;AACA,IAAA,GAAG,CAAC,OAAJ;;AAEA,QAAI;AACF,UAAI,QAAQ,GAAW,SAAS,CAAC,cAAV,CAAyB,GAAzB,CAAvB;AACA,UAAI,UAAU,GAAA,KAAA,CAAd;;AAEA,UAAI;AACF,QAAA,UAAU,GAAG,SAAS,CAAC,gBAAV,CAA2B,GAA3B,EAAgC,QAAhC,EAA0C,SAAS,CAAC,oBAAV,CAA+B,CAA/B,CAA1C,CAAb;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd,YAAI,KAAK,YAAY,iBAArB,EAAwC;AACtC,UAAA,UAAU,GAAG,SAAS,CAAC,gBAAV,CAA2B,GAA3B,EAAgC,QAAhC,EAA0C,SAAS,CAAC,oBAAV,CAA+B,CAA/B,CAA1C,CAAb;AACD;AACF,OAVC,CAYF;AACA;AACA;;;AACA,WAAK,iBAAL,CAAuB,GAAvB,EAA4B,UAAU,CAAC,CAAD,CAAtC,EAfE,CAiBF;AACA;AACA;;AACA,UAAI,IAAI,GAAG,UAAU,CAAC,CAAD,CAArB;AACA,MAAA,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAG,CAAC,OAAJ,KAAgB,UAAU,CAAC,CAAD,CAA1C;AACA,MAAA,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAG,CAAC,OAAJ,KAAgB,IAAhC;AAEA,aAAO,UAAP;AAED,KA1BD,SA0BU;AACR;AACA,MAAA,GAAG,CAAC,OAAJ;AACD;AACF,GApCO;AAsCN;;;;;;;;;AASM;;;AACS,EAAA,SAAA,CAAA,gBAAA,GAAf,UACI,GADJ,EAEI,SAFJ,EAGI,OAHJ,EAGuB;AAGnB,QAAI,aAAa,GAAW,OAAO,CAAC,MAApC;AACA,QAAI,QAAQ,GAAe,IAAI,UAAJ,CAAe,aAAf,CAA3B;AACA,QAAI,KAAK,GAAW,GAAG,CAAC,OAAJ,EAApB;AACA,QAAI,OAAO,GAAY,KAAvB;AAEJ,QAAI,eAAe,GAAW,CAA9B;AACA,QAAI,YAAY,GAAW,SAA3B;AAEA,IAAA,QAAQ,CAAC,IAAT,CAAc,CAAd;;AAEA,SAAK,IAAI,CAAC,GAAG,SAAb,EAAwB,CAAC,GAAG,KAA5B,EAAmC,CAAC,EAApC,EAAwC;AACtC,UAAI,GAAG,CAAC,GAAJ,CAAQ,CAAR,MAAe,OAAnB,EAA4B;AAC1B,QAAA,QAAQ,CAAC,eAAD,CAAR;AACD,OAFD,MAEO;AACL,YAAI,eAAe,KAAK,aAAa,GAAG,CAAxC,EAA2C;AACzC,cAAI,UAAU,CAAC,oBAAX,CAAgC,QAAhC,EAA0C,OAA1C,EAAmD,SAAS,CAAC,uBAA7D,IAAwF,SAAS,CAAC,gBAAtG,EAAwH;AACtH,mBAAO,CAAC,YAAD,EAAe,CAAf,CAAP;AACD;;AACD,UAAA,YAAY,IAAI,QAAQ,CAAC,CAAD,CAAR,GAAc,QAAQ,CAAC,CAAD,CAAtC;AACA,UAAA,MAAM,CAAC,SAAP,CAAiB,QAAjB,EAA2B,CAA3B,EAA8B,QAA9B,EAAwC,CAAxC,EAA2C,eAAe,GAAG,CAA7D;AACA,UAAA,QAAQ,CAAC,eAAe,GAAG,CAAnB,CAAR,GAAgC,CAAhC;AACA,UAAA,QAAQ,CAAC,eAAD,CAAR,GAA4B,CAA5B;AACA,UAAA,eAAe;AAChB,SATD,MASO;AACL,UAAA,eAAe;AAChB;;AACD,QAAA,QAAQ,CAAC,eAAD,CAAR,GAA4B,CAA5B;AACA,QAAA,OAAO,GAAG,CAAC,OAAX;AACD;AACF;;AACD,UAAM,IAAI,iBAAJ,EAAN;AACD,GArCgB;AAuCf;;;;;;;AAOM;;;AACS,EAAA,SAAA,CAAA,WAAA,GAAf,UAA2B,QAA3B,EAA+C;AAE/C,QAAI,YAAY,GAAW,SAAS,CAAC,gBAArC,CAF+C,CAEQ;;AACvD,QAAI,SAAS,GAAW,CAAC,CAAzB;AACA,QAAI,GAAG,GAAW,SAAS,CAAC,QAAV,CAAmB,MAArC;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAE5B,UAAI,OAAO,GAAG,SAAS,CAAC,QAAV,CAAmB,CAAnB,CAAd;AACA,UAAI,QAAQ,GAAW,UAAU,CAAC,oBAAX,CAAgC,QAAhC,EAA0C,OAA1C,EAAmD,SAAS,CAAC,uBAA7D,CAAvB;;AAEA,UAAI,QAAQ,GAAG,YAAf,EAA6B;AAC3B,QAAA,YAAY,GAAG,QAAf;AACA,QAAA,SAAS,GAAG,CAAZ;AACD,OAHD,MAGO,IAAI,QAAQ,KAAK,YAAjB,EAA+B;AACpC;AACA,QAAA,SAAS,GAAG,CAAC,CAAb;AACD;AACF;;AAED,QAAI,SAAS,IAAI,CAAjB,EAAoB;AAClB,aAAO,SAAS,GAAG,EAAnB;AACD,KAFD,MAEO;AACL,YAAM,IAAI,iBAAJ,EAAN;AACD;AACF,GAzBgB;;AAjVA,EAAA,SAAA,CAAA,QAAA,GAAyB,CACpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CADoC,EAEpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAFoC,EAGpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAHoC,EAIpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAJoC,EAKpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CALoC,EAMpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CANoC,EAOpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAPoC,EAQpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CARoC,EASpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAToC,EAUpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAVoC,EAWpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAXoC,EAYpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAZoC,EAapC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAboC,EAcpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAdoC,EAepC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAfoC,EAgBpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAhBoC,EAiBpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAjBoC,EAkBpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAlBoC,EAmBpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CAnBoC,EAoBpC,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CApBoC,CAoBF;AApBE,GAAzB;AAuBF,EAAA,SAAA,CAAA,gBAAA,GAAmB,IAAnB;AACA,EAAA,SAAA,CAAA,uBAAA,GAA0B,GAA1B;AAIf;;AACe,EAAA,SAAA,CAAA,uBAAA,GAAoC,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP,EAAW,EAAX,EAAe,EAAf,CAApC;AAKb;;;;;AAKM;;AACS,EAAA,SAAA,CAAA,aAAA,GAAgB,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAhB,CAAhB;AACA,EAAA,SAAA,CAAA,oBAAA,GAAqC,CAChD,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAhB,CADgD,EAEhD,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAhB,CAFgD,CAEpB;AAFoB,GAArC;AAmUnB,SAAA,SAAA;AAAC,CAlXD,CAAuC,UAAvC,CAAA;;eAAqB,S","sourceRoot":"","sourcesContent":["/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.oned {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport DecodeHintType from '../DecodeHintType';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultPoint from '../ResultPoint';\nimport StringBuilder from '../util/StringBuilder';\nimport System from '../util/System';\nimport OneDReader from './OneDReader';\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\nvar ITFReader = /** @class */ (function (_super) {\n    __extends(ITFReader, _super);\n    function ITFReader() {\n        // private static W = 3; // Pixel width of a 3x wide line\n        // private static w = 2; // Pixel width of a 2x wide line\n        // private static N = 1; // Pixed width of a narrow line\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // Stores the actual narrow line width of the image being decoded.\n        _this.narrowLineWidth = -1;\n        return _this;\n    }\n    // See ITFWriter.PATTERNS\n    /*\n  \n    /!**\n     * Patterns of Wide / Narrow lines to indicate each digit\n     *!/\n    */\n    ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a;\n        // Find out where the Middle section (payload) starts & ends\n        var startRange = this.decodeStart(row);\n        var endRange = this.decodeEnd(row);\n        var result = new StringBuilder();\n        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n        var resultString = result.toString();\n        var allowedLengths = null;\n        if (hints != null) {\n            allowedLengths = hints.get(DecodeHintType.ALLOWED_LENGTHS);\n        }\n        if (allowedLengths == null) {\n            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n        }\n        // To avoid false positives with 2D barcodes (and other patterns), make\n        // an assumption that the decoded string must be a 'standard' length if it's short\n        var length = resultString.length;\n        var lengthOK = false;\n        var maxAllowedLength = 0;\n        try {\n            for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n                var value = allowedLengths_1_1.value;\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!lengthOK && length > maxAllowedLength) {\n            lengthOK = true;\n        }\n        if (!lengthOK) {\n            throw new FormatException();\n        }\n        var points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];\n        var resultReturn = new Result(resultString, null, // no natural byte representation for these barcodes\n        0, points, BarcodeFormat.ITF, new Date().getTime());\n        return resultReturn;\n    };\n    /*\n    /!**\n     * @param row          row of black/white values to search\n     * @param payloadStart offset of start pattern\n     * @param resultString {@link StringBuilder} to append decoded chars to\n     * @throws NotFoundException if decoding could not complete successfully\n     *!/*/\n    ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n        // Digits are interleaved in pairs - 5 black lines for one digit, and the\n        // 5\n        // interleaved white lines for the second digit.\n        // Therefore, need to scan 10 lines and then\n        // split these into two arrays\n        var counterDigitPair = new Int32Array(10); // 10\n        var counterBlack = new Int32Array(5); // 5\n        var counterWhite = new Int32Array(5); // 5\n        counterDigitPair.fill(0);\n        counterBlack.fill(0);\n        counterWhite.fill(0);\n        while (payloadStart < payloadEnd) {\n            // Get 10 runs of black/white.\n            OneDReader.recordPattern(row, payloadStart, counterDigitPair);\n            // Split them into each array\n            for (var k = 0; k < 5; k++) {\n                var twoK = 2 * k;\n                counterBlack[k] = counterDigitPair[twoK];\n                counterWhite[k] = counterDigitPair[twoK + 1];\n            }\n            var bestMatch = ITFReader.decodeDigit(counterBlack);\n            resultString.append(bestMatch.toString());\n            bestMatch = this.decodeDigit(counterWhite);\n            resultString.append(bestMatch.toString());\n            counterDigitPair.forEach(function (counterDigit) {\n                payloadStart += counterDigit;\n            });\n        }\n    };\n    /*/!**\n     * Identify where the start of the middle / payload section starts.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'start block' and end of\n     *         'start block'\n     *!/*/\n    ITFReader.prototype.decodeStart = function (row) {\n        var endStart = ITFReader.skipWhiteSpace(row);\n        var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n        // Determine the width of a narrow line in pixels. We can do this by\n        // getting the width of the start pattern and dividing by 4 because its\n        // made up of 4 narrow lines.\n        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n        this.validateQuietZone(row, startPattern[0]);\n        return startPattern;\n    };\n    /*/!**\n     * The start & end patterns must be pre/post fixed by a quiet zone. This\n     * zone must be at least 10 times the width of a narrow line.  Scan back until\n     * we either get to the start of the barcode or match the necessary number of\n     * quiet zone pixels.\n     *\n     * Note: Its assumed the row is reversed when using this method to find\n     * quiet zone after the end pattern.\n     *\n     * ref: http://www.barcode-1.net/i25code.html\n     *\n     * @param row bit array representing the scanned barcode.\n     * @param startPattern index into row of the start or end pattern.\n     * @throws NotFoundException if the quiet zone cannot be found\n     *!/*/\n    ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n        var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n        // if there are not so many pixel at all let's try as many as possible\n        quietCount = quietCount < startPattern ? quietCount : startPattern;\n        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n            if (row.get(i)) {\n                break;\n            }\n            quietCount--;\n        }\n        if (quietCount !== 0) {\n            // Unable to find the necessary number of quiet zone pixels.\n            throw new NotFoundException();\n        }\n    };\n    /*\n    /!**\n     * Skip all whitespace until we get to the first black line.\n     *\n     * @param row row of black/white values to search\n     * @return index of the first black line.\n     * @throws NotFoundException Throws exception if no black lines are found in the row\n     *!/*/\n    ITFReader.skipWhiteSpace = function (row) {\n        var width = row.getSize();\n        var endStart = row.getNextSet(0);\n        if (endStart === width) {\n            throw new NotFoundException();\n        }\n        return endStart;\n    };\n    /*/!**\n     * Identify where the end of the middle / payload section ends.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'end block' and end of 'end\n     *         block'\n     *!/*/\n    ITFReader.prototype.decodeEnd = function (row) {\n        // For convenience, reverse the row and then\n        // search from 'the start' for the end block\n        row.reverse();\n        try {\n            var endStart = ITFReader.skipWhiteSpace(row);\n            var endPattern = void 0;\n            try {\n                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n            }\n            catch (error) {\n                if (error instanceof NotFoundException) {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                }\n            }\n            // The start & end patterns must be pre/post fixed by a quiet zone. This\n            // zone must be at least 10 times the width of a narrow line.\n            // ref: http://www.barcode-1.net/i25code.html\n            this.validateQuietZone(row, endPattern[0]);\n            // Now recalculate the indices of where the 'endblock' starts & stops to\n            // accommodate\n            // the reversed nature of the search\n            var temp = endPattern[0];\n            endPattern[0] = row.getSize() - endPattern[1];\n            endPattern[1] = row.getSize() - temp;\n            return endPattern;\n        }\n        finally {\n            // Put the row back the right way.\n            row.reverse();\n        }\n    };\n    /*\n    /!**\n     * @param row       row of black/white values to search\n     * @param rowOffset position to start search\n     * @param pattern   pattern of counts of number of black and white pixels that are\n     *                  being searched for as a pattern\n     * @return start/end horizontal offset of guard pattern, as an array of two\n     *         ints\n     * @throws NotFoundException if pattern is not found\n     *!/*/\n    ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n        var patternLength = pattern.length;\n        var counters = new Int32Array(patternLength);\n        var width = row.getSize();\n        var isWhite = false;\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        counters.fill(0);\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                        return [patternStart, x];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException();\n    };\n    /*/!**\n     * Attempts to decode a sequence of ITF black/white lines into single\n     * digit.\n     *\n     * @param counters the counts of runs of observed black/white/black/... values\n     * @return The decoded digit\n     * @throws NotFoundException if digit cannot be decoded\n     *!/*/\n    ITFReader.decodeDigit = function (counters) {\n        var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n        var bestMatch = -1;\n        var max = ITFReader.PATTERNS.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = ITFReader.PATTERNS[i];\n            var variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n            else if (variance === bestVariance) {\n                // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                bestMatch = -1;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch % 10;\n        }\n        else {\n            throw new NotFoundException();\n        }\n    };\n    ITFReader.PATTERNS = [\n        Int32Array.from([1, 1, 2, 2, 1]),\n        Int32Array.from([2, 1, 1, 1, 2]),\n        Int32Array.from([1, 2, 1, 1, 2]),\n        Int32Array.from([2, 2, 1, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 2]),\n        Int32Array.from([2, 1, 2, 1, 1]),\n        Int32Array.from([1, 2, 2, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2]),\n        Int32Array.from([2, 1, 1, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 3, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 3]),\n        Int32Array.from([1, 3, 1, 1, 3]),\n        Int32Array.from([3, 3, 1, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 3]),\n        Int32Array.from([3, 1, 3, 1, 1]),\n        Int32Array.from([1, 3, 3, 1, 1]),\n        Int32Array.from([1, 1, 1, 3, 3]),\n        Int32Array.from([3, 1, 1, 3, 1]),\n        Int32Array.from([1, 3, 1, 3, 1]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/\n    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([1, 1, 2]),\n        Int32Array.from([1, 1, 3]) // 3x\n    ];\n    return ITFReader;\n}(OneDReader));\nexport default ITFReader;\n//# sourceMappingURL=ITFReader.js.map"]},"metadata":{},"sourceType":"module"}