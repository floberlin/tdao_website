'use strict';

var react = require('react');
var ReactDOM = require('react-dom');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function move(options) {
    var slidesPerView = options.slidesPerView, slideWidth = options.slideWidth, container = options.container, loop = options.loop, _a = options.animate, animate = _a === void 0 ? true : _a, speed = options.speed, leftStart = options.leftStart, deltaX = options.deltaX, rightStart = options.rightStart, curIndex = options.curIndex;
    if (!container)
        return;
    var startTime;
    var childrenNum = container.querySelectorAll(".swiper-slide").length;
    function moveAnimation(timestamp) {
        if (!startTime)
            startTime = timestamp;
        // elapsed: [0, 1], if it is not animated, elapsed always equals to 1
        var elapsed = animate ? Math.min((timestamp - startTime) / speed, 1) : 1;
        // transformX value
        var transform = leftStart + elapsed * deltaX;
        while (transform <= -childrenNum * slideWidth && loop)
            transform += childrenNum * slideWidth;
        while (transform > 0 && loop)
            transform -= childrenNum * slideWidth;
        var transformStrLeft = "translateX(" + transform + "px)";
        // use it when we have multiple slide in one view with last slide and first slide in the same view
        var transformRight = (rightStart + elapsed * deltaX) % (childrenNum * slideWidth);
        while (transformRight < 0)
            transformRight += childrenNum * slideWidth;
        var transformStrRight = "translateX(" + transformRight + "px)";
        for (var i = 0; i < childrenNum; i += 1) {
            var child = container.children[i];
            if (loop) {
                // when you swipe from left to right
                if (deltaX > 0) {
                    if (i >= curIndex + slidesPerView - childrenNum) {
                        child.style.transform = transformStrLeft;
                    }
                    else {
                        child.style.transform = transformStrRight;
                    }
                }
                else {
                    if (i >= curIndex) {
                        child.style.transform = transformStrLeft;
                    }
                    else {
                        child.style.transform = transformStrRight;
                    }
                }
            }
            else {
                // if there is no loop, transform value = transformStrLeft
                child.style.transform = transformStrLeft;
            }
        }
        if (elapsed < 1) {
            window.requestAnimationFrame(moveAnimation);
        }
    }
    window.requestAnimationFrame(moveAnimation);
}

function useAutoPlay(options) {
    var container = options.container, cb = options.cb, duration = options.duration, autoPlay = options.autoPlay;
    var timer = react.useRef(0);
    var _a = react.useState(false), pause = _a[0], setPause = _a[1];
    react.useEffect(function () {
        if (!container)
            return;
        var mouseOverEvent = function () { return setPause(true); };
        var mouseOutEvent = function () { return setPause(false); };
        container.addEventListener("mouseover", mouseOverEvent);
        container.addEventListener("mouseout", mouseOutEvent);
        return function () {
            container.removeEventListener("mouseover", mouseOverEvent);
            container.removeEventListener("mouseout", mouseOutEvent);
        };
    }, [container]);
    react.useEffect(function () {
        if (autoPlay) {
            timer.current = window.setInterval(function () {
                if (!pause) {
                    cb();
                }
            }, duration);
        }
        return function () {
            clearInterval(timer.current);
        };
    }, [pause, duration, cb, autoPlay]);
}

function useEventBinding(container, type, callback) {
    react.useEffect(function () {
        if (!container)
            return;
        container.addEventListener(type, callback);
        return function () { return container.removeEventListener(type, callback); };
    }, [container, callback, type]);
    return callback;
}

function getClientX(e) {
    return "touches" in e ? e.changedTouches[0].clientX : e.clientX;
}
function useEvent(options) {
    var container = options.container, curIndex = options.curIndex, speed = options.speed, setCurIndex = options.setCurIndex, loop = options.loop, slidesPerView = options.slidesPerView, draggable = options.draggable;
    var slideWidth = container ? container.clientWidth / slidesPerView : 0;
    var _a = react.useState(null), startClientX = _a[0], setStartClientX = _a[1];
    var dragStart = react.useCallback(function (e) {
        if (!draggable)
            return;
        e.preventDefault();
        setStartClientX(getClientX(e));
    }, [draggable]);
    var dragMove = react.useCallback(function (e) {
        if (!draggable)
            return;
        e.preventDefault();
        if (startClientX === null || !container)
            return;
        var clientX = getClientX(e);
        var deltaX = clientX - startClientX;
        var movedDelta = deltaX;
        var updatedIndex = curIndex;
        if (!loop && curIndex === 0 && deltaX > 0) {
            // if it is not loop and when it is first slide, movedDelta will be smaller than deltaX, create bounce back effect
            movedDelta = Math.pow(deltaX, 9 / 10);
        }
        var childrenNum = container.querySelectorAll(".swiper-slide").length;
        if (!loop && curIndex >= childrenNum - slidesPerView && deltaX < 0) {
            movedDelta = -Math.pow(-deltaX, 9 / 10);
        }
        if (deltaX > 0 && loop) {
            updatedIndex = curIndex - Math.floor(deltaX / slideWidth);
            while (updatedIndex <= 0)
                updatedIndex += childrenNum;
        }
        if (deltaX < 0 && loop) {
            updatedIndex =
                (curIndex + Math.floor(-deltaX / slideWidth)) % childrenNum;
        }
        move({
            slideWidth: slideWidth,
            slidesPerView: slidesPerView,
            container: container,
            loop: loop,
            speed: speed,
            leftStart: -curIndex * slideWidth,
            deltaX: movedDelta,
            curIndex: updatedIndex,
            rightStart: (childrenNum - curIndex) * slideWidth,
            animate: false
        });
    }, [
        draggable,
        container,
        loop,
        slideWidth,
        slidesPerView,
        speed,
        startClientX,
        curIndex
    ]);
    var dragEnd = react.useCallback(function (e) {
        if (!draggable)
            return;
        if (!container || startClientX === null)
            return;
        var clientX = getClientX(e);
        var deltaX = clientX - startClientX;
        if (deltaX === 0) {
            setStartClientX(null);
            return;
        }
        var movedDelta = deltaX;
        var updatedIndex = curIndex;
        var finalDelta = deltaX > 0 ? slideWidth - deltaX : -slideWidth - deltaX;
        var newIndex = curIndex;
        var childrenNum = container.querySelectorAll(".swiper-slide").length;
        if (deltaX < 0) {
            newIndex = (curIndex + 1) % childrenNum;
        }
        else if (deltaX > 0) {
            if (curIndex === 0) {
                newIndex = childrenNum - 1;
            }
            else {
                newIndex = curIndex - 1;
            }
        }
        if (!loop && curIndex === 0 && deltaX > 0) {
            movedDelta = Math.pow(deltaX, 9 / 10);
            finalDelta = -Math.pow(deltaX, 9 / 10);
            newIndex = curIndex;
        }
        if (!loop && curIndex >= childrenNum - slidesPerView && deltaX < 0) {
            movedDelta = -Math.pow(-deltaX, 9 / 10);
            finalDelta = Math.pow(-deltaX, 9 / 10);
            newIndex = curIndex;
        }
        if (deltaX > 0 && loop) {
            updatedIndex = curIndex - Math.floor(deltaX / slideWidth);
            while (updatedIndex <= 0)
                updatedIndex += childrenNum;
            newIndex = updatedIndex - 1;
            finalDelta = slideWidth - (deltaX % slideWidth);
        }
        if (deltaX < 0 && loop) {
            updatedIndex =
                (curIndex + Math.floor(-deltaX / slideWidth)) % childrenNum;
            newIndex = (updatedIndex + 1) % childrenNum;
            finalDelta = -slideWidth - (deltaX % slideWidth);
        }
        move({
            slideWidth: slideWidth,
            slidesPerView: slidesPerView,
            container: container,
            loop: loop,
            speed: speed,
            leftStart: -curIndex * slideWidth + movedDelta,
            deltaX: finalDelta,
            curIndex: updatedIndex,
            rightStart: (childrenNum - curIndex) * slideWidth + movedDelta,
            animate: true
        });
        setCurIndex(newIndex);
        setStartClientX(null);
    }, [
        draggable,
        container,
        curIndex,
        setCurIndex,
        slideWidth,
        slidesPerView,
        loop,
        speed,
        startClientX
    ]);
    useEventBinding(container, "mousedown", dragStart);
    useEventBinding(container, "touchstart", dragStart);
    useEventBinding(container, "mousemove", dragMove);
    useEventBinding(container, "touchmove", dragMove);
    useEventBinding(container, "mouseup", dragEnd);
    useEventBinding(container, "mouseleave", dragEnd);
    useEventBinding(container, "touchend", dragEnd);
}

function initPagination(container, pagination, curIndex, moveTo) {
    var oldPaginationNode = container.querySelector(".swiper-pagination-container");
    if (oldPaginationNode)
        container.removeChild(oldPaginationNode);
    var paginationContainer = document.createElement("div");
    paginationContainer.classList.add("swiper-pagination-container");
    var paginationList = [];
    var _loop_1 = function (i) {
        if (pagination === true) {
            var paginationItem = document.createElement("span");
            paginationItem.classList.add("swiper-pagination-dot");
            paginationItem.classList.add("swiper-pagination-dot__default");
            if (curIndex === i)
                paginationItem.classList.add("active");
            paginationItem.addEventListener("click", function () { return moveTo(i); });
            paginationContainer.appendChild(paginationItem);
        }
        else {
            var renderedComponent = typeof pagination === "function" ? pagination(i) : pagination;
            paginationList.push(react.cloneElement(renderedComponent, {
                onClick: function () { return moveTo(i); },
                className: (renderedComponent.props.className
                    ? renderedComponent.props.className
                    : "") + " swiper-pagination-dot " + (curIndex === i ? "active" : "")
            }));
        }
    };
    for (var i = 0; i < container.querySelectorAll(".swiper-slide").length; i += 1) {
        _loop_1(i);
    }
    if (paginationList.length) {
        ReactDOM__default['default'].render(paginationList, paginationContainer);
    }
    container.appendChild(paginationContainer);
}
function usePagination(options) {
    var container = options.container, pagination = options.pagination, curIndex = options.curIndex, moveTo = options.moveTo;
    react.useEffect(function () {
        if (!container || !pagination)
            return;
        var observer = new MutationObserver(function (mutationList) {
            if (mutationList.every(function (mutationRecord) {
                return Array.from(mutationRecord.addedNodes).every(function (node) {
                    return !node.classList.contains("swiper-pagination-container");
                }) &&
                    Array.from(mutationRecord.removedNodes).every(function (node) {
                        return !node.classList.contains("swiper-pagination-container");
                    });
            })) {
                initPagination(container, pagination, curIndex, moveTo);
            }
        });
        observer.observe(container, {
            childList: true,
            attributes: false,
            subtree: false
        });
        initPagination(container, pagination, curIndex, moveTo);
        return function () { return observer.disconnect(); };
    }, [container, curIndex, pagination, moveTo]);
    react.useEffect(function () {
        if (!container || !pagination)
            return;
        var paginationContainer = container.querySelector(".swiper-pagination-container");
        if (!paginationContainer)
            return;
        for (var i = 0; i < paginationContainer.children.length; i += 1) {
            var child = paginationContainer.children[i];
            if (i === curIndex) {
                child.classList.add("active");
            }
            else {
                child.classList.remove("active");
            }
        }
    }, [container, curIndex, pagination]);
}

function initNavigation(container, navigation, prev, next, arrowLeft, arrowRight) {
    if (navigation || arrowLeft || arrowRight) {
        var oldNavigationNode = container.querySelector(".swiper-navigation-container");
        if (oldNavigationNode)
            container.removeChild(oldNavigationNode);
        var navigationContainer = document.createElement("div");
        navigationContainer.classList.add("swiper-navigation-container");
        var navigationList = [];
        if (arrowLeft)
            navigationList.push(react.cloneElement(arrowLeft, {
                onClick: prev,
                className: (arrowLeft.props.className ? arrowLeft.props.className : "") + " swiper-navigation-left"
            }));
        if (arrowRight)
            navigationList.push(react.cloneElement(arrowRight, {
                onClick: next,
                className: (arrowRight.props.className ? arrowRight.props.className : "") + " swiper-navigation-right"
            }));
        if (navigationList.length) {
            ReactDOM__default['default'].render(navigationList, navigationContainer);
        }
        else {
            var navigationLeft = document.createElement("div");
            navigationLeft.classList.add("swiper-navigation-left");
            navigationLeft.classList.add("swiper-navigation-left__default");
            var navigationRight = document.createElement("div");
            navigationRight.classList.add("swiper-navigation-right");
            navigationRight.classList.add("swiper-navigation-right__default");
            navigationContainer.appendChild(navigationLeft);
            navigationContainer.appendChild(navigationRight);
            navigationLeft.addEventListener("click", prev);
            navigationRight.addEventListener("click", next);
        }
        container.appendChild(navigationContainer);
    }
}
function useNavigation(options) {
    var container = options.container, navigation = options.navigation, arrowLeft = options.arrowLeft, arrowRight = options.arrowRight, prev = options.prev, next = options.next;
    react.useEffect(function () {
        if (!container)
            return;
        var observer = new MutationObserver(function (mutationList) {
            if (mutationList.every(function (mutationRecord) {
                return Array.from(mutationRecord.addedNodes).every(function (node) {
                    return !node.classList.contains("swiper-navigation-container");
                }) &&
                    Array.from(mutationRecord.removedNodes).every(function (node) {
                        return !node.classList.contains("swiper-navigation-container");
                    });
            })) {
                initNavigation(container, navigation, prev, next, arrowLeft, arrowRight);
            }
        });
        observer.observe(container, {
            childList: true,
            attributes: false,
            subtree: false
        });
        initNavigation(container, navigation, prev, next, arrowLeft, arrowRight);
    }, [container, arrowLeft, arrowRight, prev, next, navigation]);
}

var isClient = typeof window === "object";

function useWindowSize() {
    var getSize = react.useCallback(function () {
        return {
            width: isClient ? window.innerWidth : 0,
            height: isClient ? window.innerHeight : 0
        };
    }, []);
    var _a = react.useState(getSize), windowSize = _a[0], setWindowSize = _a[1];
    react.useEffect(function () {
        function handleResize() {
            setWindowSize(getSize());
        }
        window.addEventListener("resize", handleResize);
        return function () { return window.removeEventListener("resize", handleResize); };
    }, [getSize]);
    return windowSize;
}

function useResponsive(optionsSnapshot) {
    var _a = react.useState(optionsSnapshot), realOptions = _a[0], setRealOptions = _a[1];
    var windowWidth = useWindowSize().width;
    react.useEffect(function () {
        var responsive = optionsSnapshot.responsive;
        if (!responsive)
            return;
        var responsiveIndex = 0;
        while (responsive[responsiveIndex] &&
            windowWidth > responsive[responsiveIndex][0]) {
            responsiveIndex += 1;
        }
        if (!responsive[responsiveIndex]) {
            setRealOptions(optionsSnapshot);
            return;
        }
        setRealOptions(responsive[responsiveIndex][1]);
    }, [optionsSnapshot, windowWidth]);
    return realOptions;
}

function init(container, slidesPerView) {
    container.classList.add("swiper-container");
    for (var i = 0; i < container.children.length; i += 1) {
        var child = container.children[i];
        if (child.classList.contains("swiper-pagination-container") ||
            child.classList.contains("swiper-navigation-container"))
            continue;
        child.classList.add("swiper-slide");
        child.style.width = (1 / slidesPerView) * 100 + "%";
    }
}
function useInit(options) {
    var container = options.container, setCurIndex = options.setCurIndex, slidesPerView = options.slidesPerView;
    react.useEffect(function () {
        if (!container)
            return;
        setCurIndex(0);
        var observer = new MutationObserver(function () {
            init(container, slidesPerView);
        });
        observer.observe(container, {
            childList: true,
            attributes: false,
            subtree: false
        });
        init(container, slidesPerView);
        return function () { return observer.disconnect(); };
    }, [setCurIndex, container, slidesPerView]);
}

function useSwiper(options) {
    if (options === void 0) { options = {}; }
    var optionsSnapshot = react.useState(__assign(__assign({}, options), { responsive: options.responsive
            ? options.responsive.sort(function (a, b) { return a[0] - b[0]; })
            : options.responsive }))[0];
    var realOptions = useResponsive(optionsSnapshot);
    var _a = realOptions.speed, speed = _a === void 0 ? 300 : _a, _b = realOptions.initial, initial = _b === void 0 ? 0 : _b, _c = realOptions.autoPlay, autoPlay = _c === void 0 ? false : _c, _d = realOptions.duration, duration = _d === void 0 ? 3000 : _d, _e = realOptions.loop, loop = _e === void 0 ? false : _e, _f = realOptions.slidesPerView, slidesPerView = _f === void 0 ? 1 : _f, _g = realOptions.pagination, pagination = _g === void 0 ? false : _g, _h = realOptions.navigation, navigation = _h === void 0 ? false : _h, _j = realOptions.draggable, draggable = _j === void 0 ? true : _j, arrowLeft = realOptions.arrowLeft, arrowRight = realOptions.arrowRight;
    var _k = react.useState(null), container = _k[0], setContainer = _k[1];
    var callbackRef = react.useCallback(function (instance) {
        setContainer(instance);
    }, []);
    var _l = react.useState(initial), curIndex = _l[0], setCurIndex = _l[1];
    var windowWidth = useWindowSize().width;
    var prev = react.useCallback(function () {
        setCurIndex(function (prev) {
            if (!container)
                return prev;
            if (!loop && prev === 0)
                return prev;
            var slideWidth = container.clientWidth / slidesPerView;
            var newIndex;
            var childrenNum = container.querySelectorAll(".swiper-slide").length;
            if (prev === 0) {
                newIndex = childrenNum - 1;
            }
            else {
                newIndex = prev - 1;
            }
            var updatedIndex = prev;
            while (updatedIndex <= 0)
                updatedIndex += childrenNum;
            move({
                slideWidth: slideWidth,
                slidesPerView: slidesPerView,
                container: container,
                loop: loop,
                speed: speed,
                leftStart: -prev * slideWidth,
                deltaX: slideWidth,
                curIndex: updatedIndex,
                rightStart: (childrenNum - prev) * slideWidth,
                animate: true
            });
            return newIndex;
        });
    }, [container, loop, slidesPerView, speed]);
    var next = react.useCallback(function () {
        setCurIndex(function (prev) {
            if (!container)
                return prev;
            var childrenNum = container.querySelectorAll(".swiper-slide").length;
            if (!loop && prev >= childrenNum - slidesPerView)
                return prev;
            var slideWidth = container.clientWidth / slidesPerView;
            move({
                slideWidth: slideWidth,
                slidesPerView: slidesPerView,
                container: container,
                loop: loop,
                speed: speed,
                leftStart: -prev * slideWidth,
                deltaX: -slideWidth,
                curIndex: prev,
                rightStart: (childrenNum - prev) * slideWidth,
                animate: true
            });
            return (prev + 1) % childrenNum;
        });
    }, [container, loop, slidesPerView, speed]);
    var moveTo = react.useCallback(function (index) {
        setCurIndex(function (prev) {
            if (!container)
                return prev;
            var childrenNum = container.querySelectorAll(".swiper-slide").length;
            var slideWidth = container.clientWidth / slidesPerView;
            move({
                slideWidth: slideWidth,
                slidesPerView: slidesPerView,
                container: container,
                loop: loop,
                speed: speed,
                leftStart: -prev * slideWidth,
                deltaX: (prev - index) * slideWidth,
                curIndex: prev,
                rightStart: (childrenNum - prev) * slideWidth,
                animate: true
            });
            return index;
        });
    }, [container, loop, slidesPerView, speed]);
    react.useEffect(function () {
        moveTo(curIndex);
        // eslint-disable-next-line
    }, [windowWidth]);
    useInit({
        container: container,
        setCurIndex: setCurIndex,
        slidesPerView: slidesPerView
    });
    useEvent({
        container: container,
        curIndex: curIndex,
        speed: speed,
        setCurIndex: setCurIndex,
        loop: loop,
        slidesPerView: slidesPerView,
        draggable: draggable
    });
    useAutoPlay({
        container: container,
        cb: next,
        duration: duration,
        autoPlay: autoPlay
    });
    useNavigation({
        container: container,
        navigation: navigation,
        prev: prev,
        next: next,
        arrowLeft: arrowLeft,
        arrowRight: arrowRight
    });
    usePagination({
        container: container,
        pagination: pagination,
        curIndex: curIndex,
        moveTo: moveTo
    });
    var slide = {
        ref: callbackRef,
        prev: prev,
        next: next,
        curIndex: curIndex,
        moveTo: moveTo
    };
    return slide;
}

module.exports = useSwiper;
